{"input":{"cteatedAt":"2021-02-17T21:41:48.472Z","url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/","host":"www.openmobilealliance.org"},"result":{"data":[{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/___read_for_SUP_and_RD_on_web_site.txt","file":"___read_for_SUP_and_RD_on_web_site.txt","status":"","version":"","date":"","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-ERELD-Browsing-V2_4-20080923-C.pdf","file":"OMA-ERELD-Browsing-V2_4-20080923-C.pdf","status":"Candidate","version":"V2.4","date":"2008-09-23","contentMediaType":"application/pdf","description":"The scope of this document is limited to the Enabler Release Definition of Browsing V2.4 according to OMA Release process and the Enabler Release specification baseline listed in section 5."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-ERP-Browsing-V2_4-20080923-C.zip","file":"OMA-ERP-Browsing-V2_4-20080923-C.zip","status":"Candidate","version":"V2.4","date":"2008-09-23","contentMediaType":"application/zip"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-RD-Browsing-V2_4-20080128-C.pdf","file":"OMA-RD-Browsing-V2_4-20080128-C.pdf","status":"Candidate","version":"V2.4","date":"2008-01-28","contentMediaType":"application/pdf","description":"This document defines the requirements for the second phase of the Browsing Enhancements work item. It addresses the requirements to enhance HTTP-based XHTML and other XML application user agents to meet the current market requirements like converged standards, composite document handling, enhanced security, and easy integration of applications. It will include convergence in XHTML Mobile Profile, WCSS, restructuring of WAEspec for integration usability, and rich dynamic media support (e.g. RME)."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-DTD_wml13-V1_3-20061020-A.txt","file":"OMA-SUP-DTD_wml13-V1_3-20061020-A.txt","status":"Approved","version":"V1.3","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-DTD_wml20-flat-V2_0-20061020-A.txt","file":"OMA-SUP-DTD_wml20-flat-V2_0-20061020-A.txt","status":"Approved","version":"V2.0","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-DTD_wml20-V2_0-20061020-A.txt","file":"OMA-SUP-DTD_wml20-V2_0-20061020-A.txt","status":"Approved","version":"V2.0","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-MOD_wml-deprecated-1-V2_0-20061020-A.txt","file":"OMA-SUP-MOD_wml-deprecated-1-V2_0-20061020-A.txt","status":"Approved","version":"V2.0","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-MOD_wml-framework-1-V2_0-20061020-A.txt","file":"OMA-SUP-MOD_wml-framework-1-V2_0-20061020-A.txt","status":"Approved","version":"V2.0","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-MOD_wml-qname-1-V2_0-20061020-A.txt","file":"OMA-SUP-MOD_wml-qname-1-V2_0-20061020-A.txt","status":"Approved","version":"V2.0","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-SUP-MOD_wml-special-1-V2_0-20061020-A.txt","file":"OMA-SUP-MOD_wml-special-1-V2_0-20061020-A.txt","status":"Approved","version":"V2.0","date":"2006-10-20","contentMediaType":"text/plain"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-TS-ESMP-V1_1-20080923-C.pdf","file":"OMA-TS-ESMP-V1_1-20080923-C.pdf","status":"Candidate","version":"V1.1","date":"2008-09-23","contentMediaType":"application/pdf","description":"Open Mobile Alliance (OMA) is a consortium of mobile industry companies working to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope for the OMA is to define a set of specifications to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, OMA defines a set of protocols in transport, session and application layers. For additional information on the Wireless Application Environment, refer to  [MAESPEC].  This specification describes the OMA wireless markup scripting language known as ECMAScript – Mobile Profile (ESMP). It is strongly based upon ECMAScript Release 3 [ECMA262] from the ECMA TC-39 Working Group. The same ECMA working group has also released a profile of the ECMAScript language for mobile devices [ECMA327]. The language has been modified to better support low bandwidth communication and thin clients. All changes from [ECMA327] are reflected in this specification and noted as static conformance requirements. ESMP should be used together with the OMA profile of the XHTML Markup Language [XHTMLMP] to provide added intelligence to the clients. The specification will concentrate on three areas: •Language differences between the ECMAScript Mobile Profile and Wireless Markup Scripting Language [WMLSCRIPT] •Language syntax differences between [ECMA262] and ECMAScript Mobile Profile. •The environment in which ECMAScript – Mobile Profile executes."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-TS-HTTPSM-V1_1-20080331-A.pdf","file":"OMA-TS-HTTPSM-V1_1-20080331-A.pdf","status":"Approved","version":"V1.1","date":"2008-03-31","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of work by the WAP Forum, now continued by the Open Mobile Alliance (OMA), to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope of OMA is to define a set of specifications to be used by service applications for wireless communication devices. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers.  For additional information on the WAP architecture, refer to \"Wireless Application Protocol Architecture Specification\" [WAP]. This specification defines the HTTP state management model for the WAP architecture.  The WAP HTTP state management model is an implementation of the HTTP State Management Mechanism, also known as \"cookie management\", as defined in [RFC2109].  On the World Wide Web, the HTTP State Management mechanism stores state information in a file (\"cookie\") on the client, as defined in [RFC2109].  The same mechanism can also be used over the WAP protocols, as HTTP headers are used to convey all state and state manipulation information. Some WAP user agents may have motivation to store and manage cookies locally, as defined in [RFC2965]. This functionality follows precisely the current World Wide Web model, where cookies are typically stored and managed by regular web browsers.  This specification defines an additional mechanism to let an intermediate proxy store and manage cookies on behalf of the WAP client, as an alternative to client-local storage and management. Storing cookies in the network has many advantages. WAP user agents may have a limited storing capacity. When cookies are stored in the proxy, they do not have to be transmitted across the air, for every request/response transaction. In case the user changes device, and cannot move the cookies from the old device to the new one, the user can still access the cookies in the proxy via the new device. On the other hand, storing and managing cookies in the client allows the user to gain the benefit of the same cookies independent of the access point used. This aspect becomes more important in the future in conjunction with WAP gateway roaming architecture.  Some users may prefer storing private information in the client, instead of depending on the security of the network. Because both models are complementary, this specification defines a dual approach to WAP HTTP state management, while still maintaining full interoperability between the implementations and RFC2965."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-TS-MAESpec-V2_4-20080923-C.pdf","file":"OMA-TS-MAESpec-V2_4-20080923-C.pdf","status":"Candidate","version":"V2.4","date":"2008-09-23","contentMediaType":"application/pdf","description":"The  Mobile  Application  Environment  (MAE)  is  part  of  the  Open  Mobile  Alliance's  effort  to  specify  an  application  framework for mobile terminals such as mobile phones, pagers, and PDAs. The primary focus is on the mobile browser. The framework  integrates,  extends  and  leverages  other  OMA  and  non-OMA  technologies,  including  session,  transport  and  security protocols, as well as other Internet technologies such as XML, URIs, scripting, and various media types.  This effort enables  operators,  manufacturers,  and  content  developers  to  meet  the  challenges  in  building  advanced  and  differentiated  services and implementations in a fast and flexible manner This document provides a general overview of the overall MAE architecture and builds on the convergence with the Internet achieved in the previous WAE convergence releases, WAE versions 2.0 and above. This specification also represents the root document  of  the  Mobile  Application  Environment  (MAE)  version  2.4  specification  hierarchy,  i.e.,  the  normative  document  hierarchy  for  both  the  required  and  optional  features  which  mostly  are  specified  in  other  documents.  For  additional  information on the WAP architecture, refer to “Wireless Application Protocol Architecture Specification” [WAPArch] Note：MAE is formerly known as WAE (Wireless Application Environment). MAE, as a term, may be used interchangeably with WAE, otherwise terms are clearly distinguished."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-TS-UACACHE-V1_1-20080331-A.pdf","file":"OMA-TS-UACACHE-V1_1-20080331-A.pdf","status":"Approved","version":"V1.1","date":"2008-03-31","contentMediaType":"application/pdf","description":"This specification defines the caching model for the OMA application environment. The OMA caching model is an implementation of the HTTP/1.1 caching model used on the World Wide Web. The design is intended to allow the adoption of the HTTP/1.1 caching model with no loss of semantics or function while providing support for OMA enabled devices. See [RFC2616] for more information on HTTP/1.1 caching.  Even though WAP is considered as a deprecated technology this specification also contains specific responsibilities for WAP User Agents and WAP Gateways for historical backwards compatibility reasons, Wireless Application Protocol (WAP) is a result of continuous work by the WAP Forum, now continued by the Open Mobile Alliance (OMA), to define an industry-wide specification for developing applications that operate over wireless communication networks. For additional information on the WAP architecture, refer to \"Wireless Application Protocol Architecture Specification\" [Error! Reference source not found.].  This specification addresses the following issues: •User agent caching of resources fetched from the network •Rules for calculation of freshness lifetime of a cached resource. •Security considerations •WAP user agent and WAP Gateway responsibilities (included for historical reasons) oWML history cache interaction oCaching rules for intra-resource interaction within WML decks and WMLScripts oWSP time of day header handling oWAP Gateway behavior – the role and responsibility of the WAP Gateway in the implementation of reliable caching."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-TS-WCSS-V1_2-20080923-C.pdf","file":"OMA-TS-WCSS-V1_2-20080923-C.pdf","status":"Candidate","version":"V1.2","date":"2008-09-23","contentMediaType":"application/pdf","description":"This section is informative. Wireless CSS specifies a subset of CSS2.1 [[CSS21Error! Reference source not found.] and mobile extensions defined by OMA. It can be used to style XHTML Mobile Profile [[XHTMLMP] documents, as well as any other XML document.  The CSS2 subset contains core CSS functionality such as inheritance, cascading, selectors, and the syntax. It also contains properties for the box layout model, text, fonts, visual effects, colour, and lists. The following CSS extensions are specified: •Marquee - properties to create simple animation effects. Typically this will be used to create scrolling text.  •Input – (Obsoleted)- properties to specify the format of the user input into a form control. It is the same feature as the WML ‘format’ and ‘emptyok’ attributes provide. •Accesskey – (Obsolete)- property to specify an optional, additional way to activate an element in a document. It is similar to the feature the HTML ‘accesskey’ attribute provides.  A subset of CSS2 is also specified in the W3C, the “W3C CSS Mobile Profile 2.0” Candidate Recommendation [[CSSMP]. Since both CSS2 variants follow CSS user agent semantics, conforming Wireless CSS user agents will accept valid W3C CSS Mobile Profile style sheets."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-TS-XHTMLMP-V1_3-20080923-C.pdf","file":"OMA-TS-XHTMLMP-V1_3-20080923-C.pdf","status":"Candidate","version":"V1.3","date":"2008-09-23","contentMediaType":"application/pdf","description":"This specification defines the markup language XHTML Mobile Profile version 1.3 (XHTML Mobile Profile 1.3 or XHTML MP 1.3), a language designed for resource-constrained Web clients.  XHTML Mobile Profile 1.3 is targeted at devices such as mobile phones, PDAs, pagers and set-top boxes that do not support the full set of XHTML features.  Syntax for XHTML MP 1.3 has converged with syntax for XHMTL Basic 1.1.  This specification further clarifies the execution environment in which XHTML MP 1.3 is used and extends the execution environment conformance requirements to foster interoperability. For the Document Type Definition for XHTML Mobile Profile 1.3 this specification uses the XHTML Basic 1.1 Document Type Defintion. In addition  the XHTML Mobile Profile 1.3 specification defines conformance requirements for user agents that process XHTML Mobile Profile 1.3 documents."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/OMA-WAP-TS-Pictogram-V1_1-20061020-A.pdf","file":"OMA-WAP-TS-Pictogram-V1_1-20061020-A.pdf","status":"Approved","version":"V1.1","date":"2006-10-20","contentMediaType":"application/pdf","description":"This section is informative. Wireless Application Protocol (WAP) is a result of continuous work to define an industry wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a set of specifications to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers. For additional information on the WAP architecture, refer to “Wireless Application Protocol Architecture Specification” [ARCH]. This specification defines the common pictogram set and its architecture. The common pictogram set is a set of pictograms that the user agents (e.g., mobile phones) may internally have their images, and content authors may use these images in the contents without increasing network traffics. On the other hand, manufactures may install images of pictograms that were appropriate for the device (e.g., size, colour, image format, etc.). To meet the requirement of the world wide market, the common pictogram set is classified into several classes. For example, some pictograms have operational, culture and time independent semantics and intended to be used generally. The other pictograms are glossary of symbols that represent certain embodiments. Such pictograms are classified into different classes.  The bundles of images could be added to the device as a collection of pictogram in a class. The image bundles could be factory installed, network operators updated, or end user controlled. Images of pictograms could be stored into permanent or temporary storage of the device.  Some user agents that are not capable of displaying images may have alternative way to present pictograms: e.g., character only device may display alternative text instead of its image.  This specification defines a set of semantics of pictogram. However glyphs of pictograms, which represent the image the pictogram may have when they are rendered or displayed, are out of scope of this document."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-161-WMLScriptCrypto-20010620-a.pdf","file":"WAP-161-WMLScriptCrypto-20010620-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a set of standards to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers. For additional information on the WAP architecture, refer to Wireless Application Protocol Architecture Specification [WAPARCH].  This document specifies the library interface for WMLScript [WMLScript] to provide cryptographic functionality of a WAP client. In addition this document specifies a signed content format to be used to convey signed data to/from WAP devices. This functionality complements transport layer security provided by [WAPWTLS].   The notation and other conventions related to describing a WMLScript library are according to [WMLScript] and [WMLSSL].     (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 5(27)  2.   Document Status This document is available online in the following formats:  • PDF format at http://www.wapforum.org/.   2.1  Copyright Notice © Copyright Wireless Application Protocol Forum Ltd, 2001 all rights reserved.   2.2  Errata Known problems associated with this document are published at http://www.wapforum.org/.   2.3  Comments Comments regarding this document can be submitted to the WAP Forum in the manner published at http://www.wapforum.org/.     (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 6(27)  3.   References 3.1  Normative references [ASN1] ISO/IEC 8824-1:1995 Information technology – Abstract Syntax Notation One (ASN.1) – Specification of basic notation. [DER] ISO/IEC 8825-2:1995 Information technology – ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER). [ECMA262] Standard ECMA-262: \"ECMAScript Language Specification\", ECMA, June 1997 [IEEE754] ANSI/IEEE Std 754-1985: \"IEEE Standard for Binary Floating-Point Arithmetic\". Institute of Electrical and Electronics Engineers, New York (1985). [PKCS1] PKCS #1: RSA Encryption Standard”, version 1.5, RSA Laboratories, November 1993. [PKCS7] PKCS #7: Cryptographic Message Syntax Standard, version 1.5, RSA Laboratories, November 1993. [PKCS9] PKCS #9: Selected Attribute Types, version 1.1, RSA Laboratories, November 1993. [PKCS15] PKCS #15: Cryptographic Token Information Standard”, version 1.0, RSA Laboratories, April 1999. URL: ftp://ftp.rsa.com/pub/pkcs/pkcs-15/pkcs15v1.doc [RFC1521]  “MIME (Multipurpose Internet Mail Extensions), Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies”, N. Borenstein, et al, September 1993. URL: ftp://ftp.isi.edu/in-notes/rfc1521.txt [RFC1738] \"Uniform Resource Locators (URL)\", T. Berners-Lee, et al., December 1994. URL: ftp://ftp.isi.edu/in-notes/rfc1738.txt [RFC1808] \"Relative Uniform Resource Locators\", R. Fielding, June 1995. URL: ftp://ftp.isi.edu/in-notes/rfc1808.txt [RFC2119] \"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March 1997. URL: ftp://ftp.isi.edu/in-notes/rfc2119.txt [RFC2459] \"Internet X.509 Public Key Infrastructure, Certificate and CRL Profile\", R. Housley, at al., January  1999. URL: ftp://ftp.isi.edu/in-notes/rfc2459.txt [RFC2560] “X.509 Internet Public Key Infrastructure: Online Certificate Status Protocol – OCSP”, M. Myers, R. Akney, A. Malpani, S. Galperin, and C. Adams; IETF RFC 2560, June 1999. [UNICODE] \"The Unicode Standard: Version 2.0\", The Unicode Consortium, Addison-Wesley Developers Press, 1996. URL: http://www.unicode.org/ [UTF8]    \"UTF-8, a transformation format of Unicode and ISO 10646\", F. Yergeau, January 1998.  URL:ftp://ftp.isi.edu/in-notes/rfc2279.txt [WAPARCH] \"Wireless Application Protocol Architecture Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WAPWIM] “WAP Identity Module”, WAP-260-WIM, WAP Forum Ltd. URL:http//www.wapforum.org/ [WAPWTLS] \"Wireless Transport Layer Security\", WAP-261-WTLS, WAP Forum Ltd. URL: http://www.wapforum.org/ [WML] \"Wireless Markup Language Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 7(27) [WMLScript] \"WMLScript Language Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WMLSSL] \"WMLScript Standard Libraries Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WAPCREQ]  \"Specification of WAP Conformance Requirements\", WAP-221-CREQ, WAP Forum Ltd, URL:http//www.wapforum.org/\" [X9.62]  “The Elliptic Curve Digital Signature Algorithm (ECDSA)”, ANSI X9.62 Working Draft, September  1998. 3.2  Informative References [JavaScript] \"JavaScript: The Definitive Guide\", David Flanagan. O'Reilly & Associates, Inc. 1997 [RFC2068] \"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, et al., January 1997.  URL: ftp://ftp.isi.edu/in-notes/rfc2068.txt [WAE] \"Wireless Application Environment Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WSP] \"Wireless Session Protocol\", WAP Forum, 1998. URL: http://www.wapforum.org/ [XML] \"Extensible Markup Language (XML), W3C Proposed Recommendation 10-February-1998, REC-xml-19980210\", T. Bray, et al, February 10, 1998.  URL: http://www.w3.org/TR/REC-xml    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 8(27)  4.   Definitions and Abbreviations 4.1  Definitions The following are terms and conventions used throughout this specification.   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",  \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\" and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].  Please refer to [WMLScript] and [WMLSS] for WMLScript related terminology.   4.2  Abbreviations For the purposes of this specification, the following abbreviations apply:  API Application Programming Interface CA Certification Authority ECMA European Computer Manufacturer Association HTTP HyperText Transfer Protocol [RFC2068] LSB Least Significant Bits MSB Most Significant Bits PKCS Public-Key Cryptography Standards RFC Request For Comments RSA Rivest Shamir Adleman public key algorithm SHA Secure Hash Algorithm UI User Interface URL Uniform Resource Locator  W3C World Wide Web Consortium WWW World Wide Web WSP Wireless Session Protocol WTLS Wireless Transport Layer Security WTP Wireless Transport Protocol WAP Wireless Application Protocol WAE Wireless Application Environment WTA Wireless Telephony Applications WTAI Wireless Telephony Applications Interface WBMP Wireless BitMaP WIM WAP Identity Module    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 9(27)  5.   Cryptographic Library Description   Name: Crypto Library ID: 6 Description: This library contains cryptographic functions.   The current library specification supports digital signature functionality . Other functionality (like encryption/decryption or symmetric key based MAC) may be added in future versions.  5.1  signText 5.1.1  Introduction  Many kinds of applications, e.g., electronic commerce, require the ability to provide persistent proof that someone has authorised a transaction. Although WTLS [WAPWTLS] provides transient client authentication for the duration of a WTLS connection, it does not provide persistent authentication for transactions that may occur during that connection. One way to provide such authentication is to associate a digital signature with data generated as the result of a transaction, such as a purchase order or other financial document.   To support this requirement, the browser provides a WMLScript function, Crypto.signText, that asks the user to sign a string of text. A call to the signText method displays the exact text to be signed and asks the user to confirm that. After the data has been signed and both the signature and the data have been sent across the network, the server can extract the digital signature and validate it, and possibly store it for accountability purposes.   The browser SHOULD use special signature keys that are distinct from authentication keys used for WTLS. A WIM [WAPWIM] may be used for private key storage and signature computation.       (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 10(27)  5.1.2  signText function definition   Function: signedString = Crypto.signText(stringToSign, options, keyIdType, keyId) Function ID: 16 Description: The function requests that a user digitally signs a text string. The calling script provides the text to sign (stringToSign) which MUST be displayed to the user. The user may choose either to cancel or approve the signing operation. If several certificates are available that match the criteria indicated in parameters, the choices should be indicated to the user, using e.g., labels of the certificates. If the user approves the operation, the browser MUST ask for user verification information for the private key (e.g., the WIM PIN for a non-repudiation key). If the user enters the correct information, signText signs the specified string and returns signedString to the script as String, formatted as base-64 [RFC1521] encoding of SignedContent.     (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 11(27) Parameters: stringToSign = String A string which MUST be displayed to the user. In case the string is a concatenation of strings in different character sets, the implementation has to convert the string to a certain single encoding, before processing in this function. The recommended encoding method is UTF-8 [UTF8].  options = Integer Contains several option values, ORed together: 0x0001 – INCLUDE_CONTENT. If this option is set, the browser MUST include the stringToSign in the result. 0x0002 – INCLUDE_KEY_HASH. If this option is set, the browser MUST include the hash of the public key corresponding to the signature key in the result. 0x0004 – INCLUDE_CERTIFICATE. If this option is set, the browser MUST include the certificate or a URL of the certificate in the result (whether the browser includes the certificate content or a URL depends on which one is available). If the browser does not have access to a certificate, it MUST return “error:noCert”. keyIdType = Integer Indicates the type of a key identifier: 0 – NONE. No key identifier is supplied. The browser may use any key and certificate available. 1 – USER_KEY_HASH. A SHA-1 hash of the user public key is supplied in the next parameter. The browser MUST use the signature key that corresponds to the given public key hash or, if this key is not available, return “error:noCert”. 2 – TRUSTED_KEY_HASH. A SHA-1 hash of a trusted CA public key (or multiple of them) is supplied in the next parameter. The browser MUST use a signature key that is certified by the indicated CA (or some of them). If no such key is available, the browser MUST return “error:noCert”.  keyId = String Identifies the key in a way based on the previous parameter.  For a SHA-1 public key hash, contains the 20-byte hash. Multiple values may be  concatenated. Number of elements in the list is implied by the length of the parameter.    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 12(27) Return value: String or Invalid. The content of the return string is the following • in case of a succesful operation, the base-64 [RFC1521] encoding of SignedContent • if there is no proper certificate or signature key available, the string “error:noCert” • if the user cancelled the operation, the string “error:userCancel” Exceptions: Errors in parameters, encoding or internal errors result in an invalid return value. Example: var foo = Crypto.signText(\"Bill of Sale\\n------------------\\n3 Bolognese $18.00\\n1 Pepperoni  $7.00\\n4 Lemonade   $6.00\\n------------------\\nTotal Price $31.00\",  0, 1, \"\\x37\\x00\\xB6\\x96\\x37\\x75\\xE3\\x93\\x48\\x74\\xD3\\x98\\x47\\x53\\x94\\x34\\x58\\x97\\xB5\\xD6\"); // The application indicates the signature key    5.1.3   Handling of Certificates For verification of the digital signature, the server must have access to a user’s certificate that is signed by a Certification Authority (CA) recognised by the server. There are several possibilities for how the server can get access to the user’s certificate: 1. The certificate is appended to the signature.  2. The public key hash is appended to the signature. The server is able to fetch the corresponding certificate from a certificate service. 3. A URL of the certificate is appended to the signature. The server is able to fetch the certificate using internet methods. 4. The server knows the user certificate based on a previous data exchange with the user, e.g., a previous digital signature.   5.1.4   Implementation using the WIM This chapter describes how to implement the signText function using the WIM [WAPWIM].   A non-repudiation key is used for signing. This implies usage of a an authentication object used for this key only, and that the verification requirement cannot be disabled. E.g., in case of a PIN, the PIN MUST be entered separately for each signature operation.  The PKCS#15 key ID (commonObjectAttributes.id) has the value of the public key hash. So, it can be used to find the proper key or certificate, if the key is identified by USER_KEY_HASH. The certificate issuer public key hash (PKCS15CommonCertificateAttributes.requestId) can be used to find a proper certificate, if it is identified by TRUSTED_KEY_HASH.  Labels, contained in entries that describe private keys and certificates (commonObjectAttributes.label) SHOULD be used to display options to use for signing.      (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 13(27) For a smart card implementation, the procedure is described in [WAPWIM], chapter 11.4.6.    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 14(27)  6.   Format of SignedContent This section defines a format for transmission of signed content to/from WAP devices. It is described below using WTLS presentation [WAPWTLS]. Hash values of authenticated attributes are computed using a PKCS#7 template to provide end-to-end authentication between WAP clients and devices supporting the PKCS#7 standard for signed data representation.  enum {null(0), rsa_sha_pkcs1(1), ecdsa_sha_p1363(2), (255)} DataSignatureAlgorithm;  Item Description null No signature present. rsa_sha_pkcs1 The signature is calculated according to [PKCS1] (see Appendix B), using octet string output. ecdsa_sha The signature is calculated according to [X9.62], using octet string output.   struct {   DataSignatureAlgorithm algorithm;   switch (algorithm) {    case null: struct {};    default: opaque signature<0..2^16-1>;   }; } Signature;   enum { implicit(0), sha_key_hash(1), wtls_certificate(2), x509_certificate(3), x968_certificate(4), certificate_url(5), (255)} SignerInfoType;  Item Description implicit The signer is implied by the content. sha_key_hash The SHA-1 hash of the public key,  encoded as specified in [WAPWTLS].  wtls_certificate A WTLS certificate. x509_certificate An X.509v3  certificate. x968_certificate An X9.68 certificate. certificate_url A URL where the certificate is located.  struct {  SignerInfoType signer_info_type;  switch (signer_info_type) {    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 15(27)      case implicit: struct{};    case sha_key_hash:     opaque hash[20];    case wtls_certificate:     WTLSCertificate;    case x509_certificate:     opaque x509_certificate<0..2^16-1>; case x968_certificate:  opaque x968_certificate<0..2^16-1; case certificate_url:     opaque url<0..255>;   }; } SignerInfo;   enum {text(1), data(2), (255)} ContentType;  Item Description text Encoded text (according to character set). data Encoded data (encoding indicated by content_encoding parameter, see below).   enum (false(0), true(1)} Boolean;  struct {   ContentType content_type;   uint16 content_encoding;  Boolean content_present;   switch (content_present) {    case false: struct{};    case true: opaque content<0..2^16-1>;   }; } ContentInfo;  Item Description content_type The type of the content that was signed. content_encoding For text type of content, indicates the character set used to encode the text before signing (IANA assigned character set number, see [WAPWSP]). The recommended character set is UTF-8 [UTF8]. Note that the hash is calculated over the encoded text (no length indication, terminating character or character set indicator is included). For data type of content, indicates a specific content type (assigned values are not defined yet).  content_present Indicates if the content is present in the structure. content Content.    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 16(27)   enum { gmt_utc_time(1), signer_nonce(2), (255) } AttributeType;  Item Description gmt_utc_time The current time and date in UTC format (see Appendix C). Only the 12 actual date/time octet values are included; the trailing ‘Z’, indicating GMT or Zulu, is omitted since it is implicit. signer_nonce A nonce generated by the signer. This attribute MAY be used by devices that do not have an internal clock.   struct {  AttributeType attribute_type;  switch (attribute_type) {   case gmt_utc_time: uint8[12];   case signer_nonce: opaque signer_nonce[8];   } } AuthenticatedAttribute;   struct {  uint8 version;  Signature signature;  SignerInfo signer_infos<0..2^16-1>;  ContentInfo content_info;   AuthenticatedAttribute authenticated_attributes<0..255>; } SignedContent;  Item Description version Version of the SignedContent structure. For this specification the version is 1. signature Signature signer_infos Information on the signer. This may contain zero items (in case the signer is implicit). Also, there may be multiple items of SignerInfo present (public key hash and a certificate). content_info Information about the content being signed. The actual content is optionally included in the structure. authenticated_ attributes Attributes that are included in the signature.  6.1.  Usage with signText The result returned by signText is formatted as SignedContent.  The original stringToSign is optionally included in the structure. It is the responsibility of the application that the verifying party (server) will have access both to the original text and the signature. The text may be generated in the    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 17(27) server and cached there. Or, if the text is generated in the client (e.g., based on user input), it should be included in the structure.  The verification service must take the character set into account. If the original service generated the stringToSign, it is necessary to convert that to a proper character set encoding.  6.2.  Hash Calculation and Relationship to PKCS#7 SignedData The signed content type is defined so as to allow end-to-end authentication of signed content based on PKCS#7 [PKCS7] signed data structures. A proxy server or gateway may accept a PKCS#7 signed data object and convert to the WAP signed content type without violating the end-to-end integrity of the signature. This is done by compressing the PKCS#7 header (by representing it in WTLS encoding format) without information loss. Since the mobile device can reconstruct the original header with any authenticated attributes it can verify the original signature.   When a mobile device is sending signed content it constructs the PKCS#7 header using a static template and filing in the relevant attribute values. The hash is computed as specified in [PKCS7]. The mobile device then formats and sends the SignedContent type. This allows a proxy or gateway to convert this back to PKCS#7 format for transmission to a server. In this way we achieve both bandwidth efficiency and limited parsing requirements on the mobile device while enabling end-to-end signed content verification with servers not supporting the WAP signed content type.  The hash calculation on the mobile device is performed as defined in [PKCS7], using the signer's authenticated attributes. This requires that the input for the hash calculation is represented in ASN.1 DER encoding. As shown below, complex DER encoding is not required, since the length of the values are known beforehand. An implementation needs only the (static)  PKCS#7 DER structure, filing in the variable fields. It need not understand the specifics of the ASN.1 encoding.  According to [PKCS7], the mandatory authenticated attributes are the contentType and messageDigest attributes (hash of the original data). Additionally, either signing time or a random nonce MUST be used as an authenticated attribute. Signing time is recommended. A random number MAY be used by implementations that do not support real time clock.   The message-digesting process computes a message digest on the content together with the signer's authenticated attributes. The initial input to the message-digesting process is the value of the content being signed.   The authenticated attributes are the following [PKCS9].  Attribute OID OID in Binary contentType pkcs9-3 2a 86 48 86 f7 0d 01 09 03 messageDigest pkcs9-4 2a 86 48 86 f7 0d 01 09 04 signingTime pkcs9-5 2a 86 48 86 f7 0d 01 09 05 signerNonce pkcs9-25-3 2a 86 48 86 f7 0d 01 09 19 03   To calculate the hash, the signer uses the following buffer as a template:    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 18(27)  31 5d    30 18       06 09 2a 86 48 86 f7 0d 01 09 03 – contentType       31 0b          06 09 2a 86 48 86 f7 0d 01 07 01 -- data    30 1c       06 09 2a 86 48 86 f7 0d 01 09 05 – signingTime       31 0f          17 0d XX XX XX XX XX XX XX XX XX XX XX XX XX -- UTCTime     30 23       06 09 2a 86 48 86 f7 0d 01 09 04 – messageDigest       31 16          04 14 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX                 -- SHA-1 digest  In order to construct the input for hash calculation, the following steps are performed • use initially a 95-byte buffer as above (bytes 1...95) • replace bytes 46...58 with the value of UTC time expressed as YYMMDDHHMMSSZ (ASCII-encoded) • replace bytes 76...95 with the 20-byte value of the SHA-1 hash of the content value  The next step is to calculate the hash from the above 95-byte buffer. Finally, the signature is calculated.   Note that the PKCS#7 contentType “data” is used for both  text and data content types specified in the beginning of this chapter.   Note also that since the input to the message digesting process is the content value (and not for example \"ContentInfo\" as defined in Section 6), the information about the character set associated with the content is not protected. Implementations should therefore take steps to ensure that it is not possible for an attacker to harmfully manipulate this character set information.  For verification, the above structure needs to be constructed based on values transmitted in  SignedContent: content_type,  gmt_utc_time.   Note that the authenticated attributes are included in the in ascending order compared as octet strings.  A proxy server MAY construct a PKCS#7 [PKCS7] SignedData object based on a received SignedContent object. The motivation of doing this would be that some internet or other service applications may require a PKCS#7 formatted object to verify the signature. The conversion to PKCS#7 is based on the original text, the signature and a certificate.   A proxy server MAY also convert a PKCS#7 SignedData object to a SignedContent object for transmission to a mobile device.  When the mobile device receives (e.g. over WSP) a SignedContent object (containing text or any type of data), it should verify the signature and be able to present information on the signer and the result    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 19(27) of verification: if it was succesful, or if it failed with different reasons, like invalid signature or inability to verify the signer's certificate. When the SignedContent object contains signed text, the original text and result of verification must be presented in a manner which is distinctive from texts generated by applications using e.g. WML or WMLScript.   When using an 8-byte signerNonce instead of signingTime (as described above), the following buffer is used as a template:  31 59     30 18        06 09 2A 86 48 86 F7 0D 01 09 03   -- contentType       31 0B           06 09 2A 86 48 86 F7 0D 01 07 01  -- data    30 18  06 0A 2A 86 48 86 F7 0D 01 09 19 03  -- signerNonce 31 0A     04 08 XX XX XX XX XX XX XX XX  -- randomNonce    30 23  06 09 2A 86 48 86 F7 0D 01 09 04   -- messageDigest 31 16     04 14 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    -- SHA-1 digest  In order to construct the input for hash calculation, the following steps are performed • use initially a 91-byte buffer as above (bytes 1...91) • replace bytes 47...54 with the value of the 8 byte nonce. • replace bytes 72...91 with the 20-byte value of the SHA-1 hash  The next step is to calculate the hash from the above 91-byte buffer. Finally, the signature is calculated.     (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 20(27)    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 21(27) Appendix A  Library Summary The libraries and their library identifiers:  Library name Library ID Page Crypto 6 8   The libraries and their functions:  Crypto library Function ID SignText 16     (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 22(27)    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 23(27) Appendix B  Signature Calculation  B.1 ECDSA Signature Calculation  ECDSA signature calculation for signText is based on ANSI X9.62 [X9.62].  Three aspects of the ECDSA signature process are described: • the input to the signature process; • the signature process itself; and • the output from the signature process.  The input to the ECDSA signature process is one of the completed templates specified in Section 6.2.  Note that ANSI X9.62 regards hashing as an integral part of the signing process – thus the completed template will be hashed using SHA-1 as required during the signing process.  The ECDSA signature process is then performed on the completed template as specified in Section 5.3 of ANSI X9.62.  The output of the ECDSA signature process is a pair of integers r and s. Here the ECDSA signature is converted to a byte string for inclusion in the “Signature” field of “SignedContent” as specified in Section 6 as follows: Convert the integer r to an octet string R and the integer s to an octet string S using the conversion routine specified in Section 4.3.1 of ANSI X9.62 [X9.62]. Both R and S should be the same length as the length needed to represent the order of the base point G. The signature is represented as the concatenation of R and S: R | S.  Note that the signature will subsequently be re-encoded using the ASN.1 syntax for an ECDSA signature specified in Section of ANSI X9.62 if the “SignedContent” format specified in Section 6 is converted to PKCS7 CMS format.  Recommended curves for use with ECDSA are described in Appendix A of WTLS [WAPWTLS].    (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 24(27) B.2 RSA PKCS#1 Signature Calculation  The calculation is based on [PKCS1], chapter 10.1. It consists of three steps: message digesting (hashing), data encoding and RSA encryption. (The fourth step, octet-string-to-bit-string conversion is not necessary here.)  The message (the text being signed) is digested using SHA-1 [SHA1]. The 20-byte output and a SHA-1 algorithm identifier shall be combined into an ASN.1 [ASN1] value of type DigestInfo, described below, which shall be DER-encoded [DER] to give an octet string, the data.  DigestInfo ::= SEQUENCE {    digestAlgorithm DigestAlgorithmIdentifier,    digest Digest }  DigestAlgorithmIdentifier ::= AlgorithmIdentifier  Digest ::= OCTET STRING  digestAlgorithm identifies the message-digest algorithm. For this application, it should associate the SHA-1 algorithm. The object identifier is the following  sha-1 OBJECT IDENTIFIER ::=  { iso(1) identified-organization(3)  oiw(14) secsig(3) 2 26 }  The BER encoding of the above is:  2b 0e 03 02 1a  digest is the result of the message digesting process, ie, the message digest.  The BER encoding of DigestInfo is  30 21           -- SEQUENCE (DigestInfo)  30 09          -- SEQUENCE (AlgorithmIdentifier)          06 05 2b 0e 03 02 1a   -- digestAlgorithm = sha-1   05 00         -- parameters = NULL  04 14          -- OCTET STRING (digest)   xx xx xx xx       -- digest value xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx xx   where the last 20 bytes is the message digest. So, in order to implement the BER-encoded DigestInfo, it is sufficient to concatenate the constant 15 bytes and the 20 bytes of the hash.   The resulting data (BER-encoded DigestInfo), is encrypted with the signer’s private key as described in [PKCS1] section 7, using the block type 1. The resulting octet string, is the signature.      (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 25(27) Appendix C  UTC Time The universal time type, UTCTime, is a standard ASN.1 type intended for international applications where local time alone is not adequate.  UTCTime specifies the year through the two low order digits and time is specified to the precision of one minute or one second.  UTCTime includes either Z (for Zulu, or Greenwich Mean Time) or a time differential.  For the purposes of this profile, UTCTime values MUST be expressed Greenwich Mean Time (Zulu) and MUST include seconds (i.e., times are YYMMDDHHMMSSZ), even where the number of seconds is zero.  Conforming systems MUST interpret the year field (YY) as follows:  Where YY is greater than or equal to 50, the year shall be interpreted as 19YY; and where YY is less than 50, the year shall be interpreted as 20YY.  The above usage is as is specified in [RFC2459].  For transmission in the signed content AuthenticatedAttribute type (gmt_utc_time) the trailing ‘Z’ is omitted as it is implicit.      (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 26(27) Appendix D  Static Conformance Requirement This static conformance requirement [WAPCREQ] lists a minimum set of functions that can be implemented to help ensure that WMLScript Crypto Library implementations will be able to inter-operate.  The “Status\" column indicates if the function is mandatory (M) or optional (O).  D.1 Client Options  Item Function Subfunction Reference Status Requirement WMLSCrypt-C-001 Function supported with at least one signature algorithm 5.1 M WMLSCrypt-C-002 OR WMLSCrypt-C-003 WMLSCrypt-C-002 RSA 6 O  WMLSCrypt-C-003 SignText ECDSA  6 O  WMLSCrypt-C-004 Use of WIM  5.1.4 O WIM:MCF AND  WIM-C-002 AND  WIM-C-042  D.2 Script Encoder Options  Item Function Subfunction Reference Status Requirement WMLSCrypt-S-001 SignText  5.1 M   D.3 Application options  Item Function Subfunction Reference Status Requirement WMLSCrypt-A-001 Signature verification supported with at least one signature algorithm 5.1 M WMLSCrypt-A-002 OR WMLSCrypt-A-003 WMLSCrypt-A-002 RSA 6 O  WMLSCrypt-A-003 SignText output (SignedContent) verification ECDSA 6 O     (c) 2001 Wireless Application Protocol Forum, Ltd All rights reserved. Page 27(27)"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-191-WML-20000219-a.pdf","file":"WAP-191-WML-20000219-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-widespecification for developing applications that operate over wireless communication networks.  Thescope for the WAP Forum is to define a set of specifications to be used by service applications.The wireless market is growing very quickly and reaching new customers and services.  To enableoperators and manufacturers to meet the challenges in advanced services, differentiation, andfast/flexible service creation, WAP defines a set of protocols in transport, session, and applicationlayers.  For additional information on the WAP architecture, refer to \"Wireless ApplicationProtocol Architecture Specification\" [WAP].This specification defines the Wireless Markup Language (WML).  WML is a markup languagebased on [XML] and is intended for use in specifying content and user interface for narrowbanddevices, including cellular phones and pagers.WML is designed with the constraints of small narrowband devices in mind.  These constraintsinclude:• Small display and limited user input facilities• Narrowband network connection• Limited memory and computational resourcesWML includes four major functional areas:• Text presentation and layout - WML includes text and image support, including a variety offormatting and layout commands.  For example, boldfaced text may be specified.• Deck/card organisational metaphor - all information in WML is organised into a collection ofcards and decks.  Cards specify one or more units of user interaction (e.g., a choice menu, ascreen of text or a text entry field).   Logically, a user navigates through a series of WML cards,reviews the contents of each, enters requested information, makes choices and moves on toanother card.Cards are grouped together into decks.  A WML deck is similar to an HTML page, in that it isidentified by a URL [RFC2396] and is the unit of content transmission.• Inter-card navigation and linking - WML includes support for explicitly managing thenavigation between cards and decks.  WML also includes provisions for event handling in thedevice, which may be used for navigational purposes or to execute scripts.  WML also supportsanchored links, similar to those found in [HTML4].• String parameterisation and state management - all WML decks can be parameterised using astate model.  Variables can be used in the place of strings and are substituted at run-time.  Thisparameterisation allows for efficient use of network resources.WAP-191-WML, 19 February 2000Page 8 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved2.  Document  StatusThis document is available online in the following formats:• PDF format at http://www.wapforum.org.2.1  Copyright  Notice© Copyright Wireless Application Forum Ltd, 1998, 1999, 2000.Terms and conditions of use are available from the Wireless Application Protocol Forum Ltd. website at http://www.wapforum.org/docs/copyright.htm.2.2  ErrataKnown problems associated with this document are published at http://www.wapforum.org.2.3  CommentsComments regarding this document can be submitted to the WAP Forum in the manner publishedat http://www.wapforum.org.2.4  Document  HistoryDocument:Wireless Markup Language (WML)Current:WAP-191Revision History:Approval DateDocument Identifier30 Apr 1998WAP-106 (WML 1.0)16 Jun 1999WAP-136 (WML 1.1)4 Nov 1999WAP-155 (WML 1.2)7 July 2000WAP-191 (WML 1.3)WAP-191-WML, 19 February 2000Page 9 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved3.  References3.1  Normative  References[CACHE]\"WAP Caching Model Specification\", WAP Forum, 11-Febuary-1999.URL: http://www.wapforum.org/[ISO10646]\"Information Technology - Universal Multiple-Octet Coded Character Set (UCS)- Part 1: Architecture and Basic Multilingual Plane\", ISO/IEC 10646-1:1993.[RFC1766]\"Tags for the Identification of Languages\", H. Alvestrand, March 1995.URL: http://www.ietf.org/rfc/rfc1766.txt[RFC2045]\"Multipurpose Internet Mail Extensions (MIME) Part One: Format of InternetMessage Bodies\", N. Freed, et al., November 1996.URL: http://www.ietf.org/rfc/rfc2045.txt[RFC2047]\"MIME (Multipurpose Internet Mail Extensions) Part Three: Message HeaderExtensions for Non-ASCII Text\", K. Moore, November 1996.URL: http://www.ietf.org/rfc/rfc2047.txt[RFC2048]\"Multipurpose Internet Mail Extensions (MIME) Part Four: RegistrationProcedures\", N. Freed, et al., November 1996.URL: http://www.ietf.org/rfc/rfc2048.txt[RFC2068]\"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, et al., January 1997.URL: http://www.ietf.org/rfc/rfc2068.txt[RFC2119]\"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March1997.URL: http://www.ietf.org/rfc/rfc2119.txt[RFC2388]\"Returning Values from Forms: multipart/form-data\" L. Masinter.August 1998.URL: http://www.ietf.org/rfc/rfc2388.txt[RFC2396]\"Uniform Resource Identifiers (URI): Generic Syntax\", T. Berners-Lee, et al.,August 1998.URL: http://www.ietf.org/rfc/rfc2396.txt[UNICODE]   \"The Unicode Standard: Version 2.0\", The Unicode Consortium, Addison-WesleyDevelopers Press, 1996.URL: http://www.unicode.org/[WAE]\"Wireless Application Environment Specification\", WAP Forum, 4-November-1999.URL: http://www.wapforum.org/WAP-191-WML, 19 February 2000Page 10 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved[WAP]\"Wireless Application Protocol Architecture Specification\", WAP Forum, 30-April-1998.URL: http://www.wapforum.org/[WBXML]\"Binary XML Content Format Specification\", WAP Forum, 4-November-1999.URL: http://www.wapforum.org/[WSP]\"Wireless Session Protocol\", WAP Forum, 5-November-1999.URL: http://www.wapforum.org/[XML]\"Extensible Markup Language (XML), W3C Proposed Recommendation 10-February-1998, REC-xml-19980210\", T. Bray, et al, February 10, 1998.URL: http://www.w3.org/TR/REC-xml3.2  Informative  References[HDML2]\"Handheld Device Markup Language Specification\", P. King, et al., April 11,1997.URL: http://www.uplanet.com/pub/hdml_w3c/hdml20-1.html[HTML4]\"HTML 4.0 Specification, W3C Recommendation 18-December-1997, REC-HTML40-971218\", D. Raggett, et al., September 17, 1997.  URL:http://www.w3.org/TR/REC-html40[ISO8879]\"Information Processing - Text and Office Systems - Standard GeneralisedMarkup Language (SGML)\", ISO 8879:1986.WAP-191-WML, 19 February 2000Page 11 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved4.  Definitions  and  Abbreviations4.1  DefinitionsThe following are terms and conventions used throughout this specification.The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\" and \"OPTIONAL\" in this document are to beinterpreted as described in [RFC2119].  In the absence of any such terms, the specification is to beinterpreted as “MUST”.Author - an author is a person or program that writes or generates WML, WMLScript or othercontent.Card - a single WML unit of navigation and user interface.  May contain information to present tothe user, instructions for gathering user input, etc.Character Encoding – when used as a verb, character encoding refers to conversion betweensequence of characters and a sequence of bytes.  When used as a noun, character encoding refers toa method for converting a sequence of bytes to a sequence of characters.  Typically, WMLdocument character encoding is captured in transport headers attributes (e.g., Content-Type’s“charset” parameter) or the XML declaration defined by [XML].Client - a device (or application) that initiates a request for connection with a server.Content - subject matter (data) stored or generated at an origin server.  Content is typicallydisplayed or interpreted by a user agent in response to a user request.Content Encoding - when used as a verb, content encoding indicates the act of converting contentfrom one format to another.  Typically the resulting format requires less physical space than theoriginal, is easier to process or store, and/or is encrypted.  When used as a noun, content encodingspecifies a particular format or encoding standard or process.Content Format - actual representation of content.Deck - a collection of WML cards.  A WML deck is also an XML document.Device - a network entity that is capable of sending and receiving packets of information and has aunique device address.  A device can act as both a client and a server within a given context oracross multiple contexts.  For example, a device can service a number of clients (as a server) whilebeing a client to another server.JavaScript - a de facto standard language that can be used to add dynamic behaviour to HTMLdocuments.  JavaScript is one of the originating technologies of ECMAScript.Man-Machine Interface - a synonym for user interface.WAP-191-WML, 19 February 2000Page 12 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedOrigin Server - the server on which a given resource resides or is to be created.  Often referred toas a web server or an HTTP server.Resource - a network data object or service that can be identified by a URL.  Resources may beavailable in multiple representations (e.g., multiple languages, data formats, size and resolutions) orvary in other ways.Server - a device (or application) that passively waits for connection requests from one or moreclients.  A server may accept or reject a connection request from a client.SGML - the Standardised Generalised Markup Language (defined in [ISO8879]) is a general-purpose language for domain-specific markup languages.Terminal - a device providing the user with user agent capabilities, including the ability to requestand receive information.  Also called a mobile terminal or mobile station.Transcode - the act of converting from one character set to another, e.g., conversion from UCS-2to UTF-8.User - a user is a person who interacts with a user agent to view, hear or otherwise use a resource.User Agent - a user agent is any software or device that interprets WML, WMLScript, WTAI orother resources.  This may include textual browsers, voice browsers, search engines, etc.WMLScript - a scripting language used to program the mobile device. WMLScript is an extendedsubset of the JavaScript scripting language.XML - the Extensible Markup Language is a World Wide Web Consortium (W3C) standard forInternet markup languages, of which WML is one such language.  XML is a restricted subset ofSGML.4.2  AbbreviationsFor the purposes of this specification, the following abbreviations apply.BNFBackus-Naur FormHDMLHandheld Markup Language [HDML2]HTMLHyperText Markup Language [HTML4]HTTPHyperText Transfer Protocol [RFC2068]IANAInternet Assigned Number AuthorityMMIMan-Machine InterfacePDAPersonal Digital AssistantWAP-191-WML, 19 February 2000Page 13 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedRFCRequest For CommentsSGMLStandardised Generalised Markup Language [ISO8879]UIUser InterfaceURLUniform Resource Locator [RFC2396]URNUniform Resource NameW3CWorld Wide Web ConsortiumWAEWireless Application Environment [WAE]WAPWireless Application Protocol [WAP]WSPWireless Session Protocol [WSP]XMLExtensible Markup Language [XML]4.3  Device  TypesWML is designed to meet the constraints of a wide range of small, narrowband devices.  Thesedevices are primarily characterised in four ways:• Display size - smaller screen size and resolution.  A small mobile device such as a phone mayonly have a few lines of textual display, each line containing 8-12 characters.• Input devices - a limited, or special-purpose input device.  A phone typically has a numerickeypad and a few additional function-specific keys.  A more sophisticated device may havesoftware-programmable buttons, but may not have a mouse or other pointing device.• Computational resources - low power CPU and small memory size; often limited by powerconstraints.• Narrowband network connectivity - low bandwidth and high latency.  Devices with 300bps to10kbps network connections and 5-10 second round-trip latency are not uncommon.This document uses the following terms to define broad classes of device functionality:• Phone - the typical display size ranges from two to ten lines.  Input is usually accomplishedwith a combination of a numeric keypad and a few additional function keys.  Computationalresources and network throughput is typically limited, especially when compared with moregeneral-purpose computer equipment.WAP-191-WML, 19 February 2000Page 14 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved• PDA - a Personal Digital Assistant is a device with a broader range of capabilities.  When usedin this document, it specifically refers to devices with additional display and inputcharacteristics.  A PDA display often supports resolution in the range of 160x100 pixels.  APDA may support a pointing device, handwriting recognition and a variety of other advancedfeatures.These terms are meant to define very broad descriptive guidelines and to clarify certain examples inthe document.WAP-191-WML, 19 February 2000Page 15 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved5.  WML and URLsThe World Wide Web is a network of information and devices.  Three areas of specification ensurewidespread interoperability:• A unified naming model.  Naming is implemented with Uniform Resource Locators (URLs),which provide standard way to name any network resource.  See [RFC2396].• Standard protocols to transport information (e.g., HTTP).• Standard content types (e.g., HTML, WML).WML assumes the same reference architecture as HTML and the World Wide Web.  Content isnamed using URLs and is fetched over standard protocols that have HTTP semantics, such as[WSP].  URLs are defined in [RFC2396].  The character set used to specify URLs is also defined in[RFC2396].In WML, URLs are used in the following situations:• When specifying navigation, e.g., hyperlinking.• When specifying external resources, e.g., an image or a script.5.1  URL  SchemesWML browsers must implement the URL schemes specified in [WAE].5.2  Fragment  AnchorsWML has adopted the HTML de facto standard of naming locations within a resource.  A WMLfragment anchor is specified by the document URL, followed by a hash mark (#), followed by afragment identifier.  WML uses fragment anchors to identify individual WML cards within a WMLdeck.  If no fragment is specified, a URL names an entire deck.  In some contexts, the deck URLalso implicitly identifies the first card in a deck.5.3  Relative  URLsWML has adopted the use of relative URLs, as specified in [RFC2396]. [RFC2396] specifies themethod used to resolve relative URLs in the context of a WML deck.  The base URL of a WMLdeck is the URL that identifies the deck.WAP-191-WML, 19 February 2000Page 16 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved6.  WML Character SetWML is an XML language and inherits the XML document character set.  In SGML nomenclature,a document character set is the set of all logical characters that a document type may contain (e.g.,the letter 'T' and a fixed integer identifying that letter).  An SGML or XML document is simply asequence of these integer tokens, which taken together form a document.The document character set for XML and WML is the Universal Character Set of ISO/IEC-10646([ISO10646]).  Currently, this character set is identical to Unicode 2.0 [UNICODE]. WML willadopt future changes and enhancements to the [XML] and [ISO10646] specifications.  Within thisdocument, the terms ISO10646 and Unicode are used interchangeably and indicate the samedocument character set.There is no requirement that WML decks be encoded using the full Unicode encoding (e.g., UCS-4).  Any character encoding (\"charset\") that contains a proper subset of the logical characters inUnicode may be used (e.g., US-ASCII, ISO-8859-1, UTF-8, Shift_JIS, etc.).  Documents notencoded using UTF-8 or UTF-16 must declare their encoding as specified in the XMLspecification.Conformance Rules:WML-01    UTF-8 EncodingOWML-02    UTF-16 EncodingOWML-03    UCS-4 EncodingOWML-04    Other character encodingO6.1  Reference Processing ModelWML documents maybe encoded with any character encoding as defined by [HTML4].Character encoding of a WML document may be converted to another encoding (or transcoded) tobetter meet the user agent’s characteristics.  However, transcoding can lead to loss of informationand must be avoided when the user agent supports the document’s original encoding.  Unnecessarytranscoding must be avoided when information loss will result.  If required, transcoding should bedone before the document is delivered to the user agent.This specification does not mandate which character encoding a user agent must support.Since WML is an XML application, the character encoding of a WML document is determined asdefined in the XML specification [XML]. In normal cases it is always possible to detect thecharacter encoding of the document (all other cases are error situations). The meta http-equivstatement, if any is present in the document, is never used to determine the character encoding.WAP-191-WML, 19 February 2000Page 17 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedIf a WML document is transformed into a different format than XML - for example, into the binaryWBXML format - then, the rules relevant for that format are used to determine the characterencoding.When an WML document is accompanied by external information (e.g. HTTP or MIME) there maybe multiple sources of information available to determine the character encoding. In this case, theirrelative priority and the preferred method of handling conflict should be specified as part of thehigher-level protocol. See, for example, the documentation of the \"text/vnd.wap.wml\" and\"application/vnd.wap.wmlc\" MIME media types.The WML reference-processing model is as follows.  User agents must implement this processingmodel, or a model that is indistinguishable from it.• User agents must correctly map to Unicode all characters in any character encoding that theyrecognise, or they must behave as if they did.• Any processing of entities is done in the document character set.A given implementation may choose any internal representation (or representations) that isconvenient.Conformance Rules:WML-05    Reference processingM6.2  Character  EntitiesA given character encoding may not be able to express all characters of the document character set.For such encoding, or when the device characteristics do not allow users to input some documentcharacters directly, authors and users may use character entities (i.e., [XML] character references).Character entities are a character encoding-independent mechanism for entering any character fromthe document character set.WML supports both named and numeric character entities.  An important consequence of thereference processing model is that all numeric character entities are referenced with respect to thedocument character set (Unicode) and not to the current document encoding (charset).This means that &#302; always refers to the same logical character, independent of the currentcharacter encoding.WML supports the following character entity formats:• Named character entities, such as &amp; and &lt;• Decimal numeric character entities, such as &#32;• Hexadecimal numeric character entities, such as &#x20;WAP-191-WML, 19 February 2000Page 18 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedSeven named character entities are particularly important in the processing of WML:<!ENTITY quot  \"&#34;\">     <!-- quotation mark --><!ENTITY amp   \"&#38;#38;\"> <!-- ampersand --><!ENTITY apos  \"&#39;\">     <!-- apostrophe --><!ENTITY lt    \"&#38;#60;\"> <!-- less than --><!ENTITY gt    \"&#62;\">     <!-- greater than --><!ENTITY nbsp  \"&#160;\">    <!-- non-breaking space --><!ENTITY shy   \"&#173;\">    <!-- soft hyphen (discretionary hyphen) -->Conformance Rules:WML-06    Character entitiesMWAP-191-WML, 19 February 2000Page 19 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved7.  WML  SyntaxWML inherits most of its syntactic constructs from XML.  Refer to [XML] for in-depthinformation on syntactical issues.7.1  EntitiesWML text can contain numeric or named character entities.  These entities specify specificcharacters in the document character set.  Entities are used to specify characters in the documentcharacter set either which must be escaped in WML or which may be difficult to enter in a texteditor.  For example, the ampersand (&) is represented by the named entity &amp;.  All entitiesbegin with an ampersand and end with a semicolon.WML is an XML language. This implies that the ampersand and less-than characters must beescaped when they are used in textual data,  That is, these characters may appear in their literalform only when used as markup delimiters, within a comment, etc.  See [XML] for more details.7.2  ElementsElements specify all markup and structural information about a WML deck.  Elements may containa start tag, content and an end tag.  Elements have one of two structures:<tag> content </tag>or<tag/>Elements containing content are identified by a start tag (<tag>) and an end tag (</tag>).  Anempty-element tag (<tag/>) identifies elements with no content.7.3  AttributesWML attributes specify additional information about an element. More specifically, attributesspecify information about an element that is not part of the element's content.  Attributes are alwaysspecified in the start tag of an element. For example,<tag attr=\"abcd\"/>Attribute names are an XML NAME and are case sensitive.XML requires that all attribute values be quoted using either double quotation marks (\") or singlequotation marks ('). Single quote marks can be included within the attribute value when the value isdelimited by double quote marks and vice versa. Character entities may be included in an attributevalue.WAP-191-WML, 19 February 2000Page 20 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved7.4  CommentsWML comments follow the XML commenting style and have the following syntax:<!-- a comment -->Comments are intended for use by the WML author and should not be displayed by the user agent.WML comments cannot be nested.7.5  VariablesWML cards and decks can be parameterised using variables.  To substitute a variable into a card ordeck, the following syntax is used:$identifier$(identifier)$(identifier:conversion)Parentheses are required if white space does not indicate the end of a variable.  Variable syntax hasthe highest priority in WML, i.e., anywhere the variable syntax is legal, an unescaped '$' characterindicates a variable substitution.  Variable references are legal in any PCDATA and in any attributevalue identified by the vdata entity type (see section 8.3).  Variable references are illegal inattribute values of type CDATA (see section 10.3.5). Since XML does not allow for dollar signcharacters in other attribute types (for example, ID and NMTOKEN), variable references are alsoillegal in those attributesA sequence of two dollar signs ($$) represents a single dollar sign character in all CDATA attributevalues and in all #PCDATA text.See section 10.3 for more information on variable syntax and semantics.Conformance Rules:WML-64    Variable references may only occur in vdata attribute valuesM7.6  Case  SensitivityXML is a case-sensitive language; WML inherits this characteristic.  No case folding is performedwhen parsing a WML deck.  This implies that all WML tags and attributes are case sensitive.  Inaddition, any enumerated attribute values are case sensitive.WAP-191-WML, 19 February 2000Page 21 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved7.7  CDATA  SectionCDATA sections are used to escape blocks of text and are legal in any PCDATA, e.g., inside anelement.  CDATA sections begin with the string \"<![CDATA[\" and end with the string \"]]>\".  Forexample:<![CDATA[ this is <B> a test ]]>Any text inside a CDATA section is treated as literal text and will not be parsed for markup.  CDATAsections are useful anywhere literal text is convenient.Refer to the [XML] specification for more information on CDATA sections.7.8  Processing  InstructionsWML makes no use of XML processing instructions beyond those explicitly defined in the XMLspecification.7.9  ErrorsThe [XML] specification defines the concept of a well-formed XML document. WML decks thatviolate the definition of a well-formed document are in error.  See section 14.2.3 for relatedinformation.WAP-191-WML, 19 February 2000Page 22 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved8.  Core WML Data Types8.1  Character  DataAll character data in WML is defined in terms of XML data types.  In summary:• CDATA - text which may contain numeric or named character entities.  CDATA is used only inattribute values.• PCDATA - text which may contain numeric or named character entities.  This text may containtags (PCDATA is \"Parsed CDATA\").  PCDATA is used only in elements.• NMTOKEN - a name token, containing any mixture of name characters, as defined by the XMLspecification.See [XML] for more details.8.2  Length<!ENTITY % length  \"CDATA\">    <!-- [0-9]+ for pixels or [0-9]+\"%\" forpercentage length -->The length type may either be specified as an integer representing the number of pixels of thecanvas (screen, paper) or as a percentage of the available horizontal or vertical space. Thus, thevalue \"50\" means fifty pixels. For widths, the value \"50%\" means half of the available horizontalspace (between margins, within a canvas, etc.). For heights, the value \"50%\" means half of theavailable vertical space (in the current window, the current canvas, etc.).The integer value consists of one or more decimal digits ([0-9]) followed by an optional percentcharacter (%).  The lengthtype is only used in attribute values.8.3  Vdata<!ENTITY % vdata   \"CDATA\">    <!-- attribute value possibly containingvariable references -->The vdata type represents a string that may contain variable references (see section 10.3).  Thistype is only used in attribute values.8.4  Flow<!ENTITY % layout  \"br\"><!ENTITY % flow     \"%text; | %layout; | img | anchor|a|table\">The flow type represents \"card-level\" information. In general, flow is used anywhere generalmarkup can be included.WAP-191-WML, 19 February 2000Page 23 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved8.5  HREF<!ENTITY % HREF    \"%vdata;\">  <!-- URI, URL or URN designating a hypertextnode. May contain variable references -->The HREF type refers to either a relative or an absolute Uniform Resource Locator [RFC2396].See section 5 for more information.8.6  Boolean<!ENTITY % boolean \"(true|false)\">The boolean type refers to a logical value of true or false.8.7  Number<!ENTITY % number  \"NMTOKEN\">  <!-- a number, with format [0-9]+ -->The number type represents an integer value greater than or equal to zero.8.8  xml:langThe xml:lang attribute specifies the natural or formal language of an element or its attributes.The value of the attributes is a language code according to [RFC1766].  See [XML] for details onthe syntax and specification of the attribute values.  The attribute identifies to the user agent thelanguage used text that may be presented to the user (i.e., an element’s content and attributevalues).  The user agent should perform a best effort to present the data according to the specifics ofthe language.  Nested elements can assume the parent’s language or use another.  Where an elementhas both text content and text based attribute values that may be presented to the user, authors mustuse the same language for both.  Variable values that are placed in vdata should match thelanguage of the containing element.An element’s language must be established according to the following precedence (from highest tolowest):1. Based on the xml:lang attribute specified for the element.2. Based on the xml:lang attribute specified by the closest parent element.3. Based on any language information included in the transport and document meta data (seesections 6.1 and 11.3.2 for more detail).4. Based on user agent default preferences.8.9  The id and class AttributesAll WML elements have two core attributes: id and class that can be used for such tasks asserver-side transformations.  The id attribute provides an element a unique name within a singleWAP-191-WML, 19 February 2000Page 24 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserveddeck.  The attribute class affiliates an element with one or more classes.  Multiple elements canbe given the same class name.  All elements of a single deck with a common class name areconsidered part of the same class.  Class names are cases sensitive.  An element can be part ofmultiple classes if it has multiple unique class names listed in its class attribute.  Multiple classnames within a single attribute must be separated by white space.  Redundant class names as wellas insignificant white space between class names may be removed.  The WML user agent shouldignore these attributes.8.10  ContentType<!ENTITY % ContentType \"%vdata;\">  <!-- media type. May contain variablereferences -->The ContentType type represents the media type defined in [RFC2045].  See section 9.5.1 for moreinformation.WAP-191-WML, 19 February 2000Page 25 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved9.  Events and Navigation9.1  Navigation and Event HandlingWML includes navigation and event-handling models.  The associated elements allow the author tospecify the processing of user agent events.  Events may be bound to tasks by the author; when anevent occurs, the bound task is executed.  A variety of tasks may be specified, such as navigation toan author-specified URL.  Event bindings are declared by several elements, including do andonevent.9.2  HistoryWML includes a simple navigational history model that allows the author to manage backwardnavigation in a convenient and efficient manner.  The user agent history is modelled as a stack ofURLs that represent the navigational path the user traversed to arrive at the current card. Threeoperations may be performed on the history stack:• Reset - the history stack may be reset to a state where it only contains the current card.  See thenewcontext attribute (section 10.2) for more information.• Push - a new URL is pushed onto the history stack as an effect of navigation to a new card.• Pop - the current card's URL (top of the stack) is popped as a result of backward navigation.The user agent must implement a navigation history.  As each card is accessed via an explicitlyspecified URL, (e.g., via the href attribute in go element,) an entry for the card is added to thehistory stack even if it is identical to the most recent entry.  At a minimum, each entry must recordthe absolute URL of the card, the method (get or post) used to access the card, the value of anypostfields, and any request headers. The card content is not stored in the history. Variablereferences are never stored in the history. Any variable references in the history data must bereplaced with the current value of the variables before the entry is added to the stack.The user agent must return the user to the previous card in the history if a prev task is executed(see section 9.5.2).  The execution of prev pops the current card URL from the history stack whena prev task is executed.If the card is part of deck that was originally fetched using an HTTP post method, and the useragent must re-fetch the deck to establish the card, then the user agent must reissue any post dataassociated with fetching the original deck. The post data values must be the same values used tofetch the original deck.  Refer to section 12.5.2 for more information on the semantics of prev.See [CACHE] for more information on caching semantics.WAP-191-WML, 19 February 2000Page 26 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedConformance Rules:WML-07    HistoryM9.3  The Postfield Element<!ELEMENT postfield EMPTY><!ATTLIST postfieldname         %vdata;           #REQUIREDvalue        %vdata;           #REQUIRED%coreattrs;>The postfield element specifies a field name and value for transmission to an origin serverduring a URL request.  The actual encoding of the name and value will depend on the method usedto communicate with the origin server.Refer to section 9.5.1 for more information on the use of postfield in a go element.Attributesname=vdataThe name attribute specifies the field name.value=vdataThe value attribute specifies the field value.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-37    postfieldM9.4  The Setvar Element<!ELEMENT setvar EMPTY><!ATTLIST setvarname         %vdata;           #REQUIREDvalue        %vdata;           #REQUIRED%coreattrs;>The setvar element specifies the variable to set in the current browser context as a side effect ofexecuting a task.  The element must be ignored if the name attribute doe not evaluate to a legalvariable name at runtime (see section 7.5).  See section 10.3.4 for more information on settingvariables.WAP-191-WML, 19 February 2000Page 27 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributesname=vdataThe name attribute specifies the variable name.value=vdataThe value attribute specifies the value to be assigned to the variable.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-52    setvarM9.5  Tasks<!ENTITY % task   \"go | prev | noop | refresh\">Tasks specify processing that is performed in response to an event such as timer expiring, enteringa card, or activating an anchor element.9.5.1  The  Go  Element<!ENTITY % cache-control “(no-cache)” ><ELEMENT go (postfield | setvar)*><!ATTLIST gohref            %HREF;          #REQUIREDsendreferer     %boolean;       \"false\"method          (post|get)      \"get\"enctype         %ContentType;\"application/x-www-form-urlencoded\"cache-control   %cache-control; #IMPLIEDaccept-charset  CDATA           #IMPLIED%coreattrs;>The go element declares a go task, indicating navigation to a URI.  If the URI names a WML cardor deck, it is displayed.  A go executes a \"push\" operation on the history stack (see section 9.2).The UA must ignore all postfield elements of a go element if the target of the go element is acard contained within the current deck and if the cache-control is not specified as “no-cache”.Refer to section 12.5.1 for more information on the semantics of go.Attributeshref=HREFThe href attribute specifies the destination URI, e.g., the URI of the card to display.WAP-191-WML, 19 February 2000Page 28 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedsendreferer=booleanIf this attribute is true, the user agent must specify, for the server's benefit, the URI of thedeck containing this task (i.e., the referring deck).  This allows a server to perform a form ofaccess control on URIs, based on which decks are linking to them. The URI must be thesmallest relative URI possible if it can be relative at all. For example, ifsendreferer=true, an HTTP based user agent shall indicate the URI of the currentdeck in the HTTP \"Referer\" request header [RFC2068].method=(post|get)This attribute specifies the HTTP submission method.  Currently, the values of get andpost are accepted and cause the user agent to perform an HTTP GET or POSTrespectively.cache-control=no-cacheIf the “cache-control” attribute is present, and the value is set to “no-cache”, the clientMUST reload the URL from the origin server.  This attribute represents the HTTP “cache-control” header, when this attribute is present, the HTTP “cache-control” header MUST beadded to the request with the same value as specified in the attribute.enctype=ContentTypeThis attribute specifies the content type used to submit the parameter to the server (when thevalue of method is post). The default value for this attribute is application/x-www-form-urlencoded. Currently, only application/x-www-form-urlencoded ormultipart/form-data can be specified.When the field values in a submitted form may contain characters not in the US-ASCIIcharacter set, it is recommended that the post method and multipart/form-data[RFC2388] are used.User agents must explicitly specify content type for each part. If a part corresponds to apostfield element, its content type should be text/plain.  The charset parameter isrequired when the content contains characters not in the US-ASCII character set.accept-charset=cdataThis attribute specifies the list of character encodings for data that the origin server acceptswhen processing input. When the go task is executed and method=\"post\" has beenspecified, the user agent should encode the field names and values of all associatedpostfield elements using any one of the specified character sets.The value of this attribute is a comma- or space-separated list of character encoding names(charset) as specified in [RFC2045] and [RFC2068].  The IANA Character Set registrydefines the public registry for charset values.If the accept-charset attribute is not specified or is the reserved string unknown, useragents should use the character encoding that was used to transmit the WML deck thatcontains the go element.WAP-191-WML, 19 February 2000Page 29 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributes defined elsewhere• id(see section 8.9)• class(see section 8.9)The go element may contain one or more postfield elements.  These elements specifyinformation to be submitted to the origin server during the request.  The submission of field data isperformed in the following manner:1. The field name/value pairs are identified and all variables are substituted.2. The user agent should transcode the field names and values to the correct character set, asspecified explicitly by the accept-charset or implicitly by the document encoding.3. If the href attribute value is an HTTP URI, the request is performed according to the methodand enctype attribute's value:MethodEnctypeProcessapplication/x-www-form-urlencodedThe field names and values are escaped using URI-escapingand assembled into an application/x-www-form-urlencoded content type.The submission data is appended to the query component ofthe URI. The result must be a valid query component withthe original query part and the postfields combined. AnHTTP GET operation is performed on the resulting URL.getmultipart/form-dataError.WAP-191-WML, 19 February 2000Page 30 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedMethodEnctypeProcessapplication/x-www-form-urlencodedThe field names and values are escaped using URI-escapingand assembled into an application/x-www-form-urlencoded content type.The submission data is sent as the body of the HTTP POSTrequest.The Content-Type header must include the charsetparameter to indicate the character encoding.postmultipart/form-dataThe field names and values are encoded as amultipart/form-data content type as defined in[RFC2388].The Content-Type header must include the charsetparameter to indicate the character encoding when the partcontains characters not in the US-ASCII character set.The submission data is sent as the body of the HTTP POSTrequest.When enctype attribute's value is application/x-www-form-urlencoded, the fieldnames and values must be encoded as follows:1. The field names and values are escaped using URI-escaping, and listed in the order in which thepostfields are presented.2. The name is separated from the value by  `=' and name/value pairs are separated from eachother by `&'. See [RFC2396] for more information on the URI syntax and its escape sequence.It is recommended that user agents submit data with anapplication/vnd.wap.multipart.form-data content type when enctype attributehas a value of multipart/form-data.  Some user agents may only support data submission asapplication/x-www-form-urlencoded content type. Such user agents may ignoreenctype attribute. Thus, it is recommended that an origin server expect either form of submission(i.e., multipart/form-data or application/x-www-form-urlencoded) when theenctype value is multipart/form-data. However, the origin server may assume that it willonly receive an application/x-www-form-urlencoded submission when the enctypevalue is application/x-www-form-urlencoded.WAP-191-WML, 19 February 2000Page 31 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedFor example, the following go element would cause an HTTP GET request to the URL\"/foo?x=1\":<go href=\"/foo\"><postfield name=\"x\" value=\"1\"/></go>The following example will cause an HTTP POST to the URL \"/bar\" with a message entitycontaining \"w=12&y=test\":<go href=\"/bar\" method=\"post\"><postfield name=\"w\" value=\"12\"/><postfield name=\"y\" value=\"test\"/></go>Conformance Rules:WML-29    goM9.5.2  The Prev Element<!ELEMENT prev (setvar)*><!ATTLIST prev%coreattrs;>The prev element declares a prev task, indicating navigation to the previous URI on the historystack.  A prev performs a \"pop\" operation on the history stack (see section 9.2).Refer to section 12.5.2 for more information on the semantics of prev.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-38    prevM9.5.3  The Refresh Element<!ELEMENT refresh (setvar)*><!ATTLIST refresh%coreattrs;>The refresh element declares a refresh task, indicating an update of the user agent context asspecified by the setvar elements. User-visible side effects of the state changes (e.g., a change inthe screen display) occur during the processing of the refresh task. A refresh and its side effectsmust occur even if the elements have no setvar elements given that context may change by othermeans (e.g., timer).WAP-191-WML, 19 February 2000Page 32 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedRefer to section 12.5.4 for more information on the semantics of refresh.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-42    refreshM9.5.4  The Noop Element<!ELEMENT noop EMPTY><!ATTLIST noop%coreattrs;>This noop element specifies that nothing should be done, i.e., \"no operation\".Refer to section 12.5.3 for more information on the semantics of noop.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)ConformanceRules:WML-35    noopM9.6  Card/Deck Task ShadowingA variety of elements can be used to create an event binding for a card.  These bindings may alsobe declared at the deck level:• Card-level: the event-handling element may appear inside a card element and specify event-processing behaviour for that particular card.• Deck-level: the event-handling element may appear inside a template element and specifyevent-processing behaviour for all cards in the deck.  A deck-level event-handling element isequivalent to specifying the event-handling element in each card.A card-level event-handling element overrides (or \"shadows\") a deck-level event-handling elementif they both specify the same event.  A card-level onevent element will shadow a deck-levelonevent element if they both have the same type.  A card-level do element will shadow a deck-level do element if they have the same name.WAP-191-WML, 19 February 2000Page 33 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedFor a given card, the active event-handling elements are defined as the event-handling elementsspecified in the card that do not bind a noop task, plus any event-handling elements specified inthe deck's template not overridden (or shadowed) in the card or bind a noop task. Shadowed event-handling elements, event-handling elements defined in other cards, and event-handling elementsthat bind a noop task are considered inactive elements.If a card-level element shadows a deck-level element and the card-level element binds a noop task,the event binding for that event will be completely masked.  In this situation, the card- and deck-level elements will be ignored and no side effects will occur on delivery of the event. In otherwords, both the card-level and the deck-level elements are considered inactive elements in such acase.If a card-level element or deck-level element binds a noop task but does not shadow and is notshadowed by another element, then the binding for that event will also be masked and similarlyignored with no side effects.In the following example, a deck-level do element indicates that a prev task should execute onreceipt of a particular user action.  The first card inherits the do element specified in thetemplate element and will display the do to the user.  The second card shadows the deck-leveldo element with a noop.  The user agent will not display the do element when displaying thesecond card.  The third card shadows the deck-level do element, causing the user agent to displaythe alternative label and to perform the go task if the do is selected.<wml><template><do type=\"options\" name=\"do1\" label=\"default\"><prev/></do></template><card id=\"first\"><!-- deck-level do not shadowed.  The card exposes thedeck-level do as part of the current card --><!-- rest of card -->...</card>WAP-191-WML, 19 February 2000Page 34 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved<card id=\"second\"><!-- deck-level do is shadowed with noop.It is not exposed to the user --><do type=\"options\" name=\"do1\"><noop/></do><!-- rest of card --></card><card id=\"third\"><!-- deck-level do is shadowed. It is replaced bya card-level do --><do type=\"options\" name=\"do1\" label=\"options\"><go href=\"/options\"/></do><!-- rest of card --></card></wml>Conformance Rules:WML-08    Card/Deck task ShadowingM9.7  The Do Element<!ENTITY % task   \"go | prev | noop | refresh\"><!ELEMENT do (%task;)><!ATTLIST dotype         CDATA       #REQUIREDlabel        %vdata;     #IMPLIEDname         NMTOKEN     #IMPLIEDoptional     %boolean;   \"false\"xml:lang     NMTOKEN     #IMPLIED%coreattrs;>The do element provides a general mechanism for the user to act upon the current card, i.e., a card-level user interface element.  The representation of the do element is user agent dependent and theauthor must only assume that the element is mapped to a unique user interface widget that the usercan activate.  For example, the widget mapping may be to a graphically rendered button, a soft orfunction key, a voice-activated command sequence, or any other interface that has a simple\"activate\" operation with no inter-operation persistent state.  When the user activates a do element,the associated task is executed.WAP-191-WML, 19 February 2000Page 35 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe do element may appear at both the card and deck-level:• Card-level: the do element may appear inside a card element and may be located anywhere inthe text flow.  If the user agent intends to render the do element inline (i.e., in the text flow), itshould use the element's anchor point as the rendering point.  WML authors must not rely onthe inline rendering of the do element and must not rely on the correct positioning of an inlinerendering of the element.• Deck-level: the do element may appear inside a template element, indicating a deck-leveldo element.  A deck-level do element applies to all cards in the deck (i.e., is equivalent tohaving specified the do within each card).  For the purposes of inline rendering, the user agentmust behave as if deck-level do elements are located at the end of the card's text flow.Attributestype=cdataThe do element type.  This attribute provides a hint to the user agent about the author'sintended use of the element and should be used by the user agent to provide a suitablemapping onto a physical user interface construct.  WML authors must not rely on thesemantics or behaviour of an individual typevalue, or on the mapping of type to aparticular physical construct.  All types are reserved, except for those marked asexperimental, or vendor-specific.User agents must accept any type, but may treat any unrecognised type as the equivalentof unknown.In the following table, the * character represents any string, e.g., Test* indicates anystring starting with the word Test.  Although experimental and vendor-specific types maybe specified in any case, they are case-sensitive; e.g., the types VND-foo and vnd-fooare distinct.Table 1. Pre-defined DO typesTypeDescriptionacceptPositive acknowledgement (acceptance)prevBackward history navigationhelpRequest for help.  May be context-sensitive.resetClearing or resetting state.optionsContext-sensitive request for options or additional operations.deleteDelete item or choice.WAP-191-WML, 19 February 2000Page 36 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedTypeDescriptionunknownA generic do element.  Equivalent to an empty string (e.g.,type=\"\").X-*, x-*Experimental types.  This set is not reserved.vnd.*, VND.* andany combination of[Vv][Nn][Dd].*Vendor-specific or user-agent-specific types.  This set is notreserved.  Vendors should allocate names with the formatVND.CO-TYPE, where CO is a company name abbreviation andtype is the do element type.  See [RFC2045] for moreinformation.label=vdataIf the user agent is able to dynamically label the user interface widget, this attributespecifies a textual string suitable for such labelling.  The user agent must make a best-effortattempt to label the UI widget and should adapt the label to the constraints of the widget(e.g., truncate the string).  If an element can not be dynamically labelled, this attribute maybe ignored.To work well on a variety of user agents, labels should be six characters or shorter in length.name=nmtokenThis attribute specifies the name of the do event binding.  If two do elements are specifiedwith the same name, they refer to the same binding.  A card-level do element shadows adeck-level do with the same name value (see section 9.6 for more detail).  It is an error tospecify two or more do elements with the same name in a single card or in the templateelement.  An unspecified name defaults to the value of the type attribute.optional=booleanIf this attribute has a value of true, the user agent may ignore this element.All active do elements that have not been designated optional must be presented to the user.The UA must make such elements accessible to the user in some manner.  In other words, itmust be possible for the user to activate them (i.e., initiate the tasks associated with theelement), via some user interface element.All inactive do elements must not be presented to the user in a way that the user canactivate such elements. Elements that have been designated as optional may be ignored atthe discretion of the user agent. (For example, the author may wish to allow the user agentto ignore vendor-specific types that it doesn't recognise.)WAP-191-WML, 19 February 2000Page 37 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-26    doMWML-66    Two or more do elements with the same name must not bepresent in a single card or in the template element. (Note:An unspecified name defaults to the value of the typeattribute.)MWML-71    Two or more do element with the same name must not bepresent in a single card or in the template element. (Note:An unspecified name defaults to the value of the typeattribute.)O9.8  The Anchor Element<!ELEMENT anchor ( #PCDATA | br | img | go | prev | refresh )*><!ATTLIST anchortitle        %vdata;      #IMPLIEDaccesskey    %vdata;      #IMPLIEDxml:lang     NMTOKEN      #IMPLIED%coreattrs;>The anchor element defines a “hot spot” in the content, which is bound to the go, prev, orrefresh task that it contains. It is expected that the user agent presents the anchor element as alinking element; e.g., as “hypertext.”  When the user selects the element, the associated task isexecuted. Anchors may be present in any text flow, excluding the text in option elements (i.e., anywhereformatted text is legal, except for option elements).   It is an error to specify other than one taskelement (e.g., go, prev or refresh) in an anchor element.Attributestitle=vdataThis attribute specifies a brief text string identifying the link.  The user agent may display itin a variety of ways, including dynamic labelling of a button or key, a tool tip, a voiceprompt, etc.  The user agent may truncate or ignore this attribute depending on thecharacteristics of the navigational user interface.  To work well on a broad range of useragents, the author should limit all labels to 6 characters in length.WAP-191-WML, 19 February 2000Page 38 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedaccesskey=vdataThis attribute assigns an access key to an element. An access key is a single character fromthe document character set. Its purpose is to allow the user to activate a particular elementby using a single key. The keys available will vary depending on the type of mobile devicebeing used (e.g., phones will usually have \"0\"-\"9\", \"*\" and \"#\" keys).The user agent is not required to support accesskey. If the user agent does supportsaccess keys, it should respect the requested value if possible. When this is not possible (e.g.,the requested key does not already exist or has been defined more than once,) the user agentshould assign available keys to the remaining elements that request them, in the order theyare encountered in the card, until all available keys are assigned. Any remainingaccesskey attributes are ignored. The author can not assume that the key specified willbe the one used, nor that all elements that define an accesskey will have one assigned.The following elements support the accesskey attribute: A, INPUT, and ANCHOR.Activating an access key assigned to an element gives focus to the element. Theaction that occurs when an element receives focus depends on the element. Forexample, when a user activates a link defined by the A element, the user agentgenerally follows the link. When a user activates a radio button, the user agentchanges the value of the radio button. When the user activates a text field, itallows input, etc.In this example, we request an access key for a link defined by the A element.Activating this access key takes the user to another document, in this case, a tableof contents.<a accesskey=\"1\" href=\"http://someplace.com/specification/contents.html\">Table of Contents</a>The invocation of access keys may depend on both the user agent and the deviceon which it is running. For example, the access key may be recognised directly, orit may be necessary to press it in conjunction with a \"command\" key.. Therecognition of access keys may be inhibited by context. For example, a devicethat recognises access keys directly may inhibit their recognition when an inputelement is activeThe rendering of access keys depends on the user agent. User agents shouldrender the value of an access key in such a way as to emphasise its role and todistinguish it from other characters (e.g., by underlining it, enclosing it inbrackets, displaying it in reverse video or in a distinctive font, etc.) The authorshould not refer to the specific access key value in content or in documentation, asthe requested value may not be used.WAP-191-WML, 19 February 2000Page 39 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-20    anchorM9.9  The A Element<!ELEMENT a ( #PCDATA | br | img )*><!ATTLIST ahref         %HREF;       #REQUIREDtitle        %vdata;      #IMPLIEDaccesskey    %vdata;      #IMPLIEDxml:lang     NMTOKEN      #IMPLIED%coreattrs;>The a element is a short form of an anchor element bound to a go task without variableassignments.  For example, the following markup:<anchor>follow me<go href=\"destination\"/></anchor>Is identical in behaviour and semantics to:<a href=\"destination\">follow me</a>It is invalid to nest a elements.  Authors are encouraged to use the a element instead of anchorwhere possible, to allow more efficient tokenisation.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)• accesskey(see section 9.8)Conformance Rules:WML-19    aM9.10  Intrinsic  EventsSeveral WML elements are capable of generating events when the user interacts with them.  Theseso-called \"intrinsic events\" indicate state transitions inside the user agent.  Individual elementsspecify the events they can generate.  WML defines the following intrinsic events:WAP-191-WML, 19 February 2000Page 40 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedTable 2. WML Intrinsic EventsEventElement(s)Descriptionontimercard, templateThe ontimer event occurs when a timer expires.Timers are specified using the timer element (seesection 11.7).onenterforwardcard, templateThe onenterforward event occurs when theuser agent enters a card via a go task or any methodwith identical semantics.  This includes card entrycaused by a script function or user-agent-specificmechanisms, such as a means to directly enter andnavigate to a URL.The onenterforward intrinsic event may bespecified at both the card and deck-level. Eventbindings specified in the template element applyto all cards in the deck and may be overridden asspecified in section 9.6.onenterbackwardcard, templateThe onenterbackward event occurs when theuser agent enters a card via a prev task or anymethod with identical semantics.  In other words,the onenterbackward event occurs when theuser causes the user agent to navigate into a card byusing a URL retrieved from the history stack.  Thisincludes navigation caused by a script function oruser-agent-specific mechanisms.The onenterbackward intrinsic event may bespecified at both the card and deck-level.  Eventbindings specified in the template element applyto all cards in the deck and may be overridden asspecified in section 9.6.onpick         optionThe onpick event occurs when the user selects ordeselects this item.The author may specify that certain tasks are to be executed when an intrinsic event occurs.  Thisspecification may take one of two forms.  The first form specifies a URI to be navigated to whenthe event occurs.  This event binding is specified in a well-defined element-specific attribute and isthe equivalent of a gotask.  For example:<card onenterforward=\"/url\"> <p> Hello </p> </card>This attribute value may only specify a URL.WAP-191-WML, 19 February 2000Page 41 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe second form is an expanded version of the previous, allowing the author more control over useragent behaviour.  An onevent element is declared within a parent element, specifying the fullevent binding for a particular intrinsic event.  For example, the following is identical to theprevious example:<card><onevent type=\"onenterforward\"><go href=\"/url\"/></onevent><p>Hello</p></card>The user agent must treat the attribute syntax as an abbreviated form of the onevent elementwhere the attribute name is mapped to the onevent type.An intrinsic event binding is scoped to the element in which it is declared, e.g., an event bindingdeclared in a card is local to that card.  Any event binding declared in an element is active onlywithin that element.  If the event binding element specifies an intrinsic event type which does applyto its parent element, it must be ignored by the user agent.  Conflicting event bindings within anelement are an error.Conformance Rules:WML-09    Intrinsic EventsMWML-69    Event bindings must not conflictMWML-74    Event bindings must not conflictO9.10.1  The Onevent Element<!ENTITY % task   \"go | prev | noop | refresh\"><!ELEMENT onevent (%task;)><!ATTLIST oneventtype         CDATA       #REQUIRED%coreattrs;>The onevent element binds a task to a particular intrinsic event for the immediately enclosingelement, i.e., specifying an onevent element inside an \"XYZ\" element associates an intrinsicevent binding with the \"XYZ\" element.The user agent must ignore any onevent element specifying a type that does not correspond to alegal intrinsic event for the immediately enclosing element.WAP-191-WML, 19 February 2000Page 42 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributestype=cdataThe type attribute indicates the name of the intrinsic event.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-39    oneventM9.10.2  Card/Deck  Intrinsic  EventsEvent handlers for the onenterforward, onenterbackward, and ontimer intrinsic eventsmay be specified at both the card- and deck-level and have the shadowing semantics defined insection 9.6.  Handlers for these events are specified using the corresponding attribute of either thetemplate or card element, or by including an onevent element within the template orcard element. A card-level handler always overrides a deck-level handler of the same type,regardless of which syntax is used.For example, in the following deck the event handler in the card overrides the one specified in thetemplate although the two have been defined using different syntax:<wml><template><onevent type=\"onenterbackward\"><go href=\"aaa\"/></onevent></template><card onenterbackward=\"bbb\"><p>xyz</p></card></wml>WAP-191-WML, 19 February 2000Page 43 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved10.  The State ModelWML includes support for managing user agent state, including:• Variables - parameters used to change the characteristics and content of a WML card or deck;• History - navigational history, which may be used to facilitate efficient backward navigation;and• Implementation-dependent state - other state relating to the particulars of the user agentimplementation and behaviour.10.1  The Browser ContextWML state is stored in a single scope, known as a browser context.  The browser context is used tomanage all parameters and user agent state, including variables, the navigation history and otherimplementation-dependent information related to the current state of the user agent.Conformance Rules:WML-10    Browser contextM10.2  The Newcontext AttributeThe browser context may be initialised to a well-defined state by the newcontext attribute of thecard element (see section 11.5).  This attribute indicates that the browser context should be re-initialised and must perform the following operations:• Unset (remove) all variables defined in the current browser context,• Clear the navigational history state, and• Reset implementation-specific state to a well-known value.The newcontext is only performed as part of the go task.  See section 12.5 for more informationon the processing of state during navigation.Conformance Rules:WML-11    Initialisation (newcontext)MWAP-191-WML, 19 February 2000Page 44 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved10.3  VariablesAll WML content can be parameterised, allowing the author a great deal of flexibility in creatingcards and decks with improved caching behaviour and better perceived interactivity.  WMLvariables can be used in the place of strings and are substituted at run-time with their current value.A variable is said to be set if it has a value not equal to the empty string.  A value is not set if it hasa value equal to the empty string, or is otherwise unknown or undefined in the current browsercontext.Conformance Rules:WML-12    VariablesM10.3.1  Variable  SubstitutionThe values of variables can be substituted into both the text (#PCDATA) of a card and into %vdataand %HREF attribute values in WML elements. Only textual information can be substituted; nosubstitution of elements or attributes is possible.  The substitution of variable values happens atrun-time in the user agent.  Substitution does not affect the current value of the variable and isdefined as a string substitution operation.  If an undefined variable is referenced, it results in thesubstitution of the empty string.WML variable names consist of an US-ASCII letter or underscore followed by zero or more letters,digits or underscores.  Any other characters are illegal and result in an error.  Variable names arecase sensitive.The following description of the variable substitution syntax uses  the Extended Backus-Naur Form(EBNF) established in [XML].var     = ( \"$\" varname ) |( \"$(\" varname ( conv )? \")\" ) |( deprecated-var )conv    = \":\" ( \"escape\" | \"noesc\" | \"unesc\" )varname = ( \"_\" | alpha ) ( \"_\" | alpha | digit )*alpha   = lalpha | halphalalpha  = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" |\"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" |\"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"halpha  = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" |\"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" |\"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"digit   = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |\"8\" | \"9\"deprecated-var = \"$(\" varname deprecated-conv \")\"WAP-191-WML, 19 February 2000Page 45 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserveddeprecated-conv  = \":\"( escape | noesc | unesc )escape  = (\"E\" | \"e\")((\"S\"|\"s\")(\"C\"|\"c\")( \"A\" | \"a\" ) ( \"P\" | \"p\" )(\"E\"|\"e\"))?noesc   = ( \"N\" | \"n\")((\"O\"|\"o\")(\"E\" | \"e\")(\"S\"|\"s\")(\"C\"|\"c\"))?unesc   = ( \"U\" | \"u\")((\"N\"|\"n\")(\"E\" | \"e\")(\"S\"|\"s\")(\"C\"|\"c\"))?Mixed case and abbreviated conversions have been deprecated.  Authors should only use lowercase conversions.Parentheses are required anywhere the end of a variable cannot be inferred from the surroundingcontext, e.g., an illegal character such as white space.For example:This is a $varThis is another $(var).This is an escaped $(var:escape).This is an unescape $(var:unesc).Other legal variable forms: $_X $X32 $Test_9AThe value of variables can be converted into a different form as they are substituted. A conversioncan be specified in the variable reference following the colon. The following table summarised thecurrent conversions and their legal abbreviations:Table 3. Variable escaping methodsConversionEffectNoescNo change to the value of the variable.EscapeURL-escape the value of the variable.UnescURL-unescape the value of the variable.The use of a conversion during variable substitution does not affect the actual value of the variable.URL-escaping is detailed in [RFC2396].  All lexically sensitive characters defined in WML mustbe escaped, including all characters not in the unreserved set specified by [RFC2396].If no conversion is specified, the variable is substituted using the conversion format appropriate forthe context. All attributes defined as %HREF; default to escape conversion, elsewhere noconversion is done. Specifying the noesc conversion disables context sensitive escaping of avariable.WAP-191-WML, 19 February 2000Page 46 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedConformance Rules:WML-65    Variable references must match the production rule varMWML-70    Variable references must match the production rule varO10.3.2  Parsing the Variable Substitution SyntaxThe variable substitution syntax (e.g., $X) is parsed after all XML parsing is complete.  In XMLterminology, variable substitution is parsed after the XML processor has parsed the document andprovided the resulting parsed form to the XML application.  In the context of this specification, theWML parser and user agent is the XML application.This implies that all variable syntax is parsed after the XML constructs, such as tags and entities,have been parsed.  In the context of variable parsing, all XML syntax has a higher precedence thanthe variable syntax, e.g., entity substitution occurs before the variable substitution syntax is parsed.The following examples are identical references to the variable named X:$X&#x24;X$&#x58;&#36;&#x58;10.3.3  The Dollar-sign CharacterA side effect of the parsing rules is that the literal dollar sign must be encoded with a pair of dollarsign entities in any #PCDATA text or CDATA attribute values.  A single dollar-sign entity, evenspecified as &#x24;, results in a variable substitution.In order to include a '$' character in a WML deck, it must be explicitly escaped.  This can beaccomplished with the following syntax:$$Two dollar signs in a row are replaced with a single '$' character.  For example:This is a $$ character.This would be displayed as:This is a $ character.To include the '$' character in URL-escaped strings, specify it with the URL-escaped form:%2410.3.4  Setting  VariablesThere are a number of ways to set the value of a variable. When a variable is set and it is alreadydefined in the browser context, the current value is updated.WAP-191-WML, 19 February 2000Page 47 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe setvar element allows the author to set variable state as a side effect of navigation.  Setvarmay be specified in task elements, including go, prev and refresh.  The setvar elementspecifies a variable name and value, for example:<setvar name=\"location\" value=\"$(X)\"/>The variable specified in the name attribute (e.g., location) is set as a side effect of navigation.See the discussion of event handling (section 8.8 and section 12.5) for more information on theprocessing of the setvar element.Input elements set the variable identified by the name attribute to any information entered by theuser.  For example, an input element assigns the entered text to the variable, and the selectelement assigns the value present in the value attribute of the chosen option element.User input is written to variables when the user commits the input to the input or selectelement.  Committing input is an MMI dependent concept, and the WML author must not rely on aparticular user interface.  For example, some implementations will update the variable with eachcharacter entered into an input element, and others will defer the variable update until the inputelement has lost focus.  The user agent must update all variables prior to the execution of any task.The user agent may re-display the current card when variables are set, but the author must notassume that this action will occur.10.3.5  ValidationWithin the WML document, any string following a single dollar sign ('$') must be treated as avariable reference and validated, unless it is part of an escaped literal dollar sign sequenceaccording to section 10.3.3.  Each reference must use proper variable name syntax, according tosection 10.3.1. Each reference must be placed either within a card's text (#PCDATA) or within%vdata or %HREF attribute values. Other CDATA attribute values must use escaped literal dollarsign as required to prevent the creation of an otherwise valid variable reference.  The deck is inerror if any variable reference uses invalid syntax or is placed in an invalid location.Examples of invalid variable use:<!-- bad variable syntax -->Balance left is $10.00<!-- bad placement (in the type attribute) --><do type=\"x-$(type)\" label=\"$type\">Example of escaped dollar sign in an attribute of type CDATA:<!-- Dollar sign escaped in type attribute --><do type=\"x-$$(type)\" label=\"$type\">10.4  Context  RestrictionsUser agents may provide users means to reference and navigate to resources independent of thecurrent content.  For example, user agents may provide bookmarks, a URL input dialog, and soWAP-191-WML, 19 February 2000Page 48 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedforth.  Whenever a user agent navigates to a resource that was not the result of an interaction withthe content in the current context, the user agent must establish another context for that navigation.The user agent may terminate the current context before establishing another one for the newnavigation attempt.Conformance Rules:WML-13    Context restrictionsMWAP-191-WML, 19 February 2000Page 49 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.  The Structure of WML DecksWML data are structured as a collection of cards.  A single collection of cards is referred to as aWML deck.  Each card contains structured content and navigation specifications.  Logically, a usernavigates through a series of cards, reviews the contents of each, enters requested information,makes choices and navigates to another card or returns to a previously visited card.11.1  Document  PrologueA valid WML deck is a valid XML document and therefore must contain an XML declaration and adocument type declaration (see [XML] for more detail about the definition of a valid document).  Atypical document prologue contains:<?xml version=\"1.0\"?><!DOCTYPE wml PUBLIC \"-//WAPFORUM//DTD WML 1.3//EN\"\"http://www.wapforum.org/DTD/wml13.dtd\">It is an error to omit the prologue.11.2  The WML Element<!ELEMENT wml ( head?, template?, card+ )><!ATTLIST wmlxml:lang        NMTOKEN        #IMPLIED%coreattrs;>The wml element defines a deck and encloses all information and cards in the deck.Attributesxml:lang=nmtokenThe xml:lang attribute specifies the natural or formal language in which the document iswritten.  See section 8.8 for more detail.Conformance Rules:WML-53    wmlMWAP-191-WML, 19 February 2000Page 50 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.2.1  A  WML  ExampleThe following is a deck containing two cards, each represented by a card element (see section11.5 for information on cards).  After loading the deck, a user agent displays the first card.  If theuser activates the DO element, the user agent displays the second card.<wml><card><p><do type=\"accept\"><go href=\"#card2\"/></do>Hello world!This is the first card...</p></card><card id=\"card2\"><p>This is the second card.Goodbye.</p></card></wml>11.3  The Head Element<!ELEMENT head ( access | meta )+><!ATTLIST head%coreattrs;>The head element contains information relating to the deck as a whole, including meta-data andaccess control elements.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-30    bheadMWAP-191-WML, 19 February 2000Page 51 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.3.1  The Access Element<!ELEMENT access EMPTY><!ATTLIST accessdomain       CDATA       #IMPLIEDpath         CDATA       #IMPLIED%coreattrs;>The access element specifies access control information for the entire deck.  It is an error for adeck to contain more than one access element.  If a deck does not include an access element,access control is disabled. When access control is disabled, cards in any deck can access this deck.Attributesdomain=cdatapath=cdataA deck's domain and path attributes specify which other decks may access it.  As theuser agent navigates from one deck to another, it performs access control checks todetermine whether the destination deck allows access from the current deck.If a deck has a domain and/or path attribute, the referring deck's URI must match thevalues of the attributes. Matching is done as follows: the access domain is suffix-matchedagainst the domain name portion of the referring URI and the access path is prefix matchedagainst the path portion of the referring URI.Domain suffix matching is done using the entire element of each sub-domain and mustmatch each element exactly (e.g., www.wapforum.org shall match wapforum.org,but shall not match forum.org).  Path prefix matching is done using entire pathelements and must match each element exactly (e.g., /X/Y matches path=\"/X\" attribute,but does not match path=\"/XZ\" attribute).The domain attribute defaults to the current deck's domain. The path attribute defaults tothe value \"/\".To simplify the development of applications that may not know the absolute path to thecurrent deck, the path attribute accepts relative URIs. The user agent converts the relativepath to an absolute path and then performs prefix matching against the PATH attribute.For example, given the following access control attributes:domain=\"wapforum.org\"path=\"/cbb\"The following referring URIs would be allowed to go to the deck:http://wapforum.org/cbb/stocks.cgihttps://www.wapforum.org/cbb/bonds.cgihttp://www.wapforum.org/cbb/demos/alpha/packages.cgi?x=123&y=456WAP-191-WML, 19 February 2000Page 52 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe following referring URIs would not be allowed to go to the deck:http://www.test.net/cbbhttp://www.wapforum.org/internal/foo.wmlDomain and path follow URL capitalisation rules.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-21    accessM11.3.2  The Meta Element<!ELEMENT meta EMPTY><!ATTLIST metahttp-equiv     CDATA      #IMPLIEDname           CDATA      #IMPLIEDforua          %boolean;  \"false\"content        CDATA      #REQUIREDscheme         CDATA      #IMPLIED%coreattrs;>The meta element contains generic meta-information relating to the WML deck.  Meta-information is specified with property names and values.  This specification does not define anyproperties, nor does it define how user agents must interpret meta-data. User agents are not requiredto support the meta-data mechanism.A meta element must contain exactly one attribute specifying a property name; i.e., exactly onefrom the following set: http-equiv and name.Attributesname=cdataThis attribute specifies the property name.  The user agent must ignore any meta-datanamed with this attribute.  Network servers should not emit WML content containing meta-data named with this attribute.http-equiv=cdataThis attribute may be used in place of name and indicates that the property should beinterpreted as an HTTP header (see [RFC2068]).  Meta-data named with this attributeshould be converted to a WSP or HTTP response header if the content is tokenised before itarrives at the user agent.forua=booleanIf the value is \"false\" an intermediate agent MUST remove the \"meta\" element before thedocument is sent to the client. If the value is \"true\" the meta data of the element MUST beWAP-191-WML, 19 February 2000Page 53 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserveddelivered to the user-agent.  The method of delivery may vary. For example, http-equivmeta-data may be delivered using HTTP or WSP headers.content=cdataThis attribute specifies the property value.scheme=cdataThis attribute specifies a form or structure that may be used to interpret the property value.Scheme values vary depending on the type of meta-data.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-34    metaOWML-67    A meta element must not contain more than one attribute ofname and http-equivMWML-72    A meta element must not contain more than one attribute ofname and http-equivO11.4  The Template Element<!ENTITY % navelmts \"do | onevent\"><!ELEMENT template (%navelmts;)*><!ATTLIST template%cardev;%coreattrs;>The template element declares a template for cards in the deck. Event bindings specified in thetemplate element (e.g., do or onevent) apply to all cards in the deck.  Specifying an eventbinding in the template element is equivalent to specifying it in every card element.  A cardelement may override the behaviour specified in the template element.  In particular:• A do element specified in the template element may be overridden in individual cards ifboth elements have the same name attribute value.  See section 9.6 for more information.• Intrinsic event bindings specified in the template element may be overridden by thespecification of an event binding in a card element.  See section 9.6 for more information.See section 11.5.1 for the definition of the card-level intrinsic events (the cardev entity).WAP-191-WML, 19 February 2000Page 54 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributes defined elsewhere• id(see section 8.9)• class(see section 8.9)• onenterforward (see section 11.5.1)• onenterbackward (see section 11.5.1)• ontimer (see section 11.5.1)Conformance Rules:WML-47    templateM11.5  The Card ElementA WML deck contains a collection of cards. Each card can contain a variety of content. The user'sinteraction with the card depends on the type of content the card contains and how the content isrendered by the user agent.Conformance Rules:WML-25    cardM11.5.1  Card Intrinsic Events<!ENTITY % cardev\"onenterforward  %HREF;          #IMPLIEDonenterbackward %HREF;          #IMPLIEDontimer         %HREF;          #IMPLIED\">The following attributes are available in the card and template elements. Attributesonenterforward=HREFThe onenterforward event occurs when the user causes the user agent to navigate intoa card using a go task.onenterbackward=HREFThe onenterbackward event occurs when the user causes the user agent to navigateinto a card using a prev task.ontimer=HREFThe ontimer event occurs when a timer expires.WAP-191-WML, 19 February 2000Page 55 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.5.2  The Card Element<!ELEMENT card (onevent*, timer?, (do|p|pre)*)><!ATTLIST cardtitle           %vdata;       #IMPLIEDnewcontext      %boolean;     \"false\"ordered         %boolean;     \"true\"xml:lang        NMTOKEN       #IMPLIED%cardev;%coreattrs;>The card element is a container of text and input elements that is sufficiently flexible to allowpresentation and layout in a wide variety of devices, with a wide variety of display and inputcharacteristics.  The card element indicates the general layout and required input fields, but doesnot overly constrain the user agent implementation in the areas of layout or user input.  Forexample, a card can be presented as a single page on a large-screen device and as a series ofsmaller pages on a small-screen device.A card can contain markup, input fields and elements indicating the structure of the card.  Theorder of elements in the card is significant and should be respected by the user agent.  A card's idmay be used as a fragment anchor.  See section 5.2 for more information.Attributestitle=vdataThe title attribute specifies advisory information about the card. The title may berendered in a variety of ways by the user agent (e.g., suggested bookmark name, pop-uptooltip, etc.).newcontext=booleanThis attribute indicates that the current browser context should be re-initialised upon entryto this card.  See section 10.2 for more information.ordered=booleanThis attribute specifies a hint to the user agent about the organisation of the card content.This hint may be used to organise the content presentation or to otherwise influence layoutof the card.• ordered=\"true\" - the card is naturally organised as a linear sequence of fieldelements, e.g., a set of questions or fields which are naturally handled by the user in theorder in which they are specified in the group.  This style is best for short forms inwhich no fields are optional (e.g., sending an email message requires a To: address, asubject and a message, and they are logically specified in this order).It is expected that in small-screen devices, ordered groups may be presented as asequence of screens, with a screen flip in between each field or fieldset.  Other useragents may elect to present all fields simultaneously.WAP-191-WML, 19 February 2000Page 56 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved• ordered=\"false\" - the card is a collection of field elements without a natural order.This is useful for collections of fields containing optional or unordered components orsimple record data where the user is updating individual input fields.It is expected that in small-screen devices, unordered groups may be presented by usinga hierarchical or tree organisation.  In these types of presentation, the title attributeof each field and fieldset may be used to define the name presented to the user in thetop-level summary card.  A user agent may organise an unordered collection of elementsin an ordered fashion.The user agent may interpret the ordered attribute in a manner appropriate to its devicecapabilities (e.g., screen size or input device).  In addition, the user agent should adopt userinterface conventions for handling the editing of input elements in a manner that best suitsthe device's input model.For example, a phone-class device displaying a card with ordered=\"false\" may usea softkey or button to select individual fields for editing or viewing.  A PDA-class devicemight create soft buttons on demand, or simply present all fields on the screen for directmanipulation.On devices with limited display capabilities, it is often necessary to insert screen flips orother user-interface transitions between fields.  When this is done, the user agent needs todecide on the proper boundary between fields.  User agents may use the following heuristicfor determining the choice of a screen flip location:• fieldset defines a logical boundary between fields.• Fields (e.g., input) may be individually displayed.  When this is done, the line ofmarkup (flow) immediately preceding the field should be treated as a field prompt anddisplayed with the input element.  The table must be treated differently than inputand select.  The user agent must insert a line break before each table element,except when it is the first non-whitespace markup in a card.  The user agent must inserta line break after each table element, except when it is the final element in a card.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)• onenterforward(see section 11.5.1)• onenterbackward(see section 11.5.1)• ontimer(see section 11.5.1)WAP-191-WML, 19 February 2000Page 57 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.5.2.1 A Card ExampleThe following is an example of a simple card element embedded within a WML deck.  The cardcontains text, which is displayed by the user agent.  In addition, the example demonstrates the useof a simple DO element, defined at the deck level.<wml><template><do type=\"accept\" label=\"Exit\"><prev/></do></template><card><p>Hello World!</p></card></wml>11.6  Control  Elements11.6.1  The Tabindex AttributeAttributestabindex=numberThis attribute specifies the tabbing position of the current element.  The tabbing positionindicates the relative order in which elements are traversed when tabbing within a singleWML card.  A numerically greater tabindex value indicates an element that is later in thetab sequence than an element with a numerically lesser tabindex value.Each input element (i.e., input and select) in a card is assigned a position in the card'stab sequence.  In addition, the user agent may assign a tab position to other elements.  Thetabindex attribute indicates the tab position of a given element.  Elements that are notdesignated with an author-specified tab position may be assigned one by the user agent.User agent specified tab positions must be later in the tab sequence than any author-specified tab positions.Tabbing is a navigational accelerator and is optional for all user agents.  Authors must notassume that a user agent implements tabbing.11.6.2  Select  ListsSelect lists are an input element that specifies a list of options for the user to choose from.  Singleand multiple choice lists are supported.WAP-191-WML, 19 February 2000Page 58 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.6.2.1 The Select Element<!ELEMENT select (optgroup|option)+><!ATTLIST selecttitle        %vdata;           #IMPLIEDname         NMTOKEN           #IMPLIEDvalue        %vdata;           #IMPLIEDiname        NMTOKEN           #IMPLIEDivalue       %vdata;           #IMPLIEDmultiple     %boolean;         \"false\"tabindex     %number;          #IMPLIEDxml:lang     NMTOKEN           #IMPLIED%coreattrs;>The select element lets users pick from a list of options. Each option is specified by an optionelement.  Each option element may have one line of formatted text (which may be wrapped ortruncated by the user agent if too long).  Option elements may be organised into hierarchicalgroups using the optgroup element.Attributesmultiple=booleanThis attribute indicates that the select list should accept multiple selections.  When not set,the select list should only accept a single selected option.name=nmtokenvalue=vdataThis name attribute indicates the name of the variable to set with the result of the selection.The variable is set to the string value of the chosen option element, which is specifiedwith the value attribute. The name variable's value is used to pre-select options in theselect list.The value attribute indicates the default value of the variable named in the nameattribute.  When the element is displayed, and the variable named in the name attribute isnot set, the name variable may be assigned the value specified in the value attribute,depending on the values defined in iname and ivalue.  If the name variable alreadycontains a value, the value attribute is ignored. Any application of the default value isdone before the list is pre-selected with the value of the name variable.If this element allows the selection of multiple options, the result of the user's choice is a listof all selected values, separated by the semicolon character.  The name variable is set withthis result.  In addition, the value attribute is interpreted as a semicolon-separated list ofpre-selected options.iname=nmtokenivalue=vdataThe iname attribute indicates the name of the variable to be set with the index result of theselection.  The index result is the position of the currently selected option in the selectWAP-191-WML, 19 February 2000Page 59 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedlist.  An index of zero indicates that no option is selected.  Index numbering begins at oneand increases monotonically.The ivalue attribute indicates the default-selected option element. When the element isdisplayed, if the variable named in the iname attribute is not set, it is assigned the default-selected entry. If the variable already contains a value, the ivalue attribute is ignored. Ifthe iname attribute is not specified, the ivalue value is applied every time the element isdisplayed.If this element allows the selection of multiple options, the index result of the user's choiceis a list of the indices of all the selected options, separated by the semicolon character (e.g.,\"1;2\").  The iname variable is set with this result.  In addition, the ivalue attribute isinterpreted as a semicolon-separated list of pre-selected options (e.g., \"1;4\").title=vdataThis attribute specifies a title for this element, which may be used in the presentation of thisobject.Attributes defined elsewhere• xml:lang (see section 8.8)• id (see section 8.9)• class(see section 8.9)• tabindex (see section 11.6.1)On entry into a card containing a select element, the user agent must select the initial optionelement’s options and update associated variables (specified by the name or iname attributes) inthe following manner. If the card contains multiple select elements, or input elements alongwith select elements, the initialisation must take place in the order that the elements appear inthe card.Note that values are a semicolon delimited list of values when multiple=\"true\", but areotherwise treated as a single value (even if they contain semicolons).  In addition, the default optionindex is an aggregate value (a list) when multiple=\"true\" and is otherwise a single index.The selection of initial option elements includes an operation named validate.  This operates on avalue, and determines if that value is a legal option index (or indices when multiple=\"true\").The operation consists of the following steps:1. Remove all non-integer indices from the value.2. Remove all out-of-range indices from the value, where out-of-range is defined as any indexwith a value greater than the number of options in the select or with a value less than one.3. Remove duplicate indicesNote that an invalid index will result in an empty value.WAP-191-WML, 19 February 2000Page 60 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe selection of the initial option elements consists of the following steps:Step 1 - the default option index is determined using iname and ivalue:• IF the iname attribute is specified AND names a variable that is set, THEN the default optionindex is the validated value of that variable.• IF the default option index is empty AND the ivalue attribute is specified, THEN the defaultoption index is the validated attribute value.• IF the default option index is empty, AND the name attribute is specified AND the nameattribute names a variable that is set, THEN for each value in the name variable that is presentas a value in the select's option elements, the index of the first option elementcontaining that value is added to the default index if that index has not been previously added.• IF the default option index is empty AND the value attribute is specified THEN for eachvalue in the value attribute that is present as a value in the select's option elements, theindex of the first option element containing that value is added to the default index if thatindex has not been previously added.• IF the default option index is empty AND the select is a multi-choice, THEN the defaultoption index is set to zero.• IF the default option index is empty AND the select is a single-choice, THEN the defaultoption index is set to one.Step 2 – initialise variables• IF the name attribute is specified AND the select is a single-choice element, THEN thenamed variable is set with the value of the value attribute on the option element at thedefault option index.• Else, IF the name attribute is specified and the select is a multiple-choice element, THENfor each index greater than zero, the value of the value attribute on the option element atthe index is added to the name variable.• IF the iname attribute is specified, THEN the named variable is set with the default optionindex.Step 3 – pre-select option(s) specified by the default option index• Deselect all options• For each index greater than zero, select the option specified by the index.WAP-191-WML, 19 February 2000Page 61 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedWhen the user selects or deselects one or more option elements, the name and iname variablesare updated with the option's value and index.  The name is unset if all selected option elementscontain an empty value attribute.  However, in all cases, the user agent must not exhibit displayside effects as a result of updating name and iname variables, except when there is an explicitrefresh task (see section 9.4.3).  The user agent must update name and iname variables (ifspecified) for each select element in the card before each and all task invocations according tosteps 1 and 2 above.Multiple choice selection lists result in a value that is a semicolon delimited list (e.g.,\"dog;cat\").  This is not an ordered list and the user agent is free to construct the list in any orderthat is convenient.  Authors must not rely on a particular value ordering.  The user agent mustensure that the iname result contains no duplicate index values.  The name result must containduplicate values in the situation where multiple selected option elements have the same value.The name result must not contain empty values (e.g., \"cat;;dog\" is illegal).Conformance Rules:WML-43    selectM11.6.2.2 The Option Element<!ELEMENT option (#PCDATA | onevent)*><!ATTLIST optionvalue      %vdata;    #IMPLIEDtitle      %vdata;    #IMPLIEDonpick     %HREF;     #IMPLIEDxml:lang   NMTOKEN    #IMPLIED%coreattrs;>This element specifies a single choice option in a select element.Attributesvalue=vdataThe value attribute specifies the value to be used when setting the name variable.  Whenthe user selects this option, the resulting value specified in the value attribute is used toset the select element's name variable.The value attribute may contain variable references, which are evaluated before the namevariable is set.title=vdataThis attribute specifies a title for this element, which may be used in the presentation of thisobject.onpick=HREFThe onpick event occurs when the user selects or deselects this option.  A multiple-selection option list generates an onpick event whenever the user selects or deselects thisWAP-191-WML, 19 February 2000Page 62 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedoption. A single-selection option list generates an onpick event when the user selects thisoption, i.e., no event is generated for the de-selection of any previously selected option.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-41    optionM11.6.2.3 The Optgroup Element<!ELEMENT optgroup (optgroup|option)+ ><!ATTLIST optgrouptitle      %vdata;    #IMPLIEDxml:lang   NMTOKEN    #IMPLIED%coreattrs;>The optgroup element allows the author to group related option elements into a hierarchy.Within a hierarchy, all leaf elements must be option elements (i.e., it is an error to build ahierarchy that contains a leaf optgroup element.  The user agent may use this hierarchy tofacilitate layout and presentation on a wide variety of devices.  The user agent may choose not tobuild a hierarchy effectively ignoring optgroup elements.  However, in all cases, the user agentmust continue processes all the element’s children.Attributestitle=vdataThis attribute specifies a title for this element, which may be used in the presentation of thisobject.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-40    optgroupOWAP-191-WML, 19 February 2000Page 63 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.6.2.4 Select list examplesIn this example, a simple single-choice select list is specified.  If the user were to choose the \"Dog\"option, the variable \"X\" would be set to a value of \"D\".<wml><card><p>Please choose your favourite animal:<select name=\"X\"><option value=\"D\">Dog</option><option value=\"C\">Cat</option></select></p></card></wml>In this example, a single choice select list is specified.  If the user were to choose the \"Cat\" option,the variable \"I\" would be set to a value of \"2\".  In addition, the \"Dog\" option would be pre-selectedif the \"I\" variable had not been previously set.<wml><card><p>Please choose your favourite animal:<select iname=\"I\" ivalue=\"1\"><option value=\"D\">Dog</option><option value=\"C\">Cat</option></select></p></card></wml>WAP-191-WML, 19 February 2000Page 64 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedIn this example, a multiple-choice list is specified.  If the user were to choose the \"Cat\" and \"Horse\"options, the variable \"X\" would be set to \"C;H\" and the variable \"I\" would be set to \"2;3\".  Inaddition, the \"Dog\" and \"Cat\" options would be pre-selected if the variable \"I\" had not beenpreviously set.<wml><card><p>Please choose <i>all</i> of your favourite animals:<select name=\"X\" iname=\"I\" ivalue=\"1;2\" multiple=\"true\"><option value=\"D\">Dog</option><option value=\"C\">Cat</option><option value=\"H\">Horse</option></select></p></card></wml>In this example, a single choice select list is specified. The variable \"F\" would be set to the value of\"S\" if the user chooses the first option.  The second option is always pre-selected, regardless of thevalue of the variable \"F\".<wml><card><p>Please choose from the menu:<select name=\"F\" ivalue=\"2\"><option value=\"S\">Sandwich</option><option value=\"D\">Drink</option></select></p></card></wml>In this example, the use of the onpick intrinsic event is demonstrated.  If the user selects thesecond option, a go will be performed to the ”/morehelp.wml” URL.<wml><card><p>Select type of help:<select><option onpick=\"/help.wml\">Help</option><option onpick=\"/morehelp.wml\">More Help</option></select></p></card></wml>WAP-191-WML, 19 February 2000Page 65 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedIn this example, if the name variable is set to the value \"1;2\", the third option will be pre-selected.  This demonstrates that values containing semicolons are treated as a single value in asingle-choice selection element.<wml><card><p>Select one:<select name=\"K\"><option value=\"1\">One</option><option value=\"2\">Two</option><option value=\"1;2\">Both</option></select></p></card></wml>11.6.3  The Input Element<!ELEMENT input EMPTY><!ATTLIST inputname       NMTOKEN           #REQUIREDtype       (text|password)   \"text\"value      %vdata;           #IMPLIEDformat     CDATA             #IMPLIEDemptyok    %boolean;         #IMPLIEDsize       %number;          #IMPLIEDmaxlength  %number;          #IMPLIEDtabindex   %number;          #IMPLIEDtitle      %vdata;           #IMPLIEDaccesskey  %vdata;           #IMPLIEDxml:lang   NMTOKEN           #IMPLIED%coreattrs;>The input element specifies a text entry object. The user’s input is constrained by thecombination of the optional format and emptyok attributes.  If a valid input mask is bound to aninput object, the user agent must ensure that any value collected by the entry object conforms to thebound input mask when the user attempts to commit the value.  If the input collected does notconform to the input mask, the user agent must not commit that input and must notify the user thatthe input was rejected and allow the user to resubmit new input.  In this case, the variable specifiedin the name attribute must not be modified from its original value.  The user agent may validateeach character against the input mask as the user enters it.All input objects that represent the input elements (and select elements, if any) within the cardmust be initialised when the card is rendered, and the initialisation must take place in the order thatthe elements appear in the card.  The initialisation must be done with the following two steps:• The user agent decides the initial value from the name and value attributes, and if neededsets or unsets the variable specified in the name attribute (see attributes description below).WAP-191-WML, 19 February 2000Page 66 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved• The user agent pre-loads the initial value into the input object (e.g., renders the initialvalue into the text entry object).If the user clears the initial value of an input object and attempts to commit that input, it isregarded as a submission of an empty string.  The user agent must accept the submission of anempty string only when the input mask allows an empty string.Attributesname=nmtokenvalue=vdataThe name attribute specifies the name of the variable to set with the result of the user's textinput.  The name variable's value is used as the initial value of the input object.  If thename variable contains a value that does not conform to the input mask, the user agent mustunset the variable and attempt to initialise the variable with the value attribute.The value attribute indicates the default value of the variable named in the nameattribute.  When the element is displayed and the variable named in the name attribute isnot set, the name variable is assigned the value specified in the value attribute.  If thename variable already contains a value, the value attribute is ignored. If the valueattribute specifies a value that does not conform to the input mask specified by the formatattribute, the user agent must ignore the valueattribute. In the case where no valid valuecan be established, the name variable is left unset and the input object must be initialisedwith the empty string.type=(text|password)This attribute specifies the type of text-input area.  The default type is text.  The followingvalues are allowed:• text - a text entry control.  User agents should echo the input in a manner appropriateto the user agent and the input mask.  If the submitted value conforms to an existinginput mask, the user agent must store that input unaltered and in its entirety in thevariable named in the name attribute.  For example, the user agent must not trim theinput by removing leading or trailing white space from the input. If the variable namedby the name attribute is unset, the user agent should echo an empty string in anappropriate manner.• password - a text entry control. Input of each character should be echoed in anobscured or illegible form in a manner appropriate to the user agent.  For example,visual user agents may elect to display an asterisk in place of a character entered by theuser.  Typically, the password input mode is indicated for password entry or otherprivate data.  Note that Password input is not secure and should not be depended onfor critical applications.  Similar to a text type, if the submitted value conforms to anexisting input mask, the user agent must store input unaltered and in its entirety in thevariable named in the name attribute.  User agents should not obscure non-formattingWAP-191-WML, 19 February 2000Page 67 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedcharacters of the input mask.  If the variable named by the name attribute is unset, theuser agent should echo an empty string in an appropriate manner.format=cdataThe format attribute specifies an input mask for user input entries. The string consists ofmask control characters and static text that is displayed in the input area.  The user agentmay use the format mask to facilitate accelerated data input (e.g. the user agent may changeits input mode according to the format code of the current position of the input cursor).  Aninput mask is only valid when it contains only legal format codes and static text.  Useragents must ignore invalid masks.Character categories are as defined by [Unicode]:• “Letter” refers to character categories Lu, Ll, Lm, and Lo.• “Uppercase letter” refers to character categories Lu and Lm.• “Lowercase letter” refers to character categories Ll and Lm.• “Numeric character” refers to the character category Nd.• “Punctuation” refers to character categories Pc, Pd, Ps, Pe, and Po.• “Symbol” refers to character categories Sm, Sc, Sk, and So.User agents need only be capable of displaying and accepting the subsets of the above setsthat are appropriate for all languages that they support.  However, all user agents mustsupport ASCII graphic characters of the Unicode Basic Latin block (U+0020 – U+007E).For a given input element, user agents may choose to restrict the set of allowable charactersto those appropriate for the current language(s).The current languages are the superset of:• the current language of the WML deck, plus• the user agent’s accept language(s), plus• the user agent’s interface language.In caseless languages, format codes distinguishing between upper and lowercase areequivalent.The format control characters specify the data format expected to be entered by the user.The default format is \"*M\".  The format codes are:Aentry of any uppercase letter, symbol, or punctuation character.  Numericcharacters are excluded.WAP-191-WML, 19 February 2000Page 68 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedaentry of any lowercase letter, symbol, or punctuation character.  Numericcharacters are excluded.Nentry of any numeric character.nentry of any numeric, symbol, or punctuation character.Xentry of any uppercase letter, numeric character, symbol, or punctuationcharacter.xentry of any lowercase letter, numeric character, symbol, or punctuationcharacter.Mentry of any character valid in the current languages, including any letter,numeric, symbol, or punctuation character.  If the language supports case and thehardware supports both upper and lower case entry, the user agent may choose todefault to uppercase entry mode but must allow entry of any character.mentry of any character valid in the current languages, including any letter,numeric, symbol, or punctuation character. If the language supports case and thehardware supports both upper and lower case entry, the user agent may choose todefault to lowercase entry mode but must allow entry of any character.*f entry of any number of characters; f is one of the above format codes andspecifies what kind of characters can be entered.  Note: This format may only bespecified once and must appear at the end of the format string.nfentry of up to n characters where n is from 1 to 9; f is one of the above formatcodes (other than *f format code) and specifies what kind of characters can beentered.  Note: This format may only be specified once and must appear at theend of the format string.\\cdisplay the next character, c, in the entry field; allows escaping of the formatcodes as well as introducing non-formatting characters so they can be displayedin the entry area.  Escaped characters are considered part of the input's value, andmust be preserved by the user agent.  For example, the stored value of the input\"12345-123\" having a mask \"NNNNN\\-3N\" is \"12345-123\" and not\"12345123\".  Similarly, if the value of the variable named by the nameattribute is \"12345123\" and the mask is \"NNNNN\\-3N\", the user agent mustunset the variable since it does not conform to the mask.emptyok=booleanThe emptyok attribute indicates whether this input element accepts empty input or not.If emptyok is true, input is not required even if the format mask would otherwise requireit.  If emptyok is false, input is required even if the format mast would otherwise notrequire it.WAP-191-WML, 19 February 2000Page 69 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedIf the author does not explicitly specify the emptyok attribute, the format attribute fullydefines the input requirement. The implied value of the emptyok attribute is “true” whenthe format attribute allows empty input (i.e., the format mask is implied or a “*f” formatcode). Otherwise, the implied value of the attribute is “false”.Whether or not input is required, any input given must match the format specification.For the following input elements, input is required:<input name=”x” format=”M*M”/>        <!-- implied: emptyok=”false” --><input name=”x” emptyok=”false”/>         <!-- implied: format=”*M” --><input name=”x” emptyok=”false” format=”M*M”/><input name=”x” emptyok=”false” format=”*M”/>For the following input elements, input is not required:<input name=”x”/>          <!-- implied: format=”*M” emptyok=”true” --><input name=”x” format=”*M”/>          <!-- implied: emptyok=”true” --><input name=”x” emptyok=”true”/>          <!-- implied: format=”*M” --><input name=”x” emptyok=”true” format=”M*M”/><input name=”x” emptyok=”true” format=”*M”/>size=numberThis attribute specifies the width, in characters, of the text-input area.  The user agent mayignore this attribute.maxlength=numberThis attribute specifies the maximum number of characters that can be entered by the user inthe text-entry area.  The default value for this attribute is an unlimited number of characters.title=vdataThis attribute specifies a title for this element, which may be used in the presentation of thisobject.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)• tabindex (see section 11.6.1)• accesskey (see section 9.8)Conformance Rules:WML-33    inputM11.6.3.1 Input Element ExamplesIn this example, an input element is specified.  This element accepts any characters and displaysthe input to the user in a human-readable form.  The maximum number of character entered is 32and the resulting input is assigned to the variable named X.WAP-191-WML, 19 February 2000Page 70 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved<input name=\"X\" type=\"text\" maxlength=\"32\"/>The following example requests input from the user and assigns the resulting input to the variablename.  The text field has a default value of \"Robert\".<input name=\"NAME\" type=\"text\" value=\"Robert\"/>The following example is a card that prompts the user for a first name, last name and age.<card><p>First name: <input type=\"text\" name=\"first\"/><br/>Last name: <input type=\"text\" name=\"last\"/><br/>Age: <input type=\"text\" name=\"age\" format=\"*N\"/></p></card>11.6.4  The Fieldset Element<!ELEMENT fieldset (%fields; | do)* ><!ATTLIST fieldsettitle           %vdata;      #IMPLIEDxml:lang        NMTOKEN      #IMPLIED%coreattrs;>The fieldset element allows the grouping of related fields and text.  This grouping providesinformation to the user agent, allowing the optimising of layout and navigation.  Fieldsetelements may nest, providing the user with a means of specifying behaviour across a wide varietyof devices.  It is an error to include empty fieldset elements. See section 11.5.2 for informationon how the fieldset element may influence layout and navigation.  If a user agent chooses todiscard fieldsets, it must continue to process all its children.Attributestitle=vdataThis attribute specifies a title for this element, which may be used in the presentation of thisobject.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-28    fieldsetOWAP-191-WML, 19 February 2000Page 71 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.6.4.1 Fieldset Element ExamplesThe following example specifies a WML deck that requests basic identity and personal informationfrom the user.  It is separated into multiple field sets, indicating the preferred field grouping to theuser agent.<wml><card><p><do type=\"accept\"><go href=\"/submit?f=$(fname)&amp;l=$(lname)&amp;s=$(sex)&amp;a=$(age)\"/></do><fieldset title=\"Name\">First name:<input type=\"text\" name=\"fname\" maxlength=\"32\"/><br/>Last name:<input type=\"text\" name=\"lname\" maxlength=\"32\"/></fieldset><fieldset title=\"Info\"><select name=\"sex\"><option value=\"F\">Female</option><option value=\"M\">Male</option></select><br/>Age: <input type=\"text\" name=\"age\" format=\"*N\"/></fieldset></p></card></wml>11.7  The Timer Element<!ELEMENT timer EMPTY><!ATTLIST timername       NMTOKEN           #IMPLIEDvalue      %vdata;           #REQUIRED%coreattrs;>The timer element declares a card timer, which exposes a means of processing inactivity or idletime.  The timer is initialised and started at card entry and is stopped when the card is exited.  Cardentry is any task or user action that results in the card being activated, for example, navigating intothe card.  Card exit is defined as the execution of any task (see sections 9.5 and 12.5).  The value ofa timer will decrement from the initial value, triggering the delivery of an ontimer intrinsic eventon transition from a value of one to zero.  If the user has not exited the card at the time of timerexpiration, an ontimer intrinsic event is delivered to the card.Timer resolution is implementation dependent.  The interaction of the timer with the user agent'suser interface and other time-based or asynchronous device functionality is implementationdependent.  It is an error to have more than one timer element in a card.WAP-191-WML, 19 February 2000Page 72 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe timer timeout value is specified in units of one-tenth (1/10) of a second.  The author shouldnot expect a particular timer resolution and should provide the user with another means to invoke atimer's task. If the value of the timeout is not a positive integral number, the user agent must ignorethe timer element.  A timeout value of zero (0) disables the timer.Invoking a refresh task is considered an exit.  The task stops the timer, commits it’s value to thecontext, and updates the user agent accordingly. Completion of the refresh task is considered anentry to the card.  At that time, the timer must resume.Attributesname=nmtokenThe name attribute specifies the name of the variable to be set with the value of the timer.The name variable's value is used to set the timeout period upon timer initialisation.  Thevariable named by the name attribute will be set with the current timer value when the cardis exited or when the timer expires.  For example, if the timer expires, the name variable isset to a value of \"0\".value=vdataThe value attribute indicates the default value of the variable named in the nameattribute.  When the timer is initialised and the variable named in the name attribute is notset, the name variable is assigned the value specified in the value attribute.  If the namevariable already contains a value, the value attribute is ignored.  If the name attribute isnot specified, the timeout is always initialised to the value specified in the value attribute.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-48    timerM11.7.1  Timer  ExampleThe following deck will display a text message for approximately 10 seconds and will then go tothe URL next.<wml><card ontimer=\"/next\"><timer value=\"100\"/><p>Hello World!</p></card></wml>WAP-191-WML, 19 February 2000Page 73 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedThe same example could be implemented as:<wml><card><onevent type=”ontimer\"><go href=”/next”/></onevent><timer value=\"100\"/><p>Hello World!</p></card></wml>The following example illustrates how a timer can initialise and reuse a counter.  Each time thecard is entered, the timer is reset to value of the variable t.  If t is not set, the timer is set to a valueof 5 seconds.<wml><card ontimer=”/next\"><timer name=”t” value=\"50\"/><p>Hello World!</p></card></wml>11.8  TextThis section defines the elements and constructs related to text.11.8.1  White  SpaceWML white space and line break handling is based on [XML] and assumes the default XML whitespace handling rules for text.  The WML user agent ignores all insignificant white space inelements and attribute values, as defined by the XML specification. White space immediatelybefore and after an element is ignored. In addition, all other sequences of white space must becompressed into a single inter-word space.User agents should treat inter-word spaces in a locale-dependent manner, as different writtenlanguages treat inter-word spacing in different ways.11.8.2  Emphasis<!ELEMENT em     (%flow;)*><!ATTLIST emxml:lang        NMTOKEN       #IMPLIED%coreattrs;>WAP-191-WML, 19 February 2000Page 74 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved<!ELEMENT strong (%flow;)*><!ATTLIST strongxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT i      (%flow;)*><!ATTLIST ixml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT b      (%flow;)*><!ATTLIST bxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT u      (%flow;)*><!ATTLIST uxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT big    (%flow;)*><!ATTLIST bigxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT small  (%flow;)*><!ATTLIST smallxml:lang        NMTOKEN       #IMPLIED%coreattrs;>The emphasis elements specify text emphasis markup information.em:Render with emphasis.strong:Render with strong emphasis.i:Render with an italic font.b:Render with a bold font.u:Render with underline.big:Render with a large font.small:Render with a small font.Authors should use the strong and em elements where possible.  The b, i and u elements shouldnot be used except where explicit control over text presentation is required.Visual user agents must distinguish emphasised text from non-emphasised text.  A user agentshould do a best effort to distinguish the various forms of emphasised text as described above.  Itshould distinguish text that has been emphasised using the em element from that using strongWAP-191-WML, 19 February 2000Page 75 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedelement.  User agents may use the same style for strong, b, and big emphasis.  It may also usethe same style for em, i, u, and small emphasis.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-22    bOWML-23    bigOWML-27    emOWML-31    iOWML-44    smallOWML-45    strongOWML-51    uO11.8.3  Paragraphs<!ENTITY % TAlign \"(left|right|center)\"><!ENTITY % WrapMode \"(wrap|nowrap)\" ><!ELEMENT p (%fields; | do)*><!ATTLIST palign       %TAlign;     \"left\"mode        %WrapMode;   #IMPLIEDxml:lang    NMTOKEN      #IMPLIED%coreattrs;>WML has two line-wrapping modes for visual user agents: breaking (or wrapping) and non-breaking (or non-wrapping).  The treatment of a line too long to fit on the screen is specified by thecurrent line-wrap mode.  If mode=\"wrap\" is specified, the line is word-wrapped onto multiplelines. In this case, line breaks should be inserted into a text flow as appropriate for presentation onan individual device. If mode=\"nowrap\" is specified, the line is not automatically wrapped. Inthis case, the user agent must provide a mechanism to view entire non-wrapped lines (e.g.,horizontal scrolling or some other user-agent-specific mechanism).Any inter-word space is a legal line break point.  The non-breaking space entity (&nbsp;or&#160;) indicates a space that must not be treated as an inter-word space by the user agent.Authors should use &nbsp; to prevent undesired line-breaks.  The soft-hyphen character entity(&shy;or&#173;) indicates a location that may be used by the user agent for a line break.  If aline break occurs at a soft-hyphen, the user agent must insert a hyphen character (&#45;) at theWAP-191-WML, 19 February 2000Page 76 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedend of the line.  In all other operations, the soft-hyphen entity should be ignored.  A user agent maychoose to entirely ignore soft-hyphens when formatting text lines.The p element establishes both the line wrap and alignment parameters for a paragraph.  If the textalignment is not specified, it defaults to left. If the line-wrap mode is not specified, it is identicalto the line-wrap mode of the previous paragraph in the current card. Empty paragraphs (i.e., anempty element or an element with only insignificant white space) should be considered asinsignificant and ignored by visual user agents.  Insignificant paragraphs do not impact line-wrapmode.  If the first p element in a card does not specify a line-wrap or alignment mode, that modedefaults to the initial mode for the card.  The user agent must insert a line break into the text flowbetween significant p elements.Insignificant paragraphs may be removed before the document is delivered to the user agent.Attributesalign=(left|right|center)This attribute specifies the text alignment mode for the paragraph.  Text can be centrealigned, left aligned or right aligned when it is displayed to the user.  Left alignment is thedefault alignment mode.  If not explicitly specified, the text alignment is set to the defaultalignment.mode=(wrap|nowrap)This attribute specifies the line-wrap mode for the paragraph.  Wrap specifies breaking textmode and nowrap specifies non-breaking text mode.  If not explicitly specified, the line-wrap mode is identical to the line-wrap mode of the previous paragraph in the text flow of acard.  The default mode for the first paragraph in a card is wrap.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-36    pM11.8.4  The  Br  Element<!ELEMENT br EMPTY><!ATTLIST br%coreattrs;>The br element establishes the beginning of a new line.  The user agent must break the current lineand continue on the following line. User agents should do best effort to support the br element intables (see section 11.8.7).WAP-191-WML, 19 February 2000Page 77 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-24    brM11.8.5  The Table Element<!ELEMENT table (tr)+><!ATTLIST tabletitle       %vdata;    #IMPLIEDalign       CDATA      #IMPLIEDcolumns     %number;   #REQUIREDxml:lang    NMTOKEN    #IMPLIED%coreattrs;>The table element is used together with the tr and td elements to create sets of aligned columnsof text and images in a card. Nesting of table elements it not allowed. The table elementsdetermine the structure of the columns. The elements separate content into columns, but do notspecify column or intercolumn widths. The user agent should do its best effort to present theinformation of the table in a manner appropriate to the device.Attributestitle=vdataThis attribute specifies a title for this element, which may be used in the presentation of thisobject.align=cdataThis attribute specifies the layout of text and images within the columns of a table.  Acolumn’s contents can be centre aligned, left aligned or right aligned when it is rendered tothe user.  The attribute value is interpreted as a non-separated list of alignment designations,one for each column.  Centre alignment is specified with the value “C”, left alignment isspecified with the value “L”, right alignment is specified with the value “R”, and defaultalignment is specified with the value “D”. Designators are applied to columns as they aredefined in the content.  The first designator in the list applies to the first column, the seconddesignator to the second column, and so forth.  Default alignment is applied to columns thatare missing alignment designators or have unrecognised designators.  All extra designatorsare ignored.  Determining the default alignment is implementation dependent.  User agentsshould consider the current language when determining the default alignment and thedirection of the table.  A user agent may use other algorithms to make such decisions.columns=numberThis required attribute specifies the number of columns for the table.  The user agent mustcreate a table with exactly the number of columns specified by the attribute value.  It is anerror to specify a value of zero (“0”).WAP-191-WML, 19 February 2000Page 78 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedIf  the  actual  number  of  columns  in  a  row  is  less  than  the  value  specified  by  the  columnsattribute,  the  row  must  be  padded  with  empty  columns  effectively  as  if  the  user  agentappended empty td elements to the row.If the actual number of columns in a row is greater than the value specified by this attribute,the  extra  columns  of  the  row  must  be  aggregated  into  the  last  column  such  that  the  rowcontains  exactly  the  number  of  columns  specified.    A  single  inter-word  space  must  beinserted between two cells that are being aggregated.The presentation of the table is likely to depend on the display characteristics of the device.WML  does  not  define  how  a  user  agent  renders  a  table.    User  agents  may  create  alignedcolumns for each table, or it may use a single set of aligned columns for all tables in a card.User  agents  that  choose  to  render  a  table  in  a  traditional  tabular  manner  should  determinethe width of each column from the maximum width of the text and images in that column toensure  the  narrowest  display  width.  However,  user  agents  may  use  fixed  width  or  otherappropriate  layout  algorithms  instead.    User  agents  that  choose  to  render  tables  in  atraditional  tabular  manner  must  use  a  non-zero  width  gutter  to  separate  each  non-emptycolumn.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-46    tableMWML-68    The number of columns in a table must not be set to zeroMWML-73    The number of columns in a table must not be set to zeroO11.8.6  The Tr Element<!ELEMENT tr (td)+><!ATTLIST tr%coreattrs;>The tr element is used as a container to hold a single table row.  Table rows may be empty (i.e., allcells are empty).  Empty table rows are significant and must not be ignored.Attributes defined elsewhere• id(see section 8.9)• class(see section 8.9)Conformance Rules:WAP-191-WML, 19 February 2000Page 79 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedWML-50    trM11.8.7  The Td Element<!ELEMENT td ( %text; | %layout; | img | anchor|a)*><!ATTLIST tdxml:lang        NMTOKEN       #IMPLIED%coreattrs;>The td element is used as a container to hold a single table cell data within a table row.  Table datacells may be empty.  Empty cells are significant, and must not be ignored.  The user agent shoulddo a best effort to deal with multiple line data cells that may result from using images or linebreaks.Attributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-49    tdM11.8.8  Table  ExampleThe following example contains a card with a single column group, containing two columns andthree rows.<wml><card><p><table columns=\"2\" align=\"LL\"><tr><td>One </td><td> Two </td></tr><!-- row missing cells --><tr><td>1</td></tr><!-- row with too many cells --><tr><td/><td> B </td><td>C<br/>D</td></tr></table></p></card></wml>An acceptable layout for this card is:One     Two1BCDWAP-191-WML, 19 February 2000Page 80 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved11.8.9  The Pre Element<!ELEMENT pre \"(#PCDATA|a|anchor | do|u|br|i|b|em|strong | input | select )*\"><!ATTLIST prexml:space    CDATA    #FIXED \"preserve\"%coreattrs;>The pre element tells visual user agents that the enclosed text is \"preformatted\". When handlingpreformatted text, user agents:• May leave white space intact.• May render text with a fixed-pitch font.• May disable automatic word wrap.The user agent must make “best effort” to achieve the requirements above.Conformance Rules:WML-75    preO11.9  Images<!ENTITY % IAlign \"(top|middle|bottom)\" ><!ELEMENT img EMPTY><!ATTLIST imgalt        %vdata;      #REQUIREDsrc        %HREF;       #REQUIREDlocalsrc   %vdata;      #IMPLIEDvspace     %length;     \"0\"hspace     %length;     \"0\"align      %IAlign;     \"bottom\"height     %length;     #IMPLIEDwidth      %length;     #IMPLIEDxml:lang   NMTOKEN      #IMPLIED%coreattrs;>The img element indicates that an image is to be included in the text flow.  Image layout is donewithin the context of normal text layout.Attributesalt=vdataThis attribute specifies an alternative textual representation for the image.  Thisrepresentation is used when the image can not be displayed using any other method (i.e., theuser agent does not support images, or the image contents can not be found).WAP-191-WML, 19 February 2000Page 81 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedsrc=HREF This attribute specifies the URI for the image.  If the browser supports images, it downloadsthe image from the specified URI and renders it when the text is being displayed.localsrc=vdata This attribute specifies an alternative internal representation for the image.  Thisrepresentation is used if it exists; otherwise the image is downloaded from the URI specifiedin the src attribute, i.e., any localsrc parameter specified takes precedence over theimage specified in the src parameter.vspace=lengthhspace=length These attributes specify the amount of white space to be inserted to the left and right(hspace) and above and below (vspace) the image. The default value for this attribute iszero indicating that no white space should be inserted. If length is specified as apercentage value, the space inserted is based on the available horizontal or vertical space.These attributes are hints to the user agent and may be ignored.align=(top|middle|bottom) This attribute specifies image alignment within the text flow and with respect to the currentinsertion point. align has three possible values:• bottom: means that the bottom of the image should be vertically aligned with thecurrent baseline. This is the default value.• middle: means that the centre of the image should be vertically aligned with the centreof the current text line.• top: means that the top of the image should be vertically aligned with the top of thecurrent text line.height=lengthwidth=length These attributes give user agents an idea of the size of an image or object so that they mayreserve space for it and continue rendering the card while waiting for the image data. Useragents may scale objects and images to match these values if appropriate.  If length isspecified as a percentage value, the resulting size is based on the available horizontal orvertical space, not on the natural size of the image. These attributes are a hint to the useragent and may be ignored.WAP-191-WML, 19 February 2000Page 82 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttributes defined elsewhere• xml:lang(see section 8.8)• id(see section 8.9)• class(see section 8.9)Conformance Rules:WML-32    imgMWML-54    Display of alt attribute of <img>IF NOT WAE-GRIM: MWML-55    Support for vspace hintWAE-GRIM:OWML-56    Support for hspace hintWAE-GRIM:OWML-57    Support for <img> alignWAE-GRIM:OWML-58    Support for <img> heightWAE-GRIM:OWML-59    Support for <img> widthWAE-GRIM:OWAP-191-WML, 19 February 2000Page 83 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved12.  User Agent SemanticsExcept where explicitly stated WML does not dictate how a user agent should render or displayWML content.  The user agent is not obligated to perform any particular mapping of elements touser interface widgets, and the WML author should not rely on such.12.1  Deck Access ControlThe introduction of variables into WML exposes potential security issues that do not exist in othermarkup languages such as HTML. In particular, certain variable state may be considered private bythe user. While the user may be willing to send a private information to a secure service, aninsecure or malicious service should not be able to retrieve that information from the user agent byother means.A conforming WML user agent must implement deck-level access control, including the accesselement and the sendreferer, domain and path attributes.A WML author should remove private or sensitive information from the browser context byclearing the variables containing this information.Conformance Rules:WML-14    Deck access controlM12.2  Low-Memory  BehaviourWML is targeted at devices with limited hardware resources, including significant restrictions onmemory size.  It is important that the author have a clear expectation of device behaviour in errorsituations, including those caused by lack of memory.Conformance Rules:WML-15    Low-memoryO12.2.1  Limited  HistoryThe user agent may limit the size of the history stack (i.e., the depth of the historical navigationinformation). In the case of history size exhaustion, the user agent should delete the least-recently-used history information.It is recommended that all user agents implement a minimum history stack size of ten entries.WAP-191-WML, 19 February 2000Page 84 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved12.2.2  Limited Browser Context SizeIn some situations, it is possible that the author has defined an excessive number of variables in thebrowser context, leading to memory exhaustion.In this situation, the user agent should attempt to acquire additional memory by reclaiming cacheand history memory as described in sections 12.2.1.  If this fails and the user agent has exhaustedall memory, the user should be notified of the error, and the user agent should be reset to apredictable user state.  For example, the browser may be terminated or the context may be clearedand the browser reset to a well-known state.12.3  Error  HandlingConforming user agents must enforce error conditions defined in this specification and must nothide errors by attempting to infer author or origin server intent.Conformance Rules:WML-16    Error handlingM12.4  Unknown  DTDA WML deck encoded with an alternate DTD may include elements or attributes that are notrecognised by certain user agents.  In this situation, a user agent should render the deck as if theunrecognised tags and attributes were not present.  Content contained in unrecognised elementsshould be rendered.Conformance Rules:WML-17    Unknown DTD handlingM12.5  Reference Processing Behaviour - Inter-card NavigationThe following process describes the reference model for inter-card traversal in WML. All useragents must implement this process, or one that is indistinguishable from it.Conformance Rules:WML-18    Inter-card navigationMWAP-191-WML, 19 February 2000Page 85 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved12.5.1  The Go TaskThe process of executing a go task comprises the following steps:1. If the originating task contains setvar elements, the variable name and value in eachsetvar element is converted into a simple string by substituting all referenced variables.  Theresulting collection of variable names and values is stored in temporary memory for laterprocessing. See section 10.3.1 for more information on variable substitution.2. The target URI is identified and fetched by the user agent. The URI attribute value is convertedinto a simple string by substituting all referenced variables.3. The access control parameters for the fetched deck are processed as specified in section 11.3.1.4. The destination card is located using the fragment name specified in the URI.a) If no fragment name was specified as part of the URI, the first card in the deck is thedestination card.b) If a fragment name was identified and a card has a name attribute that is identical to thefragment name, then that card is the destination card.c) If the fragment name can not be associated with a specific card, the first card in the deck isthe destination card.5. The variable assignments resulting from the processing done in step #1 (the setvar element)are applied to the current browser context.6. If the destination card contains a newcontext attribute, the current browser context is re-initialised as described in section 10.2.7. The destination card is pushed onto the history stack.8. If the destination card specifies an onenterforward intrinsic event binding, the taskassociated with the event binding is executed and processing stops.  See section 9.10 for moreinformation.9. If the destination card contains a timer element, the timer is started as specified in section11.7.10. The destination card is displayed using the current variable state and processing stops.WAP-191-WML, 19 February 2000Page 86 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved12.5.2  The Prev TaskThe process of executing a prev task comprises the following steps:1. If the originating task contains setvar elements, the variable name and value in eachsetvar element is converted into a simple string by substituting all referenced variables.  Theresulting collection of variable names and values is stored in temporary memory for laterprocessing. See section 10.3.1 for more information on variable substitution.2. The target URI is identified and fetched by the user agent.   The history stack is popped and thetarget URI is the top of the history stack.  If there is no previous card in the history stack,processing stops.3. The destination card is located using the fragment name specified in the URI.a) If no fragment name was specified as part of the URI, the first card in the deck is thedestination card.b) If a fragment name was identified and a card has a name attribute that is identical to thefragment name, then that card is the destination card.4. The variable assignments resulting from the processing done in step #1 (the setvar element)are applied to the current browser context.5. If the destination card specifies an onenterbackward intrinsic event binding, the taskassociated with the event binding is executed and processing stops.  See section 9.10 for moreinformation.6. If the destination card contains a timer element, the timer is started as specified in section11.7.7. The destination card is displayed using the current variable state and processing stops.12.5.3  The Noop TaskNo processing is done for a noop task.12.5.4  The Refresh TaskThe process of executing a refresh task comprises the following steps:1. For each setvar element, the variable name and value in each setvar element is convertedinto a simple string by substituting all referenced variables. See section 10.3.1 for moreinformation on variable substitution.2. The variable assignments resulting from the processing done in step #1 (the setvar element)are applied to the current browser context.WAP-191-WML, 19 February 2000Page 87 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved3. If the card contains a timer element, the timer is started as specified in section 11.7.4. The current card is re-displayed using the current variable state and processing stops.12.5.5  Task Execution FailureIf a task fails to fetch its target URI or the access control restrictions prevent a successful inter-cardtransition, the user agent must notify the user and take the following actions:• The invoking card remains the current card.• No changes are made to the browser context, including any pending variable assignments ornewcontext processing.• No intrinsic event bindings are executed.WAP-191-WML, 19 February 2000Page 88 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved13.  WML Reference InformationWML is an application of [XML] version 1.0.13.1  Document  Identifiers13.1.1  SGML Public Identifier-//WAPFORUM//DTD WML 1.3//EN13.1.2  WML Media TypeTextual form:text/vnd.wap.wmlTokenised form:application/vnd.wap.wmlcWAP-191-WML, 19 February 2000Page 89 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved13.2  Document Type Definition (DTD)<!--Wireless Markup Language (WML) Document Type Definition.WML is an XML language.  Typical usage:<?xml version=\"1.0\"?><!DOCTYPE wml PUBLIC \"-//WAPFORUM//DTD WML 1.3//EN\"\"http://www.wapforum.org/DTD/wml13.dtd\"><wml>...</wml>--><!ENTITY % length  \"CDATA\">    <!-- [0-9]+ for pixels or [0-9]+\"%\" forpercentage length --><!ENTITY % vdata   \"CDATA\">    <!-- attribute value possibly containingvariable references --><!ENTITY % HREF    \"%vdata;\">  <!-- URI, URL or URN designating a hypertextnode. May contain variable references --><!ENTITY % boolean \"(true|false)\"><!ENTITY % number  \"NMTOKEN\">  <!-- a number, with format [0-9]+ --><!ENTITY % coreattrs  \"id    ID     #IMPLIEDclass CDATA  #IMPLIED\"><!ENTITY % ContentType \"%vdata;\">  <!-- media type. May contain variablereferences --><!ENTITY % emph    \"em | strong|b|i|u|big|small\"><!ENTITY % layout  \"br\"><!ENTITY % text     \"#PCDATA | %emph;\"><!-- flow covers \"card-level\" elements, such as text and images --><!ENTITY % flow     \"%text; | %layout; | img | anchor|a|table\"><!-- Task types --><!ENTITY % task   \"go | prev | noop | refresh\"><!-- Navigation and event elements --><!ENTITY % navelmts \"do | onevent\"><!--================ Decks and Cards ================--><!ELEMENT wml ( head?, template?, card+ )><!ATTLIST wmlxml:lang        NMTOKEN        #IMPLIED%coreattrs;><!-- card intrinsic events --><!ENTITY % cardev\"onenterforward  %HREF;          #IMPLIEDonenterbackward %HREF;          #IMPLIEDontimer         %HREF;          #IMPLIED\"><!-- card field types -->WAP-191-WML, 19 February 2000Page 90 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved<!ENTITY % fields  \"%flow; | input | select | fieldset\"><!ELEMENT card (onevent*, timer?, (do|p|pre)*)><!ATTLIST cardtitle           %vdata;       #IMPLIEDnewcontext      %boolean;     \"false\"ordered         %boolean;     \"true\"xml:lang        NMTOKEN       #IMPLIED%cardev;%coreattrs;><!--================ Event Bindings ================--><!ELEMENT do (%task;)><!ATTLIST dotype         CDATA       #REQUIREDlabel        %vdata;     #IMPLIEDname         NMTOKEN     #IMPLIEDoptional     %boolean;   \"false\"xml:lang     NMTOKEN     #IMPLIED%coreattrs;><!ELEMENT onevent (%task;)><!ATTLIST oneventtype         CDATA       #REQUIRED%coreattrs;><!--================ Deck-level declarations ================--><!ELEMENT head ( access | meta )+><!ATTLIST head%coreattrs;><!ELEMENT template (%navelmts;)*><!ATTLIST template%cardev;%coreattrs;><!ELEMENT access EMPTY><!ATTLIST accessdomain       CDATA       #IMPLIEDpath         CDATA       #IMPLIED%coreattrs;><!ELEMENT meta EMPTY><!ATTLIST metahttp-equiv     CDATA      #IMPLIEDname           CDATA      #IMPLIEDforua          %boolean;  \"false\"content        CDATA      #REQUIREDscheme         CDATA      #IMPLIEDWAP-191-WML, 19 February 2000Page 91 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved%coreattrs;><!--================ Tasks ================--><!ENTITY % cache-control “(no-cache)” ><ELEMENT go (postfield | setvar)*><!ATTLIST gohref            %HREF;          #REQUIREDsendreferer     %boolean;       \"false\"method          (post|get)      \"get\"enctype         %ContentType;\"application/x-www-form-urlencoded\"cache-control   %cache-control; #IMPLIEDaccept-charset  CDATA           #IMPLIED%coreattrs;><!ELEMENT prev (setvar)*><!ATTLIST prev%coreattrs;><!ELEMENT refresh (setvar)*><!ATTLIST refresh%coreattrs;><!ELEMENT noop EMPTY><!ATTLIST noop%coreattrs;><!--================ postfield ================--><!ELEMENT postfield EMPTY><!ATTLIST postfieldname         %vdata;           #REQUIREDvalue        %vdata;           #REQUIRED%coreattrs;><!--================ variables ================--><!ELEMENT setvar EMPTY><!ATTLIST setvarname         %vdata;           #REQUIREDvalue        %vdata;           #REQUIRED%coreattrs;><!--================ Card Fields ================--><!ELEMENT select (optgroup|option)+><!ATTLIST selecttitle        %vdata;           #IMPLIEDname         NMTOKEN           #IMPLIEDWAP-191-WML, 19 February 2000Page 92 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedvalue        %vdata;           #IMPLIEDiname        NMTOKEN           #IMPLIEDivalue       %vdata;           #IMPLIEDmultiple     %boolean;         \"false\"tabindex     %number;          #IMPLIEDxml:lang     NMTOKEN           #IMPLIED%coreattrs;><!ELEMENT optgroup (optgroup|option)+ ><!ATTLIST optgrouptitle      %vdata;    #IMPLIEDxml:lang   NMTOKEN    #IMPLIED%coreattrs;><!ELEMENT option (#PCDATA | onevent)*><!ATTLIST optionvalue      %vdata;    #IMPLIEDtitle      %vdata;    #IMPLIEDonpick     %HREF;     #IMPLIEDxml:lang   NMTOKEN    #IMPLIED%coreattrs;><!ELEMENT input EMPTY><!ATTLIST inputname       NMTOKEN           #REQUIREDtype       (text|password)   \"text\"value      %vdata;           #IMPLIEDformat     CDATA             #IMPLIEDemptyok    %boolean;         #IMPLIEDsize       %number;          #IMPLIEDmaxlength  %number;          #IMPLIEDtabindex   %number;          #IMPLIEDtitle      %vdata;           #IMPLIEDaccesskey  %vdata;           #IMPLIEDxml:lang   NMTOKEN           #IMPLIED%coreattrs;><!ELEMENT fieldset (%fields; | do)* ><!ATTLIST fieldsettitle           %vdata;      #IMPLIEDxml:lang        NMTOKEN      #IMPLIED%coreattrs;><!ELEMENT timer EMPTY><!ATTLIST timername       NMTOKEN           #IMPLIEDvalue      %vdata;           #REQUIRED%coreattrs;><!--================ Images ================-->WAP-191-WML, 19 February 2000Page 93 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved<!ENTITY % IAlign \"(top|middle|bottom)\" ><!ELEMENT img EMPTY><!ATTLIST imgalt        %vdata;      #REQUIREDsrc        %HREF;       #REQUIREDlocalsrc   %vdata;      #IMPLIEDvspace     %length;     \"0\"hspace     %length;     \"0\"align      %IAlign;     \"bottom\"height     %length;     #IMPLIEDwidth      %length;     #IMPLIEDxml:lang   NMTOKEN      #IMPLIED%coreattrs;><!--================ Anchor ================--><!ELEMENT anchor ( #PCDATA | br | img | go | prev | refresh )*><!ATTLIST anchortitle        %vdata;      #IMPLIEDaccesskey    %vdata;      #IMPLIEDxml:lang     NMTOKEN      #IMPLIED%coreattrs;><!ELEMENT a ( #PCDATA | br | img )*><!ATTLIST ahref         %HREF;       #REQUIREDtitle        %vdata;      #IMPLIEDaccesskey    %vdata;      #IMPLIEDxml:lang     NMTOKEN      #IMPLIED%coreattrs;><!--================ Tables ================--><!ELEMENT table (tr)+><!ATTLIST tabletitle       %vdata;    #IMPLIEDalign       CDATA      #IMPLIEDcolumns     %number;   #REQUIREDxml:lang    NMTOKEN    #IMPLIED%coreattrs;><!ELEMENT tr (td)+><!ATTLIST tr%coreattrs;><!ELEMENT td ( %text; | %layout; | img | anchor|a)*><!ATTLIST tdxml:lang        NMTOKEN       #IMPLIED%coreattrs;>WAP-191-WML, 19 February 2000Page 94 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved<!--=============== Text layout and line breaks ===============--><!ELEMENT em     (%flow;)*><!ATTLIST emxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT strong (%flow;)*><!ATTLIST strongxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT b      (%flow;)*><!ATTLIST bxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT i      (%flow;)*><!ATTLIST ixml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT u      (%flow;)*><!ATTLIST uxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT big    (%flow;)*><!ATTLIST bigxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ELEMENT small  (%flow;)*><!ATTLIST smallxml:lang        NMTOKEN       #IMPLIED%coreattrs;><!ENTITY % TAlign \"(left|right|center)\"><!ENTITY % WrapMode \"(wrap|nowrap)\" ><!ELEMENT p (%fields; | do)*><!ATTLIST palign       %TAlign;     \"left\"mode        %WrapMode;   #IMPLIEDxml:lang    NMTOKEN      #IMPLIED%coreattrs;><!ELEMENT br EMPTY><!ATTLIST br%coreattrs;WAP-191-WML, 19 February 2000Page 95 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved><!ELEMENT pre \"(#PCDATA|a|anchor | do|u|br|i|b|em|strong | input | select )*\"><!ATTLIST prexml:space    CDATA    #FIXED \"preserve\"%coreattrs;><!ENTITY quot  \"&#34;\">     <!-- quotation mark --><!ENTITY amp   \"&#38;#38;\"> <!-- ampersand --><!ENTITY apos  \"&#39;\">     <!-- apostrophe --><!ENTITY lt    \"&#38;#60;\"> <!-- less than --><!ENTITY gt    \"&#62;\">     <!-- greater than --><!ENTITY nbsp  \"&#160;\">    <!-- non-breaking space --><!ENTITY shy   \"&#173;\">    <!-- soft hyphen (discretionary hyphen) -->13.3  Reserved  WordsWML reserves the use of several strings for future uses.  These strings may not be used in any DTDor extension of WML.  The following words are reserved:styleWAP-191-WML, 19 February 2000Page 96 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved14.  A Compact Binary Representation of WMLWML may be encoded using a compact binary representation. This content format is based uponthe WAP Binary XML Content Format [WBXML].Conformance Rules:WML-60    WML token tableM14.1  Extension  Tokens14.1.1  Global Extension TokensThe [WBXML] global extension tokens are used to represent WML variables. Variable referencesmay occur in a variety of places in a WML deck (see section 10.3). There are several codes thatindicate variable substitution.  Each code has different escaping semantics (e.g., direct substitution,escaped substitution and unescaped substitution).  The variable name is encoded in the currentdocument character encoding and must be encoded as the specified in the source document (e.g.,variable names may not be shortened, mapped or otherwise changed).  For example, the globalextension token EXT_I_0 represents an escaped variable substitution, with the variable nameinline.14.1.2  Tag  TokensWML defines a set of single-byte tokens corresponding to the tags defined in the DTD.  All ofthese tokens are defined within code page zero.14.1.3  Attribute  TokensWML defines a set of single-byte tokens corresponding to the attribute names and values defined inthe DTD.  All of these tokens are defined within code page zero.14.2  Encoding  Semantics14.2.1  Encoding  VariablesAll valid variable references must be converted to variable reference tokens (e.g., EXT_I_0).  Theencoder must validate that a variable reference uses proper syntax.  The encoder should alsovalidate that the placement of the variable reference within the WML deck is valid.WAP-191-WML, 19 February 2000Page 97 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved14.2.2  Encoding Tag and Attributes NamesAll tag and attribute names, for which binary token values are defined in this specification, must betokenised, literal tokens must not be used. The user-agent must, however, treat literal and binarytokens as equivalent. See [WBXML].Conformance Rules:WML-61    XML Well-formedMWML-62    XML ValidationO14.2.3  Document  ValidationXML document validation (see [XML]) should occur during the process of tokenising a WML deckand must be based on the DOCTYPE declared in the WML deck.  When validating the source text,the tokenisation process must accept any DOCTYPE or public identifier, if the document isidentified as a WML media type (see section 13.1.2).The tokenisation process should notify the user of any well-formedness or validity errors detectedin the source deck.14.2.3.1 Validate %length;The WML tokenisation process should validate that attribute values defined as %length; containeither a NMTOKEN or a NMTOKEN followed by a percentage sign character.  For example, thefollowing attributes are legal:vspace=\"100%\"hspace=\"123\"%length; data is encoded using normal attribute value encoding methods.14.2.3.2 Validate %vdata;The WML tokenisation process must validate the syntax of all variable references within attributevalues defined as %vdata; or %HREF; according to section 10.3.5.  It must also verify that otherCDATA attribute values do not contain any variable references.  Attribute values not defined in theDTD must be treated as %vdata; and validated accordingly.WAP-191-WML, 19 February 2000Page 98 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved14.3  Numeric  Constants14.3.1  WML Extension Token AssignmentThe following global extension tokens are used in WML and occupy document-type-specific tokenslots in the global token range.  As with all tokens in the global range, these codes must be reservedin every code page.  All numbers are in hexadecimal.Table 4. Global extension token assignmentsToken NameTokenDescriptionEXT_I_040Variable substitution - escaped.  Name of the variableis inline and follows the token as a termstr.EXT_I_141Variable substitution - unescaped.  Name of thevariable is inline and follows the token as atermstr.EXT_I_242Variable substitution - no transformation.  Name ofthe variable is inline and follows the token as atermstr.EXT_T_080Variable substitution - escaped.  Variable nameencoded as a reference into the string table.EXT_T_181Variable substitution - unescaped.  Variable nameencoded as a reference into the string table.EXT_T_282Variable substitution - no transformation.  Variablename encoded as a reference into the string table.EXT_0C0Reserved for future use.EXT_1C1Reserved for future use.EXT_2C2Reserved for future use.14.3.2  Tag  TokensThe following token codes represent tags in code page zero (0).   All numbers are in hexadecimal.Table 5. Tag tokensWAP-191-WML, 19 February 2000Page 99 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedTag NameTokena1Canchor22access23b24big25br26card27do28em29fieldset2Ago2Bhead2Ci2Dimg2Einput2Fmeta30noop31p20Tag NameTokenpostfield21pre1Bprev32onevent33optgroup34option35refresh36select37setvar3Esmall38strong39table1Ftd1Dtemplate3Btimer3Ctr1Eu3Dwml3F14.3.3  Attribute Start TokensThe following token codes represent the start of an attribute in code page zero (0).  All numbers arein hexadecimal.Table 6. Attribute start tokensAttribute NameAttribute ValuePrefixTokenAttribute NameAttribute ValuePrefixTokenWAP-191-WML, 19 February 2000Page 100 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttribute NameAttribute ValuePrefixTokenaccept-charset5accesskey5Ealign52alignbottom6aligncenter7alignleft8alignmiddle9alignrightAaligntopBaltCcache-controlno-cache64class54columns53contentDcontentapplication/vnd.wap.wmlc;charset=5CdomainFemptyokfalse10emptyoktrue11enctype5Fenctypeapplication/x-www-form-urlencoded60enctypemultipart/for61Attribute NameAttribute ValuePrefixTokenm-dataformat12foruafalse56foruatrue57height13href4Ahrefhttp://4Bhrefhttps://4Chspace14http-equiv5Ahttp-equivContent-Type5Bhttp-equivExpires5Did55ivalue15iname16label18localsrc19maxlength1Amethodget1Bmethodpost1Cmodenowrap1Dmodewrap1Emultiplefalse1FWAP-191-WML, 19 February 2000Page 101 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedAttribute NameAttribute ValuePrefixTokenmultipletrue20name21newcontextfalse22newcontexttrue23onenterbackward25onenterforward26onpick24ontimer27optionalfalse28optionaltrue29path2Ascheme2Esendrefererfalse2Fsendreferertrue30size31src32srchttp://58srchttps://59orderedtrue33orderedfalse34tabindex35title36Attribute NameAttribute ValuePrefixTokentype37typeaccept38typedelete39typehelp3Atypepassword3Btypeonpick3Ctypeonenterbackward3Dtypeonenterforward3Etypeontimer3Ftypeoptions45typeprev46typereset47typetext48typevnd.49value4Dvspace4Ewidth4Fxml:lang50xml:spacepreserve62xml:spacedefault63WAP-191-WML, 19 February 2000Page 102 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved14.3.4  Attribute Value TokensThe following token codes represent attribute values in code page zero (0). All numbers are inhexadecimal.Table 7. Attribute value tokensAttribute ValueToken.com/85.edu/86.net/87.org/88accept89bottom8Aclear8Bdelete8Chelp8Dhttp://8Ehttp://www.8Fhttps://90https://www.91middle93Attribute ValueTokennowrap94onenterbackward96onenterforward97onpick95ontimer98options99password9Areset9Btext9Dtop9Eunknown9FwrapA0Www.A1WAP-191-WML, 19 February 2000Page 103 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved14.4  WML Encoding ExamplesRefer to [WBXML] for additional examples.The following is another example of a tokenised WML deck.  It demonstrates variable encoding,attribute encoding and the use of the string table.  Source deck:<wml><card id=\"abc\" ordered=\"true\"><p><do type=\"accept\"><go href=\"http://xyz.org/s\"/></do>X: $(X)<br/>Y: $(&#x59;)<br/>Enter name: <input type=\"text\" name=\"N\"/></p></card></wml>Tokenised form (numbers in hexadecimal) follows.  This example only uses inline strings andassumes that the character encoding uses a NULL terminated string format.  It also assumes that thecharacter encoding is UTF-8:02  08  6A  04  'X' 00  'Y' 00  7F  E7  55  03  'a' 'b' 'c' 0033  01  60  E8  38  01  AB  4B  03  'x' 'y' 'z' 00  88  03's'00 01 01 03 '''X'':'''00 82 00 26 03 '''Y'':'''00 82 02 26 03 '''E''n''t''e''r''''n''a''m''e'':'''00 AF 48 21 03 'N'00 01 01 01 01In an expanded and annotated form:Table 8. Example tokenised deckToken StreamDescription02WBXML Version number 1.208WML 1.2 Public ID6ACharset=UTF-8 (MIBEnum 106)04String table length'X', 00, 'Y', 00String table7Fwml, with contentWAP-191-WML, 19 February 2000Page 104 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedToken StreamDescriptionE7card, with content and attributes55                                 id=03Inline string follows'a', 'b', 'c', 00string33                                 ordered=\"true\"01END (of card attribute list)60                                 pE8do, with content and attributes38                                 type=accept01END (of do attribute list)ABgo, with attributes4Bhref=\"http://\"03Inline string follows'x', 'y', 'z', 00string88                                 \".org/\"03Inline string follows's', 00string01END (of go element)01END (of do element)03Inline string follows' ', 'X', ':', ' ', 00String82Direct variable reference (EXT_T_2)00Variable offset 0WAP-191-WML, 19 February 2000Page 105 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedToken StreamDescription26                                 br03Inline string follows' ', 'Y', ':', ' ', 00String82Direct variable reference (EXT_T_2)02Variable offset 226                                 br03Inline string follows' ', 'E', 'n', 't', 'e', 'r', '', 'n', 'a', 'm', 'e', ':', ' ',00StringAFinput, with attributes48                                 type=\"text\"21                                 name=03Inline string follows'N', 00String01END (of input attribute list)01END (of p element)01END (of card element)01END (of wml element)WAP-191-WML, 19 February 2000Page 106 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved15.  Static Conformance StatementThis section defines the static conformance requirements for the WML user agent, documents, andencoder.15.1  WML User Agent15.1.1  Character Set and EncodingItemFunctionReferenceMandatory/OptionalWML-01UTF-8 Encoding6OWML-02UTF-16 Encoding6OWML-03UCS-4 Encoding6OWML-04Other characterencoding6OWML-05Reference processing6.1MWML-06Character entities6.2M15.1.2  Events and NavigationItemFunctionReferenceMandatory/OptionalWML-07History9.2MWML-08Card/Deck taskShadowing9.6MWML-09Intrinsic Events9.10M15.1.3  State  ModelItemFunctionReferenceMandatory/OptionalWML-10Browser context10.1MWML-11Initialisation(newcontext)10.2MWML-12Variables10.3MWML-13Context restrictions10.4MWAP-191-WML, 19 February 2000Page 107 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved15.1.4  User Agent SemanticsItemFunctionReferenceMandatory/OptionalWML-14Deck access control12.1MWML-15Low-memorybehaviour12.2OWML-16Error handling12.3MWML-17Unknown DTDhandling12.4MWML-18Inter-card navigation12.5M15.1.5  ElementsIf a user agent does not support an optional element, it should continue to process the children ofthe element. The children of an element include all elements and character data.ItemElementReferenceMandatory/OptionalWML-19a9.9MWML-20anchor9.8MWML-21access11.3.1MWML-22b11.8.2OWML-23big11.8.2OWML-24br11.8.4MWML-25card11.5MWML-26do9.7MWML-27em11.8.2OWML-28fieldset11.6.4OWML-29go9.5.1MWML-30head11.3MWML-31i11.8.2OWML-32img11.9MWML-33input11.6.3MWML-34meta11.3.2OWML-35noop9.5.4MWML-36p11.8.3MWML-37postfield9.3MWML-75pre11.8.9OWAP-191-WML, 19 February 2000Page 108 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedItemElementReferenceMandatory/OptionalWML-38prev9.5.2MWML-39onevent9.10.1MWML-40optgroup11.6.2.3OWML-41option11.6.2.2MWML-42refresh9.5.3MWML-43select11.6.2.1MWML-44small11.8.2OWML-45strong11.8.2OWML-46table11.8.5MWML-47template11.4MWML-48timer11.7MWML-49td11.8.7MWML-50tr11.8.6MWML-51u11.8.2OWML-52setvar9.4MWML-53wml11.2M15.1.6  Image  SupportItemFunctionReferenceMandatory/OptionalWML-54Display of alt attributeof <img>11.9IF NOT WAE-GRIM: MWML-55Support for vspace hint11.9WAE-GRIM:OWML-56Support for hspace hint11.9WAE-GRIM:OWML-57Support for <img>align11.9WAE-GRIM:OWML-58Support for <img>height11.9WAE-GRIM:OWML-59Support for <img>width11.9WAE-GRIM:OWAP-191-WML, 19 February 2000Page 109 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reserved15.2  WML  Encoder15.2.1  Token  TableItemFunctionReferenceMandatory/OptionalWML-60WML token table14M15.2.2  ValidationItemFunctionReferenceMandatory/OptionalWML-61XML Well-formed14.2.2MWML-62XML Validation14.2.2OWML-63WML Validation15.3O15.3  WML Document - ServerItemFunctionReferenceMandatory/OptionalWML-64Variable referencesmay only occur invdata attribute values7.5MWML-65Variable referencesmust match theproduction rule var10.3.1MWML-66Two or more doelements with the samename must not bepresent in a single cardor in the templateelement. (Note: Anunspecified namedefaults to the value ofthe type attribute.)9.7MWML-67A meta element mustnot contain more thanone attribute of nameand http-equiv11.3.2MWAP-191-WML, 19 February 2000Page 110 (110)  Copyright Wireless Application Protocol Forum,Ltd, 1998, 1999, 2000.All rights reservedItemFunctionReferenceMandatory/OptionalWML-68The number of columnsin a table must not beset to zero11.8.5MWML-69Event bindings mustnot conflict9.10M15.4  WML Document – ClientItemFunctionReferenceMandatory/OptionalWML-70Variable referencesmust match theproduction rule var10.3.1OWML-71Two or more doelement with the samename must not bepresent in a single cardor in the templateelement. (Note: Anunspecified namedefaults to the value ofthe type attribute.)9.7OWML-72A meta element mustnot contain more thanone attribute of nameand http-equiv11.3.2OWML-73The number of columnsin a table must not beset to zero11.8.5OWML-74Event bindings mustnot conflict9.10O"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-191_102-WML-20001213-a.pdf","file":"WAP-191_102-WML-20001213-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"This document provides changes and corrections to the following document files:-     WAP-191-WML-2000-02-19-aIt includes changes from the following change requests:Change RequestTitleCommentsWAEALL13-IBM-20001107-HTTPrefHTTP Normative Reference•      Updates the WAE 1.x suite torefer to RFC2616 instead ofRFC2068.2. NotationIn the subsections describing the changes new text is underlined. Removed text has strikethrough marks. The presentedtext is copied from the specification. Text that is not presented is not affected at all. The change descriptions may alsoinclude editor’s notes similar to the one below. The notes are not part of the actual changes and must not be included inthe changed text.Editor's note: Framed notes like these only clarify where and how the changes shall be applied."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-191_104-WML-20010718-a.pdf","file":"WAP-191_104-WML-20010718-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-wide specification for developing applications that operate over wireless communication networks.  The scope for the WAP Forum is to define a set of specifications to be used by service applications.  The wireless market is growing very quickly and reaching new customers and services.  To enable operators and manufacturers to meet the challenges in advanced services, differentiation, and fast/flexible service creation, WAP defines a set of protocols in transport, session, and application layers.  For additional information on the WAP architecture, refer to \"Wireless Application Protocol Architecture Specification\" [WAP]. This specification defines the Wireless Markup Language (WML).  WML is a markup language based on [XML] and is intended for use in specifying content and user interface for narrowband devices, including cellular phones and pagers. WML is designed with the constraints of small narrowband devices in mind.  These constraints include: • Small display and limited user input facilities • Narrowband network connection • Limited memory and computational resources WML includes four major functional areas: • Text presentation and layout - WML includes text and image support, including a variety of formatting and layout commands.  For example, boldfaced text may be specified. • Deck/card organisational metaphor - all information in WML is organised into a collection of cards and decks.  Cards specify one or more units of user interaction (e.g., a choice menu, a screen of text or a text entry field).   Logically, a user navigates through a series of WML cards, reviews the contents of each, enters requested information, makes choices and moves on to another card. Cards are grouped together into decks.  A WML deck is similar to an HTML page, in that it is identified by a URL [RFC2396] and is the unit of content transmission. • Inter-card navigation and linking - WML includes support for explicitly managing the navigation between cards and decks.  WML also includes provisions for event handling in the device, which may be used for navigational purposes or to execute scripts.  WML also supports anchored links, similar to those found in [HTML4]. • String parameterisation and state management - all WML decks can be parameterised using a state model.  Variables can be used in the place of strings and are substituted at run-time.  This parameterisation allows for efficient use of network resources.          WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 8 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved2. Document Status You may use this document or any part of the document for internal or educational purposes only, provided you do not modify, edit or take out of context the information in this document in any manner. You may not use this document in any other manner without the prior written permission of the WAP Forum™. The WAP Forum authorises you to copy this document, provided that you retain all copyright and other proprietary notices contained in the original materials on any copies of the materials and that you comply strictly with these terms. This copyright permission does not constitute an endorsement of the products or services offered by you. The WAP Forum™ assumes no responsibility for errors or omissions in this document. In no event shall the WAP Forum be liable for any special, indirect or consequential damages or any damages whatsoever arising out of or in connection with the use of this information. WAP Forum™ members have agreed to use reasonable endeavors to disclose in a timely manner to the WAP Forum the existence of all intellectual property rights (IPR's) essential to the present document. The members do not have an obligation to conduct IPR searches. This information is publicly available to members and non-members of the WAP Forum and may be found on the \"WAP IPR Declarations\" list at http://www.wapforum.org/what/ipr.htm. Essential IPR is available for license on the basis set out in the schedule to the WAP Forum Application Form. No representations or warranties (whether express or implied) are made by the WAP Forum™ or any WAP Forum member or its affiliates regarding any of the IPR's represented on this list, including but not limited to the accuracy, completeness, validity or relevance of the information or whether or not such rights are essential or non-essential. 2.1 Copyright Notice © Copyright Wireless Application Forum Ltd, 1998, 1999, 2000. Terms and conditions of use are available from the Wireless Application Protocol Forum Ltd. web site at http://www.wapforum.org/docs/copyright.htm. 2.2 Errata Known problems associated with this document are published at http://www.wapforum.org. 2.3 Comments Comments regarding this document can be submitted to the WAP Forum in the manner published at http://www.wapforum.org. 2.4 Document History Document: Wireless Markup Language (WML) Current: WAP-191, WAP-191.104 Revision History: Approval Date Document Identifier 30 Apr 1998 WAP-106 (WML 1.0) 16 Jun 1999 WAP-136 (WML 1.1) 4 Nov 1999 WAP-155 (WML 1.2) TBD WAP-191, WAP-191.101 WAP-191.102, WAP-191.104  (WML 1.3)   WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 9 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved3. References 3.1 Normative References [CACHE] \"WAP Caching Model Specification\", WAP Forum, 11-Febuary-1999. URL: http://www.wapforum.org/ [ISO10646] \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane\", ISO/IEC 10646-1:1993. [RFC1766] \"Tags for the Identification of Languages\", H. Alvestrand, March 1995. URL: http://www.ietf.org/rfc/rfc1766.txt [RFC2045] \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", N. Freed, et al., November 1996. URL: http://www.ietf.org/rfc/rfc2045.txt [RFC2047] \"MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text\", K. Moore, November 1996. URL: http://www.ietf.org/rfc/rfc2047.txt [RFC2048] \"Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures\", N. Freed, et al., November 1996. URL: http://www.ietf.org/rfc/rfc2048.txt [RFC2068616] \"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, et al., January 19979. URL: http://www.ietf.org/rfc/rfc2068616.txt [RFC2119] \"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March 1997. URL: http://www.ietf.org/rfc/rfc2119.txt [RFC2388] \"Returning Values from Forms: multipart/form-data\" L. Masinter.August 1998. URL: http://www.ietf.org/rfc/rfc2388.txt [RFC2396] \"Uniform Resource Identifiers (URI): Generic Syntax\", T. Berners-Lee, et al., August 1998. URL: http://www.ietf.org/rfc/rfc2396.txt [UNICODE] \"The Unicode Standard: Version 2.0\", The Unicode Consortium, Addison-Wesley Developers Press, 1996. URL: http://www.unicode.org/ [WAE] \"Wireless Application Environment Specification\", WAP Forum, 4-November-1999. URL: http://www.wapforum.org/ [WAP] \"Wireless Application Protocol Architecture Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WBXML] \"Binary XML Content Format Specification\", WAP Forum, 4-November-1999. URL: http://www.wapforum.org/ [WSP] \"Wireless Session Protocol\", WAP Forum, 5-November-1999. URL: http://www.wapforum.org/ [XML] \"Extensible Markup Language (XML), W3C Proposed Recommendation 10-February-1998, REC-xml-19980210\", T. Bray, et al, February 10, 1998. URL: http://www.w3.org/TR/REC-xml WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 10 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved3.2 Informative References [HDML2] \"Handheld Device Markup Language Specification\", P. King, et al., April 11, 1997.   URL: http://www.uplanet.com/pub/hdml_w3c/hdml20-1.html [HTML4] \"HTML 4.0 Specification, W3C Recommendation 18-December-1997, REC-HTML40-971218\", D. Raggett, et al., September 17, 1997.  URL: http://www.w3.org/TR/REC-html40 [ISO8879] \"Information Processing - Text and Office Systems - Standard Generalised Markup Language (SGML)\", ISO 8879:1986. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 11 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved4. Definitions and Abbreviations 4.1 Definitions The following are terms and conventions used throughout this specification. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",  \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\" and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].  In the absence of any such terms, the specification is to be interpreted as “MUST”. Author - an author is a person or program that writes or generates WML, WMLScript or other content. Card - a single WML unit of navigation and user interface.  May contain information to present to the user, instructions for gathering user input, etc. Character Encoding – when used as a verb, character encoding refers to conversion between sequence of characters and a sequence of bytes.  When used as a noun, character encoding refers to a method for converting a sequence of bytes to a sequence of characters.  Typically, WML document character encoding is captured in transport headers attributes (e.g., Content-Type’s “charset” parameter) or the XML declaration defined by [XML]. Client - a device (or application) that initiates a request for connection with a server. Content - subject matter (data) stored or generated at an origin server.  Content is typically displayed or interpreted by a user agent in response to a user request. Content Encoding - when used as a verb, content encoding indicates the act of converting content from one format to another.  Typically the resulting format requires less physical space than the original, is easier to process or store, and/or is encrypted.  When used as a noun, content encoding specifies a particular format or encoding standard or process. Content Format - actual representation of content. Deck - a collection of WML cards.  A WML deck is also an XML document. Device - a network entity that is capable of sending and receiving packets of information and has a unique device address.  A device can act as both a client and a server within a given context or across multiple contexts.  For example, a device can service a number of clients (as a server) while being a client to another server. JavaScript - a de facto standard language that can be used to add dynamic behaviour to HTML documents.  JavaScript is one of the originating technologies of ECMAScript. Man-Machine Interface - a synonym for user interface. Origin Server - the server on which a given resource resides or is to be created.  Often referred to as a web server or an HTTP server. Resource - a network data object or service that can be identified by a URL.  Resources may be available in multiple representations (e.g., multiple languages, data formats, size and resolutions) or vary in other ways. Server - a device (or application) that passively waits for connection requests from one or more clients.  A server may accept or reject a connection request from a client. SGML - the Standardised Generalised Markup Language (defined in [ISO8879]) is a general-purpose language for domain-specific markup languages. Terminal - a device providing the user with user agent capabilities, including the ability to request and receive information.  Also called a mobile terminal or mobile station. Transcode - the act of converting from one character set to another, e.g., conversion from UCS-2 to UTF-8. User - a user is a person who interacts with a user agent to view, hear or otherwise use a resource. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 12 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedUser Agent - a user agent is any software or device that interprets WML, WMLScript, WTAI or other resources.  This may include textual browsers, voice browsers, search engines, etc. WMLScript - a scripting language used to program the mobile device. WMLScript is an extended subset of the JavaScript scripting language. XML - the Extensible Markup Language is a World Wide Web Consortium (W3C) standard for Internet markup languages, of which WML is one such language.  XML is a restricted subset of SGML. 4.2 Abbreviations For the purposes of this specification, the following abbreviations apply. BNF Backus-Naur Form HDML Handheld Markup Language [HDML2] HTML HyperText Markup Language [HTML4] HTTP HyperText Transfer Protocol [RFC2068616] IANA Internet Assigned Number Authority MMI Man-Machine Interface PDA Personal Digital Assistant RFC Request For Comments SGML Standardised Generalised Markup Language [ISO8879] UI User Interface URL Uniform Resource Locator [RFC2396]  URN Uniform Resource Name W3C World Wide Web Consortium WAE Wireless Application Environment [WAE] WAP Wireless Application Protocol [WAP] WSP Wireless Session Protocol [WSP] XML Extensible Markup Language [XML] 4.3 Device Types WML is designed to meet the constraints of a wide range of small, narrowband devices.  These devices are primarily characterised in four ways: • Display size - smaller screen size and resolution.  A small mobile device such as a phone may only have a few lines of textual display, each line containing 8-12 characters. • Input devices - a limited, or special-purpose input device.  A phone typically has a numeric keypad and a few additional function-specific keys.  A more sophisticated device may have software-programmable buttons, but may not have a mouse or other pointing device. • Computational resources - low power CPU and small memory size; often limited by power constraints. • Narrowband network connectivity - low bandwidth and high latency.  Devices with 300bps to 10kbps network connections and 5-10 second round-trip latency are not uncommon. This document uses the following terms to define broad classes of device functionality: • Phone - the typical display size ranges from two to ten lines.  Input is usually accomplished with a combination of a numeric keypad and a few additional function keys.  Computational resources and network throughput is typically limited, especially when compared with more general-purpose computer equipment. • PDA - a Personal Digital Assistant is a device with a broader range of capabilities.  When used in this document, it specifically refers to devices with additional display and input characteristics.  A PDA display often supports resolution in the range of 160x100 pixels.  A PDA may support a pointing device, handwriting recognition and a variety of other advanced features. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 13 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedThese terms are meant to define very broad descriptive guidelines and to clarify certain examples in the document. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 14 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved5. WML and URLs The World Wide Web is a network of information and devices.  Three areas of specification ensure widespread interoperability: • A unified naming model.  Naming is implemented with Uniform Resource Locators (URLs), which provide standard way to name any network resource.  See [RFC2396]. • Standard protocols to transport information (e.g., HTTP). • Standard content types (e.g., HTML, WML). WML assumes the same reference architecture as HTML and the World Wide Web.  Content is named using URLs and is fetched over standard protocols that have HTTP semantics, such as [WSP].  URLs are defined in [RFC2396].  The character set used to specify URLs is also defined in [RFC2396]. In WML, URLs are used in the following situations: • When specifying navigation, e.g., hyperlinking. • When specifying external resources, e.g., an image or a script. 5.1 URL Schemes WML browsers must implement the URL schemes specified in [WAE]. 5.2 Fragment Anchors WML has adopted the HTML de facto standard of naming locations within a resource.  A WML fragment anchor is specified by the document URL, followed by a hash mark (#), followed by a fragment identifier.  WML uses fragment anchors to identify individual WML cards within a WML deck.  If no fragment is specified, a URL names an entire deck.  In some contexts, the deck URL also implicitly identifies the first card in a deck. 5.3 Relative URLs WML has adopted the use of relative URLs, as specified in [RFC2396]. [RFC2396] specifies the method used to resolve relative URLs in the context of a WML deck.  The base URL of a WML deck is the URL that identifies the deck. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 15 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved6. WML Character Set WML is an XML language and inherits the XML document character set.  In SGML nomenclature, a document character set is the set of all logical characters that a document type may contain (e.g., the letter 'T' and a fixed integer identifying that letter).  An SGML or XML document is simply a sequence of these integer tokens, which taken together form a document. The document character set for XML and WML is the Universal Character Set of ISO/IEC-10646 ([ISO10646]).  Currently, this character set is identical to Unicode 2.0 [UNICODE]. WML will adopt future changes and enhancements to the [XML] and [ISO10646] specifications.  Within this document, the terms ISO10646 and Unicode are used interchangeably and indicate the same document character set. There is no requirement that WML decks be encoded using the full Unicode encoding (e.g., UCS-4).  Any character encoding (\"charset\") that contains a proper subset of the logical characters in Unicode may be used (e.g., US-ASCII, ISO-8859-1, UTF-8, Shift_JIS, etc.).  Documents not encoded using UTF-8 or UTF-16 must declare their encoding as specified in the XML specification. Conformance Rules: WML-C-01  UTF-8 Encoding O WML-C-02  UTF-16 Encoding O WML-C-03  UCS-4 Encoding O WML-C-04 Other character encoding O 6.1 Reference Processing Model WML documents maybe encoded with any character encoding as defined by [HTML4].  Character encoding of a WML document may be converted to another encoding (or transcoded) to better meet the user agent’s characteristics.  However, transcoding can lead to loss of information and must be avoided when the user agent supports the document’s original encoding.  Unnecessary transcoding must be avoided when information loss will result.  If required, transcoding should be done before the document is delivered to the user agent. This specification does not mandate which character encoding a user agent must support. Since WML is an XML application, the character encoding of a WML document is determined as defined in the XML specification [XML]. In normal cases it is always possible to detect the character encoding of the document (all other cases are error situations). The meta http-equiv statement, if any is present in the document, is never used to determine the character encoding.  If a WML document is transformed into a different format than XML - for example, into the binary WBXML format - then, the rules relevant for that format are used to determine the character encoding. When an WML document is accompanied by external information (e.g. HTTP or MIME) there may be multiple sources of information available to determine the character encoding. In this case, their relative priority and the preferred method of handling conflict should be specified as part of the higher-level protocol. See, for example, the documentation of the \"text/vnd.wap.wml\" and \"application/vnd.wap.wmlc\" MIME media types. The WML reference-processing model is as follows.  User agents must implement this processing model, or a model that is indistinguishable from it. • User agents must correctly map to Unicode all characters in any character encoding that they recognise, or they must behave as if they did. • Any processing of entities is done in the document character set. A given implementation may choose any internal representation (or representations) that is convenient. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 16 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedConformance Rules: WML-C-05  Reference processing M 6.2 Character Entities A given character encoding may not be able to express all characters of the document character set.  For such encoding, or when the device characteristics do not allow users to input some document characters directly, authors and users may use character entities (i.e., [XML] character references).  Character entities are a character encoding-independent mechanism for entering any character from the document character set. WML supports both named and numeric character entities.  An important consequence of the reference processing model is that all numeric character entities are referenced with respect to the document character set (Unicode) and not to the current document encoding (charset). This means that &#302; always refers to the same logical character, independent of the current character encoding. WML supports the following character entity formats: • Named character entities, such as &amp; and &lt; • Decimal numeric character entities, such as &#32; • Hexadecimal numeric character entities, such as &#x20; Seven named character entities are particularly important in the processing of WML: <!ENTITY quot  \"&#34;\">     <!-- quotation mark --> <!ENTITY amp   \"&#38;#38;\"> <!-- ampersand --> <!ENTITY apos  \"&#39;\">     <!-- apostrophe --> <!ENTITY lt    \"&#38;#60;\"> <!-- less than --> <!ENTITY gt    \"&#62;\">     <!-- greater than --> <!ENTITY nbsp  \"&#160;\">    <!-- non-breaking space --> <!ENTITY shy   \"&#173;\">    <!-- soft hyphen (discretionary hyphen) -->  Conformance Rules: WML-C-06  Character entities M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 17 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved7. WML Syntax WML inherits most of its syntactic constructs from XML.  Refer to [XML] for in-depth information on syntactical issues. 7.1 Entities WML text can contain numeric or named character entities.  These entities specify specific characters in the document character set.  Entities are used to specify characters in the document character set either which must be escaped in WML or which may be difficult to enter in a text editor.  For example, the ampersand (&) is represented by the named entity &amp;.  All entities begin with an ampersand and end with a semicolon. WML is an XML language. This implies that the ampersand and less-than characters must be escaped when they are used in textual data,  That is, these characters may appear in their literal form only when used as markup delimiters, within a comment, etc.  See [XML] for more details. 7.2 Elements Elements specify all markup and structural information about a WML deck.  Elements may contain a start tag, content and an end tag.  Elements have one of two structures:  <tag> content </tag> or  <tag/> Elements containing content are identified by a start tag (<tag>) and an end tag (</tag>).  An empty-element tag (<tag/>) identifies elements with no content. 7.3 Attributes WML attributes specify additional information about an element. More specifically, attributes specify information about an element that is not part of the element's content.  Attributes are always specified in the start tag of an element. For example,  <tag attr=\"abcd\"/> Attribute names are an XML NAME and are case sensitive. XML requires that all attribute values be quoted using either double quotation marks (\") or single quotation marks ('). Single quote marks can be included within the attribute value when the value is delimited by double quote marks and vice versa. Character entities may be included in an attribute value. 7.4 Comments WML comments follow the XML commenting style and have the following syntax:  <!-- a comment --> Comments are intended for use by the WML author and should not be displayed by the user agent.  WML comments cannot be nested. 7.5 Variables WML cards and decks can be parameterised using variables.  To substitute a variable into a card or deck, the following syntax is used:  $identifier  $(identifier) WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 18 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved $(identifier:conversion) Parentheses are required if white space does not indicate the end of a variable.  Variable syntax has the highest priority in WML, i.e., anywhere the variable syntax is legal, an unescaped '$' character indicates a variable substitution.  Variable references are legal in any PCDATA and in any attribute value identified by the vdata entity type (see section 8.3).  Variable references are illegal in attribute values of type CDATA (see section 10.3.5). Since XML does not allow for dollar sign characters in other attribute types (for example, ID and NMTOKEN), variable references are also illegal in those attributes A sequence of two dollar signs ($$) represents a single dollar sign character in all CDATA attribute values and in all #PCDATA text. See section 10.3 for more information on variable syntax and semantics. Conformance Rules: WML-S-64  Variable references may only occur in vdata attribute values M 7.6 Case Sensitivity XML is a case-sensitive language; WML inherits this characteristic.  No case folding is performed when parsing a WML deck.  This implies that all WML tags and attributes are case sensitive.  In addition, any enumerated attribute values are case sensitive. 7.7 CDATA Section CDATA sections are used to escape blocks of text and are legal in any PCDATA, e.g., inside an element.  CDATA sections begin with the string \"<![CDATA[\" and end with the string \"]]>\".  For example:  <![CDATA[ this is <B> a test ]]> Any text inside a CDATA section is treated as literal text and will not be parsed for markup.  CDATA sections are useful anywhere literal text is convenient. Refer to the [XML] specification for more information on CDATA sections. 7.8 Processing Instructions WML makes no use of XML processing instructions beyond those explicitly defined in the XML specification. 7.9 Errors The [XML] specification defines the concept of a well-formed XML document. WML decks that violate the definition of a well-formed document are in error.  See section 14.2.3 for related information. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 19 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved8. Core WML Data Types 8.1 Character Data All character data in WML is defined in terms of XML data types.  In summary: • CDATA - text which may contain numeric or named character entities.  CDATA is used only in attribute values. • PCDATA - text which may contain numeric or named character entities.  This text may contain tags (PCDATA is \"Parsed CDATA\").  PCDATA is used only in elements. • NMTOKEN - a name token, containing any mixture of name characters, as defined by the XML specification. See [XML] for more details. 8.2 Length <!ENTITY % length  \"CDATA\">    <!-- [0-9]+ for pixels or [0-9]+\"%\" for                                     percentage length --> The length type may either be specified as an integer representing the number of pixels of the canvas (screen, paper) or as a percentage of the available horizontal or vertical space. Thus, the value \"50\" means fifty pixels. For widths, the value \"50%\" means half of the available horizontal space (between margins, within a canvas, etc.). For heights, the value \"50%\" means half of the available vertical space (in the current window, the current canvas, etc.). The integer value consists of one or more decimal digits ([0-9]) followed by an optional percent character (%).  The length type is only used in attribute values. 8.3 Vdata <!ENTITY % vdata   \"CDATA\">    <!-- attribute value possibly containing                                     variable references --> The vdata type represents a string that may contain variable references (see section 10.3).  This type is only used in attribute values. 8.4 Flow <!ENTITY % layout  \"br\"> <!ENTITY % flow     \"%text; | %layout; | img | anchor | a | table\"> The flow type represents \"card-level\" information. In general, flow is used anywhere general markup can be included.  8.5 HREF <!ENTITY % HREF    \"%vdata;\">  <!-- URI, URL or URN designating a hypertext                                     node. May contain variable references --> The HREF type refers to either a relative or an absolute Uniform Resource Locator [RFC2396].  See section 5 for more information. 8.6 Boolean <!ENTITY % boolean \"(true|false)\"> The boolean type refers to a logical value of true or false. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 20 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved8.7 Number <!ENTITY % number  \"NMTOKEN\">  <!-- a number, with format [0-9]+ --> The number type represents an integer value greater than or equal to zero. 8.8 xml:lang The xml:lang attribute specifies the natural or formal language of an element or its attributes.  The value of the attributes is a language code according to [RFC1766].  See [XML] for details on the syntax and specification of the attribute values.  The attribute identifies to the user agent the language used text that may be presented to the user (i.e., an element’s content and attribute values).  The user agent should perform a best effort to present the data according to the specifics of the language.  Nested elements can assume the parent’s language or use another.  Where an element has both text content and text based attribute values that may be presented to the user, authors must use the same language for both.  Variable values that are placed in vdata should match the language of the containing element.  An element’s language must be established according to the following precedence (from highest to lowest): 1. Based on the xml:lang attribute specified for the element. 2. Based on the xml:lang attribute specified by the closest parent element. 3. Based on any language information included in the transport and document meta data (see sections 6.1 and 11.3.2 for more detail). 4. Based on user agent default preferences. 8.9 The id and class Attributes All WML elements have two core attributes: id and class that can be used for such tasks as server-side transformations.  The id attribute provides an element a unique name within a single deck.  The attribute class affiliates an element with one or more classes.  Multiple elements can be given the same class name.  All elements of a single deck with a common class name are considered part of the same class.  Class names are cases sensitive.  An element can be part of multiple classes if it has multiple unique class names listed in its class attribute.  Multiple class names within a single attribute must be separated by white space.  Redundant class names as well as insignificant white space between class names may be removed.  The WML user agent should ignore these attributes. 8.10 ContentType  <!ENTITY % ContentType \"%vdata;\">  <!-- media type. May contain variable                                         references --> The ContentType type represents the media type defined in [RFC2045].  See section 9.5.1 for more information. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 21 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved9. Events and Navigation 9.1 Navigation and Event Handling WML includes navigation and event-handling models.  The associated elements allow the author to specify the processing of user agent events.  Events may be bound to tasks by the author; when an event occurs, the bound task is executed.  A variety of tasks may be specified, such as navigation to an author-specified URL.  Event bindings are declared by several elements, including do and onevent. 9.2 History WML includes a simple navigational history model that allows the author to manage backward navigation in a convenient and efficient manner.  The user agent history is modelled as a stack of URLs that represent the navigational path the user traversed to arrive at the current card. Three operations may be performed on the history stack: • Reset - the history stack may be reset to a state where it only contains the current card.  See the newcontext attribute (section 10.2) for more information. • Push - a new URL is pushed onto the history stack as an effect of navigation to a new card. • Pop - the current card's URL (top of the stack) is popped as a result of backward navigation. The user agent must implement a navigation history.  As each card is accessed via an explicitly specified URL, (e.g., via the href attribute in go element,) an entry for the card is added to the history stack even if it is identical to the most recent entry.  At a minimum, each entry must record the absolute URL of the card, the method (get or post) used to access the card, the value of any postfields, and any request headers. The card content is not stored in the history. Variable references are never stored in the history. Any variable references in the history data must be replaced with the current value of the variables before the entry is added to the stack. The user agent must return the user to the previous card in the history if a prev task is executed (see section 9.5.2).  The execution of prev pops the current card URL from the history stack when a prev task is executed.   If the card is part of deck that was originally fetched using an HTTP post method, and the user agent must re-fetch the deck to establish the card, then the user agent must reissue any post data associated with fetching the original deck. The post data values must be the same values used to fetch the original deck.  Refer to section 12.5.2 for more information on the semantics of prev.  See [CACHE] for more information on caching semantics. Conformance Rules: WML-C-07  History M 9.3 The Postfield Element <!ELEMENT postfield EMPTY> <!ATTLIST postfield   name         %vdata;           #REQUIRED   value        %vdata;           #REQUIRED   %coreattrs;   > The postfield element specifies a field name and value for transmission to an origin server during a URL request.  The actual encoding of the name and value will depend on the method used to communicate with the origin server. Refer to section 9.5.1 for more information on the use of postfield in a go element. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 22 (80)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAttributes name=vdata The name attribute specifies the field name. value=vdata The value attribute specifies the field value. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-37  postfield M 9.4 The Setvar Element <!ELEMENT setvar EMPTY> <!ATTLIST setvar   name         %vdata;           #REQUIRED   value        %vdata;           #REQUIRED   %coreattrs;   > The setvar element specifies the variable to set in the current browser context as a side effect of executing a task.  The element must be ignored if the name attribute doe not evaluate to a legal variable name at runtime (see section 7.5).  See section 10.3.4 for more information on setting variables. Attributes name=vdata The name attribute specifies the variable name. value=vdata The value attribute specifies the value to be assigned to the variable. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-52  setvar M 9.5 Tasks <!ENTITY % task   \"go | prev | noop | refresh\"> Tasks specify processing that is performed in response to an event such as timer expiring, entering a card, or activating an anchor element. 9.5.1 The Go Element <!ENTITY % cache-control “(no-cache)” > <!ELEMENT go (postfield | setvar)*> <!ATTLIST go   href            %HREF;          #REQUIRED   sendreferer     %boolean;       \"false\"   method          (post|get)      \"get\"   enctype         %ContentType;          \"application/x-www-form-urlencoded\"   cache-control   %cache-control; #IMPLIED   accept-charset  CDATA           #IMPLIED WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 23 (81)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  %coreattrs;   > The go element declares a go task, indicating navigation to a URI.  If the URI names a WML card or deck, it is displayed.  A go executes a \"push\" operation on the history stack (see section 9.2).  The UA must ignore all postfield elements of a go element if the target of the go element is a card contained within the current deck and if the cache-control is not specified as “no-cache”. Refer to section 12.5.1 for more information on the semantics of go. Attributes href=HREF The href attribute specifies the destination URI, e.g., the URI of the card to display. sendreferer=boolean If this attribute is true, the user agent must specify, for the server's benefit, the URI of the deck containing this task (i.e., the referring deck).  This allows a server to perform a form of access control on URIs, based on which decks are linking to them. The URI must be the smallest relative URI possible if it can be relative at all. For example, if sendreferer=true, an HTTP based user agent shall indicate the URI of the current deck in the HTTP \"Referer\" request header [RFC2068616]. method=(post|get) This attribute specifies the HTTP submission method.  Currently, the values of get and post are accepted and cause the user agent to perform an HTTP GET or POST respectively. cache-control=no-cache If the “cache-control” attribute is present, and the value is set to “no-cache”, the client MUST reload the URL from the origin server.  This attribute represents the HTTP “cache-control” header, when this attribute is present, the HTTP “cache-control” header MUST be added to the request with the same value as specified in the attribute. enctype=ContentType This attribute specifies the content type used to submit the parameter to the server (when the value of method is post). The default value for this attribute is application/x-www-form-urlencoded. Currently, only application/x-www-form-urlencoded or multipart/form-data can be specified.  When the field values in a submitted form may contain characters not in the US-ASCII character set, it is recommended that the post method and multipart/form-data [RFC2388] are used.  User agents must explicitly specify content type for each part. If a part corresponds to a postfield element, its content type should be text/plain.  The charset parameter is required when the content contains characters not in the US-ASCII character set.  accept-charset=cdata This attribute specifies the list of character encodings for data that the origin server accepts when processing input. When the go task is executed and method=\"post\" has been specified, the user agent should encode the field names and values of all associated postfield elements using any one of the specified character sets. The value of this attribute is a comma- or space-separated list of character encoding names (charset) as specified in [RFC2045] and [RFC2068616].  The IANA Character Set registry defines the public registry for charset values.   If the accept-charset attribute is not specified or is the reserved string unknown, user agents should use the character encoding that was used to transmit the WML deck that contains the go element. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 24 (81)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAttributes defined elsewhere • id (see section 8.9) • class (see section 8.9) The go element may contain one or more postfield elements.  These elements specify information to be submitted to the origin server during the request.  The submission of field data is performed in the following manner: 1. The field name/value pairs are identified and all variables are substituted. 2. The user agent should transcode the field names and values to the correct character set, as specified explicitly by the accept-charset or implicitly by the document encoding. 3. If the href attribute value is an HTTP URI, the request is performed according to the method and enctype attribute's value: Method Enctype Process application/x-www-form-urlencoded The field names and values are escaped using URI-escaping and assembled into an application/x-www-form-urlencoded content type.   The submission data is appended to the query component of the URI. The result must be a valid query component with the original query part and the postfields combined. An HTTP GET operation is performed on the resulting URL. get multipart/form-data Error. application/x-www-form-urlencoded The field names and values are escaped using URI-escaping and assembled into an application/x-www-form-urlencoded content type.   The submission data is sent as the body of the HTTP POST request.  The Content-Type header must include the charset parameter to indicate the character encoding. post multipart/form-data The field names and values are encoded as a multipart/form-data content type as defined in [RFC2388].  The Content-Type header must include the charset parameter to indicate the character encoding when the part contains characters not in the US-ASCII character set.  The submission data is sent as the body of the HTTP POST request. When enctype attribute's value is application/x-www-form-urlencoded, the field names and values must be encoded as follows:  1. The field names and values are escaped using URI-escaping, and listed in the order in which the postfields are presented.  2. The name is separated from the value by  `=' and name/value pairs are separated from each other by `&'. See [RFC2396] for more information on the URI syntax and its escape sequence. It is recommended that user agents submit data with an application/vnd.wap.multipart.form-data content type when enctype attribute has a value of multipart/form-data.  Some user agents may only support data submission as application/x-www-form-urlencoded content type. Such user agents may ignore enctype attribute. Thus, it is recommended that an origin server expect either form of submission (i.e., multipart/form-data or application/x-www-form-urlencoded) when the enctype value is multipart/form-data. However, the origin server may assume that it will only receive WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 25 (81)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedan application/x-www-form-urlencoded submission when the enctype value is application/x-www-form-urlencoded. For example, the following go element would cause an HTTP GET request to the URL \"/foo?x=1\":  <go href=\"/foo\">   <postfield name=\"x\" value=\"1\"/>  </go> The following example will cause an HTTP POST to the URL \"/bar\" with a message entity containing \"w=12&y=test\":  <go href=\"/bar\" method=\"post\">   <postfield name=\"w\" value=\"12\"/>   <postfield name=\"y\" value=\"test\"/>  </go> Conformance Rules: WML-C-29  go M 9.5.2 The Prev Element <!ELEMENT prev (setvar)*> <!ATTLIST prev   %coreattrs;   > The prev element declares a prev task, indicating navigation to the previous URI on the history stack.  A prev performs a \"pop\" operation on the history stack (see section 9.2). Refer to section 12.5.2 for more information on the semantics of prev. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-38  prev M 9.5.3 The Refresh Element <!ELEMENT refresh (setvar)*> <!ATTLIST refresh   %coreattrs;   > The refresh element declares a refresh task, indicating an update of the user agent context as specified by the setvar elements. User-visible side effects of the state changes (e.g., a change in the screen display) occur during the processing of the refresh task. A refresh and its side effects must occur even if the elements have no setvar elements given that context may change by other means (e.g., timer). Refer to section 12.5.4 for more information on the semantics of refresh. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-42  refresh M 9.5.4 The Noop Element <!ELEMENT noop EMPTY> WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 26 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved<!ATTLIST noop   %coreattrs;   > This noop element specifies that nothing should be done, i.e., \"no operation\". Refer to section 12.5.3 for more information on the semantics of noop. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules:   WML-C-35  noop M 9.6 Card/Deck Task Shadowing A variety of elements can be used to create an event binding for a card.  These bindings may also be declared at the deck level: • Card-level: the event-handling element may appear inside a card element and specify event-processing behaviour for that particular card. • Deck-level: the event-handling element may appear inside a template element and specify event-processing behaviour for all cards in the deck.  A deck-level event-handling element is equivalent to specifying the event-handling element in each card. A card-level event-handling element overrides (or \"shadows\") a deck-level event-handling element if they both specify the same event.  A card-level onevent element will shadow a deck-level onevent element if they both have the same type.  A card-level do element will shadow a deck-level do element if they have the same name.  For a given card, the active event-handling elements are defined as the event-handling elements specified in the card that do not bind a noop task, plus any event-handling elements specified in the deck's template not overridden (or shadowed) in the card or bind a noop task. Shadowed event-handling elements, event-handling elements defined in other cards, and event-handling elements that bind a noop task are considered inactive elements. If a card-level element shadows a deck-level element and the card-level element binds a noop task, the event binding for that event will be completely masked.  In this situation, the card- and deck-level elements will be ignored and no side effects will occur on delivery of the event. In other words, both the card-level and the deck-level elements are considered inactive elements in such a case. If a card-level element or deck-level element binds a noop task but does not shadow and is not shadowed by another element, then the binding for that event will also be masked and similarly ignored with no side effects. In the following example, a deck-level do element indicates that a prev task should execute on receipt of a particular user action.  The first card inherits the do element specified in the template element and will display the do to the user.  The second card shadows the deck-level do element with a noop.  The user agent will not display the do element when displaying the second card.  The third card shadows the deck-level do element, causing the user agent to display the alternative label and to perform the go task if the do is selected.  <wml>   <template>    <do type=\"options\" name=\"do1\" label=\"default\">     <prev/>    </do>   </template> WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 27 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved   <card id=\"first\">    <!-- deck-level do not shadowed.  The card exposes the            deck-level do as part of the current card -->     <!-- rest of card -->    ...   </card>    <card id=\"second\">    <!-- deck-level do is shadowed with noop.         It is not exposed to the user -->    <do type=\"options\" name=\"do1\">     <noop/>    </do>     <!-- rest of card -->          </card>    <card id=\"third\">    <!-- deck-level do is shadowed. It is replaced by          a card-level do -->    <do type=\"options\" name=\"do1\" label=\"options\">     <go href=\"/options\"/>    </do>     <!-- rest of card -->          </card>   </wml> Conformance Rules: WML-C-08  Card/Deck task Shadowing M 9.7 The Do Element <!ENTITY % task   \"go | prev | noop | refresh\"> <!ELEMENT do (%task;)> <!ATTLIST do   type         CDATA       #REQUIRED   label        %vdata;     #IMPLIED   name         NMTOKEN     #IMPLIED   optional     %boolean;   \"false\"   xml:lang     NMTOKEN     #IMPLIED   %coreattrs;   > The do element provides a general mechanism for the user to act upon the current card, i.e., a card-level user interface element.  The representation of the do element is user agent dependent and the author must only assume that the element is mapped to a unique user interface widget that the user can activate.  For example, the widget mapping may be to a graphically rendered button, a soft or function key, a voice-activated command sequence, or any other interface that has a simple \"activate\" operation with no inter-operation persistent state.  When the user activates a do element, the associated task is executed. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 28 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedThe do element may appear at both the card and deck-level: • Card-level: the do element may appear inside a card element and may be located anywhere in the text flow.  If the user agent intends to render the do element inline (i.e., in the text flow), it should use the element's anchor point as the rendering point.  WML authors must not rely on the inline rendering of the do element and must not rely on the correct positioning of an inline rendering of the element. • Deck-level: the do element may appear inside a template element, indicating a deck-level do element.  A deck-level do element applies to all cards in the deck (i.e., is equivalent to having specified the do within each card).  For the purposes of inline rendering, the user agent must behave as if deck-level do elements are located at the end of the card's text flow. Attributes type=cdata The do element type.  This attribute provides a hint to the user agent about the author's intended use of the element and should be used by the user agent to provide a suitable mapping onto a physical user interface construct.  WML authors must not rely on the semantics or behaviour of an individual type value, or on the mapping of type to a particular physical construct.  All types are reserved, except for those marked as experimental, or vendor-specific. User agents must accept any type, but may treat any unrecognised type as the equivalent of unknown. In the following table, the * character represents any string, e.g., Test* indicates any string starting with the word Test.  Although experimental and vendor-specific types may be specified in any case, they are case-sensitive; e.g., the types VND-foo and vnd-foo are distinct. Table 1. Pre-defined DO types Type Description accept Positive acknowledgement (acceptance) prev Backward history navigation help Request for help.  May be context-sensitive. reset Clearing or resetting state. options Context-sensitive request for options or additional operations. delete Delete item or choice. unknown A generic do element.  Equivalent to an empty string (e.g., type=\"\"). X-*, x-* Experimental types.  This set is not reserved. vnd.*, VND.* and any combination of [Vv][Nn][Dd].* Vendor-specific or user-agent-specific types.  This set is not reserved.  Vendors should allocate names with the format VND.CO-TYPE, where CO is a company name abbreviation and type is the do element type.  See [RFC2045] for more information. label=vdata If the user agent is able to dynamically label the user interface widget, this attribute specifies a textual string suitable for such labelling.  The user agent must make a best-effort attempt to label the UI widget and should adapt the label to the constraints of the widget (e.g., truncate the string).  If an element can not be dynamically labelled, this attribute may be ignored. To work well on a variety of user agents, labels should be six characters or shorter in length. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 29 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedname=nmtoken This attribute specifies the name of the do event binding.  If two do elements are specified with the same name, they refer to the same binding.  A card-level do element shadows a deck-level do with the same name value (see section 9.6 for more detail).  It is an error to specify two or more do elements with the same name in a single card or in the template element.  An unspecified name defaults to the value of the type attribute. optional=boolean If this attribute has a value of true, the user agent may ignore this element. All active do elements that have not been designated optional must be presented to the user. The UA must make such elements accessible to the user in some manner.  In other words, it must be possible for the user to activate them (i.e., initiate the tasks associated with the element), via some user interface element. All inactive do elements must not be presented to the user in a way that the user can activate such elements. Elements that have been designated as optional may be ignored at the discretion of the user agent. (For example, the author may wish to allow the user agent to ignore vendor-specific types that it doesn't recognise.) Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-26  do M WML-S-66  Two or more do elements with the same name must not be present in a single card or in the template element. (Note: An unspecified name defaults to the value of the type attribute.) M WML-C-71  Two or more do element with the same name must not be present in a single card or in the template element. (Note: An unspecified name defaults to the value of the type attribute.) O 9.8 The Anchor Element <!ELEMENT anchor ( #PCDATA | br | img | go | prev | refresh )*> <!ATTLIST anchor   title        %vdata;      #IMPLIED   accesskey    %vdata;      #IMPLIED   xml:lang     NMTOKEN      #IMPLIED   %coreattrs;   > The anchor element defines a “hot spot” in the content, which is bound to the go, prev, or refresh task that it contains. It is expected that the user agent presents the anchor element as a linking element; e.g., as “hypertext.”  When the user selects the element, the associated task is executed. Anchors may be present in any text flow, excluding the text in option elements (i.e., anywhere formatted text is legal, except for option elements).   It is an error to specify other than one task element (e.g., go, prev or refresh) in an anchor element. Attributes title=vdata This attribute specifies a brief text string identifying the link.  The user agent may display it in a variety of ways, including dynamic labelling of a button or key, a tool tip, a voice WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 30 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedprompt, etc.  The user agent may truncate or ignore this attribute depending on the characteristics of the navigational user interface.  To work well on a broad range of user agents, the author should limit all labels to 6 characters in length. accesskey=vdata This attribute assigns an access key to an element. An access key is a single character from the document character set. Its purpose is to allow the user to activate a particular element by using a single key. The keys available will vary depending on the type of mobile device being used (e.g., phones will usually have \"0\"-\"9\", \"*\" and \"#\" keys).  The user agent is not required to support accesskey. If the user agent does supports access keys, it should respect the requested value if possible. When this is not possible (e.g., the requested key does not already exist or has been defined more than once,) the user agent should assign available keys to the remaining elements that request them, in the order they are encountered in the card, until all available keys are assigned. Any remaining accesskey attributes are ignored. The author can not assume that the key specified will be the one used, nor that all elements that define an accesskey will have one assigned. The following elements support the accesskey attribute: A, INPUT, and ANCHOR.  Activating an access key assigned to an element gives focus to the element. The action that occurs when an element receives focus depends on the element. For example, when a user activates a link defined by the A element, the user agent generally follows the link. When a user activates a radio button, the user agent changes the value of the radio button. When the user activates a text field, it allows input, etc.  In this example, we request an access key for a link defined by the A element. Activating this access key takes the user to another document, in this case, a table of contents.  <a accesskey=\"1\" href=\"http://someplace.com/specification/contents.html\"> Table of Contents</a>  The invocation of access keys may depend on both the user agent and the device on which it is running. For example, the access key may be recognised directly, or it may be necessary to press it in conjunction with a \"command\" key.. The recognition of access keys may be inhibited by context. For example, a device that recognises access keys directly may inhibit their recognition when an input element is active The rendering of access keys depends on the user agent. User agents should render the value of an access key in such a way as to emphasise its role and to distinguish it from other characters (e.g., by underlining it, enclosing it in brackets, displaying it in reverse video or in a distinctive font, etc.) The author should not refer to the specific access key value in content or in documentation, as the requested value may not be used. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-20  anchor M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 31 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved9.9 The A Element <!ELEMENT a ( #PCDATA | br | img )*> <!ATTLIST a   href         %HREF;       #REQUIRED   title        %vdata;      #IMPLIED   accesskey    %vdata;      #IMPLIED   xml:lang     NMTOKEN      #IMPLIED   %coreattrs;   > The a element is a short form of an anchor element bound to a go task without variable assignments.  For example, the following markup:  <anchor>follow me   <go href=\"destination\"/>  </anchor> Is identical in behaviour and semantics to:  <a href=\"destination\">follow me</a> It is invalid to nest a elements.  Authors are encouraged to use the a element instead of anchor where possible, to allow more efficient tokenisation. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) • accesskey (see section 9.8) Conformance Rules: WML-C-19  a M 9.10 Intrinsic Events Several WML elements are capable of generating events when the user interacts with them.  These so-called \"intrinsic events\" indicate state transitions inside the user agent.  Individual elements specify the events they can generate.  WML defines the following intrinsic events: Table 2. WML Intrinsic Events Event Element(s) Description ontimer card, template The ontimer event occurs when a timer expires.  Timers are specified using the timer element (see section 11.7). onenterforward card, template The onenterforward event occurs when the user agent enters a card via a go task or any method with identical semantics.  This includes card entry caused by a script function or user-agent-specific mechanisms, such as a means to directly enter and navigate to a URL. The onenterforward intrinsic event may be specified at both the card and deck-level. Event bindings specified in the template element apply to all cards in the deck and may be overridden as specified in section 9.6. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 32 (82)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedEvent Element(s) Description onenterbackward card, template The onenterbackward event occurs when the user agent enters a card via a prev task or any method with identical semantics.  In other words, the onenterbackward event occurs when the user causes the user agent to navigate into a card by using a URL retrieved from the history stack.  This includes navigation caused by a script function or user-agent-specific mechanisms. The onenterbackward intrinsic event may be specified at both the card and deck-level.  Event bindings specified in the template element apply to all cards in the deck and may be overridden as specified in section 9.6. onpick option The onpick event occurs when the user selects or deselects this item. The author may specify that certain tasks are to be executed when an intrinsic event occurs.  This specification may take one of two forms.  The first form specifies a URI to be navigated to when the event occurs.  This event binding is specified in a well-defined element-specific attribute and is the equivalent of a go task.  For example:  <card onenterforward=\"/url\"> <p> Hello </p> </card> This attribute value may only specify a URL. The second form is an expanded version of the previous, allowing the author more control over user agent behaviour.  An onevent element is declared within a parent element, specifying the full event binding for a particular intrinsic event.  For example, the following is identical to the previous example:  <card>   <onevent type=\"onenterforward\">    <go href=\"/url\"/>   </onevent>   <p>    Hello   </p>  </card> The user agent must treat the attribute syntax as an abbreviated form of the onevent element where the attribute name is mapped to the onevent type. An intrinsic event binding is scoped to the element in which it is declared, e.g., an event binding declared in a card is local to that card.  Any event binding declared in an element is active only within that element.  If the event binding element specifies an intrinsic event type which does apply to its parent element, it must be ignored by the user agent.  Conflicting event bindings within an element are an error. Conformance Rules: WML-C-09  Intrinsic Events M WML-S-69  Event bindings must not conflict M WML-C-74  Event bindings must not conflict O 9.10.1 The Onevent Element <!ENTITY % task   \"go | prev | noop | refresh\"> <!ELEMENT onevent (%task;)> <!ATTLIST onevent   type         CDATA       #REQUIRED WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 33 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  %coreattrs;   > The onevent element binds a task to a particular intrinsic event for the immediately enclosing element, i.e., specifying an onevent element inside an \"XYZ\" element associates an intrinsic event binding with the \"XYZ\" element. The user agent must ignore any onevent element specifying a type that does not correspond to a legal intrinsic event for the immediately enclosing element. Attributes type=cdata The type attribute indicates the name of the intrinsic event. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-39  onevent M 9.10.2 Card/Deck Intrinsic Events Event handlers for the onenterforward, onenterbackward, and ontimer intrinsic events may be specified at both the card- and deck-level and have the shadowing semantics defined in section 9.6.    Handlers for these events are specified using the corresponding attribute of either the template or card element, or by including an onevent element within the template or card element. A card-level handler always overrides a deck-level handler of the same type, regardless of which syntax is used. For example, in the following deck the event handler in the card overrides the one specified in the template although the two have been defined using different syntax:   <wml>   <template>    <onevent type=\"onenterbackward\">     <go href=\"aaa\"/>    </onevent>   </template>    <card onenterbackward=\"bbb\">    <p>xyz</p>   </card>  </wml> WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 34 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved10. The State Model WML includes support for managing user agent state, including: • Variables - parameters used to change the characteristics and content of a WML card or deck; • History - navigational history, which may be used to facilitate efficient backward navigation; and • Implementation-dependent state - other state relating to the particulars of the user agent implementation and behaviour. 10.1 The Browser Context WML state is stored in a single scope, known as a browser context.  The browser context is used to manage all parameters and user agent state, including variables, the navigation history and other implementation-dependent information related to the current state of the user agent. Conformance Rules: WML-C-10  Browser context M 10.2 The Newcontext Attribute The browser context may be initialised to a well-defined state by the newcontext attribute of the card element (see section 11.5).  This attribute indicates that the browser context should be re-initialised and must perform the following operations: • Unset (remove) all variables defined in the current browser context, • Clear the navigational history state, and • Reset implementation-specific state to a well-known value. The newcontext is only performed as part of the go task.  See section 12.5 for more information on the processing of state during navigation. Conformance Rules: WML-C-11  Initialisation (newcontext) M 10.3 Variables All WML content can be parameterised, allowing the author a great deal of flexibility in creating cards and decks with improved caching behaviour and better perceived interactivity.  WML variables can be used in the place of strings and are substituted at run-time with their current value. A variable is said to be set if it has a value not equal to the empty string.  A value is not set if it has a value equal to the empty string, or is otherwise unknown or undefined in the current browser context. Conformance Rules: WML-C-12  Variables M 10.3.1 Variable Substitution The values of variables can be substituted into both the text (#PCDATA) of a card and into %vdata and %HREF attribute values in WML elements. Only textual information can be substituted; no substitution of elements or attributes is possible.  The substitution of variable values happens at run-time in the user agent.  Substitution does not affect the current value of the variable and is defined as a string substitution operation.  If an undefined variable is referenced, it results in the substitution of the empty string. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 35 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedWML variable names consist of an US-ASCII letter or underscore followed by zero or more letters, digits or underscores.  Any other characters are illegal and result in an error.  Variable names are case sensitive. The following description of the variable substitution syntax uses  the Extended Backus-Naur Form (EBNF) established in [XML].   var     = ( \"$\" varname ) |             ( \"$(\" varname ( conv )? \")\" ) |             ( deprecated-var )    conv    = \":\" ( \"escape\" | \"noesc\" | \"unesc\" )    varname = ( \"_\" | alpha ) ( \"_\" | alpha | digit )*   alpha   = lalpha | halpha   lalpha  = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" |             \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" |             \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"   halpha  = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" |             \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" |             \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"   digit   = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |             \"8\" | \"9\"   deprecated-var = \"$(\" varname deprecated-conv \")\"   deprecated-conv  = \":\"( escape | noesc | unesc )   escape  = (\"E\" | \"e\") ( ( \"S\" | \"s\" ) ( \"C\" | \"c\" )                           ( \"A\" | \"a\" ) ( \"P\" | \"p\" )                           ( \"E\" | \"e\" ) )?   noesc   = ( \"N\" | \"n\" ) ( ( \"O\" | \"o\" ) (\"E\" | \"e\")                             ( \"S\" | \"s\" ) ( \"C\" | \"c\" ) )?   unesc   = ( \"U\" | \"u\" ) ( ( \"N\" | \"n\" ) (\"E\" | \"e\")                             ( \"S\" | \"s\" ) ( \"C\" | \"c\" ) )?  Mixed case and abbreviated conversions have been deprecated.  Authors should only use lower case conversions. Parentheses are required anywhere the end of a variable cannot be inferred from the surrounding context, e.g., an illegal character such as white space. For example:  This is a $var  This is another $(var).  This is an escaped $(var:escape).  This is an unescape $(var:unesc).  Other legal variable forms: $_X $X32 $Test_9A The value of variables can be converted into a different form as they are substituted. A conversion can be specified in the variable reference following the colon. The following table summarised the current conversions and their legal abbreviations: Table 3. Variable escaping methods Conversion Effect Noesc No change to the value of the variable. Escape URL-escape the value of the variable. Unesc URL-unescape the value of the variable. The use of a conversion during variable substitution does not affect the actual value of the variable. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 36 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedURL-escaping is detailed in [RFC2396].  All lexically sensitive characters defined in WML must be escaped, including all characters not in the unreserved set specified by [RFC2396]. If no conversion is specified, the variable is substituted using the conversion format appropriate for the context. All attributes defined as %HREF; default to escape conversion, elsewhere no conversion is done. Specifying the noesc conversion disables context sensitive escaping of a variable. Conformance Rules: WML-S-65  Variable references must match the production rule var  M WML-C-70  Variable references must match the production rule var O 10.3.2 Parsing the Variable Substitution Syntax The variable substitution syntax (e.g., $X) is parsed after all XML parsing is complete.  In XML terminology, variable substitution is parsed after the XML processor has parsed the document and provided the resulting parsed form to the XML application.  In the context of this specification, the WML parser and user agent is the XML application. This implies that all variable syntax is parsed after the XML constructs, such as tags and entities, have been parsed.  In the context of variable parsing, all XML syntax has a higher precedence than the variable syntax, e.g., entity substitution occurs before the variable substitution syntax is parsed.  The following examples are identical references to the variable named X:  $X  &#x24;X  $&#x58;  &#36;&#x58; 10.3.3 The Dollar-sign Character A side effect of the parsing rules is that the literal dollar sign must be encoded with a pair of dollar sign entities in any #PCDATA text or CDATA attribute values.  A single dollar-sign entity, even specified as &#x24;, results in a variable substitution. In order to include a '$' character in a WML deck, it must be explicitly escaped.  This can be accomplished with the following syntax:    $$ Two dollar signs in a row are replaced with a single '$' character.  For example:    This is a $$ character. This would be displayed as:    This is a $ character. To include the '$' character in URL-escaped strings, specify it with the URL-escaped form:    %24 10.3.4 Setting Variables There are a number of ways to set the value of a variable. When a variable is set and it is already defined in the browser context, the current value is updated. The setvar element allows the author to set variable state as a side effect of navigation.  Setvar may be specified in task elements, including go, prev and refresh.  The setvar element specifies a variable name and value, for example:  <setvar name=\"location\" value=\"$(X)\"/> The variable specified in the name attribute (e.g., location) is set as a side effect of navigation.  See the discussion of event handling (section 8.8 and section 12.5) for more information on the processing of the setvar element. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 37 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedInput elements set the variable identified by the name attribute to any information entered by the user.  For example, an input element assigns the entered text to the variable, and the select element assigns the value present in the value attribute of the chosen option element. User input is written to variables when the user commits the input to the input or select element.  Committing input is an MMI dependent concept, and the WML author must not rely on a particular user interface.  For example, some implementations will update the variable with each character entered into an input element, and others will defer the variable update until the input element has lost focus.  The user agent must update all variables prior to the execution of any task.  The user agent may re-display the current card when variables are set, but the author must not assume that this action will occur. 10.3.5 Validation Within the WML document, any string following a single dollar sign ('$') must be treated as a variable reference and validated, unless it is part of an escaped literal dollar sign sequence according to section 10.3.3.  Each reference must use proper variable name syntax, according to section 10.3.1. Each reference must be placed either within a card's text (#PCDATA) or within %vdata or %HREF attribute values. Other CDATA attribute values must use escaped literal dollar sign as required to prevent the creation of an otherwise valid variable reference.  The deck is in error if any variable reference uses invalid syntax or is placed in an invalid location. Examples of invalid variable use:  <!-- bad variable syntax -->   Balance left is $10.00   <!-- bad placement (in the type attribute) -->   <do type=\"x-$(type)\" label=\"$type\"> Example of escaped dollar sign in an attribute of type CDATA:  <!-- Dollar sign escaped in type attribute -->   <do type=\"x-$$(type)\" label=\"$type\"> 10.4 Context Restrictions User agents may provide users means to reference and navigate to resources independent of the current content.  For example, user agents may provide bookmarks, a URL input dialog, and so forth.  Whenever a user agent navigates to a resource that was not the result of an interaction with the content in the current context, the user agent must establish another context for that navigation.  The user agent may terminate the current context before establishing another one for the new navigation attempt. Conformance Rules: WML-C-13  Context restrictions M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 38 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11. The Structure of WML Decks WML data are structured as a collection of cards.  A single collection of cards is referred to as a WML deck.  Each card contains structured content and navigation specifications.  Logically, a user navigates through a series of cards, reviews the contents of each, enters requested information, makes choices and navigates to another card or returns to a previously visited card. 11.1 Document Prologue A valid WML deck is a valid XML document and therefore must contain an XML declaration and a document type declaration (see [XML] for more detail about the definition of a valid document).  A typical document prologue contains:  <?xml version=\"1.0\"?>  <!DOCTYPE wml PUBLIC \"-//WAPFORUM//DTD WML 1.3//EN\"      \"http://www.wapforum.org/DTD/wml13.dtd\"> It is an error to omit the prologue.  11.2 The WML Element <!ELEMENT wml ( head?, template?, card+ )> <!ATTLIST wml   xml:lang        NMTOKEN        #IMPLIED   %coreattrs;   > The wml element defines a deck and encloses all information and cards in the deck. Attributes xml:lang=nmtoken The xml:lang attribute specifies the natural or formal language in which the document is written.  See section 8.8 for more detail. Conformance Rules: WML-C-53  wml M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 39 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.2.1 A WML Example The following is a deck containing two cards, each represented by a card element (see section 11.5 for information on cards).  After loading the deck, a user agent displays the first card.  If the user activates the DO element, the user agent displays the second card.  <wml>   <card>    <p>     <do type=\"accept\">      <go href=\"#card2\"/>     </do>     Hello world!     This is the first card...    </p>   </card>   <card id=\"card2\">   <p>    This is the second card.    Goodbye.   </p>  </card> </wml> 11.3 The Head Element <!ELEMENT head ( access | meta )+> <!ATTLIST head   %coreattrs;   > The head element contains information relating to the deck as a whole, including meta-data and access control elements. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-30  bhead M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 40 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.3.1 The Access Element <!ELEMENT access EMPTY> <!ATTLIST access   domain       CDATA       #IMPLIED   path         CDATA       #IMPLIED   %coreattrs;   > The access element specifies access control information for the entire deck.  It is an error for a deck to contain more than one access element.  If a deck does not include an access element, access control is disabled. When access control is disabled, cards in any deck can access this deck. Attributes domain=cdata path=cdata A deck's domain and path attributes specify which other decks may access it.  As the user agent navigates from one deck to another, it performs access control checks to determine whether the destination deck allows access from the current deck. If a deck has a domain and/or path attribute, the referring deck's URI must match the values of the attributes. Matching is done as follows: the access domain is suffix-matched against the domain name portion of the referring URI and the access path is prefix matched against the path portion of the referring URI. Domain suffix matching is done using the entire element of each sub-domain and must match each element exactly (e.g., www.wapforum.org shall match wapforum.org, but shall not match forum.org).  Path prefix matching is done using entire path elements and must match each element exactly (e.g., /X/Y matches path=\"/X\" attribute, but does not match path=\"/XZ\" attribute). The domain attribute defaults to the current deck's domain. The path attribute defaults to the value \"/\".  To simplify the development of applications that may not know the absolute path to the current deck, the path attribute accepts relative URIs. The user agent converts the relative path to an absolute path and then performs prefix matching against the PATH attribute. For example, given the following access control attributes:   domain=\"wapforum.org\"   path=\"/cbb\" The following referring URIs would be allowed to go to the deck:   http://wapforum.org/cbb/stocks.cgi   https://www.wapforum.org/cbb/bonds.cgi   http://www.wapforum.org/cbb/demos/alpha/packages.cgi?x=123&y=456 The following referring URIs would not be allowed to go to the deck:   http://www.test.net/cbb   http://www.wapforum.org/internal/foo.wml Domain and path follow URL capitalisation rules. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-21  access M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 41 (83)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.3.2 The Meta Element <!ELEMENT meta EMPTY> <!ATTLIST meta   http-equiv     CDATA      #IMPLIED   name           CDATA      #IMPLIED   forua          %boolean;  \"false\"   content        CDATA      #REQUIRED   scheme         CDATA      #IMPLIED   %coreattrs;   > The meta element contains generic meta-information relating to the WML deck.  Meta-information is specified with property names and values.  This specification does not define any properties, nor does it define how user agents must interpret meta-data. User agents are not required to support the meta-data mechanism. A meta element must contain exactly one attribute specifying a property name; i.e., exactly one from the following set: http-equiv and name. Attributes name=cdata This attribute specifies the property name.  The user agent must ignore any meta-data named with this attribute.  Network servers should not emit WML content containing meta-data named with this attribute. http-equiv=cdata This attribute may be used in place of name and indicates that the property should be interpreted as an HTTP header (see [RFC2068616]).  Meta-data named with this attribute should be converted to a WSP or HTTP response header if the content is tokenised before it arrives at the user agent. forua=boolean If the value is \"false\" an intermediate agent MUST remove the \"meta\" element before the document is sent to the client. If the value is \"true\" the meta data of the element MUST be delivered to the user-agent.  The method of delivery may vary. For example, http-equiv meta-data may be delivered using HTTP or WSP headers. content=cdata This attribute specifies the property value. scheme=cdata This attribute specifies a form or structure that may be used to interpret the property value.  Scheme values vary depending on the type of meta-data. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-34  meta O WML-S-67 A meta element must not contain more than one attribute of name and http-equiv M WML-C-72 A meta element must not contain more than one attribute of name and http-equiv O 11.4 The Template Element <!ENTITY % navelmts \"do | onevent\"> <!ELEMENT template (%navelmts;)*> <!ATTLIST template WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 42 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  %cardev;   %coreattrs;   > The template element declares a template for cards in the deck. Event bindings specified in the template element (e.g., do or onevent) apply to all cards in the deck.  Specifying an event binding in the template element is equivalent to specifying it in every card element.  A card element may override the behaviour specified in the template element.  In particular: • A do element specified in the template element may be overridden in individual cards if both elements have the same name attribute value.  See section  9.6 for more information. • Intrinsic event bindings specified in the template element may be overridden by the specification of an event binding in a card element.  See section 9.6 for more information. See section 11.5.1 for the definition of the card-level intrinsic events (the cardev entity). Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) • onenterforward (see section 11.5.1) • onenterbackward (see section 11.5.1) • ontimer (see section 11.5.1) Conformance Rules: WML-C-47  template M 11.5 The Card Element A WML deck contains a collection of cards. Each card can contain a variety of content. The user's interaction with the card depends on the type of content the card contains and how the content is rendered by the user agent. Conformance Rules: WML-C-25  card M 11.5.1 Card Intrinsic Events <!ENTITY % cardev  \"onenterforward  %HREF;          #IMPLIED   onenterbackward %HREF;          #IMPLIED   ontimer         %HREF;          #IMPLIED\"   > The following attributes are available in the card and template elements.  Attributes onenterforward=HREF The onenterforward event occurs when the user causes the user agent to navigate into a card using a go task. onenterbackward=HREF The onenterbackward event occurs when the user causes the user agent to navigate into a card using a prev task. ontimer=HREF The ontimer event occurs when a timer expires. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 43 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.5.2 The Card Element <!ELEMENT card (onevent*, timer?, (do | p | pre)*)> <!ATTLIST card   title           %vdata;       #IMPLIED   newcontext      %boolean;     \"false\"   ordered         %boolean;     \"true\"   xml:lang        NMTOKEN       #IMPLIED   %cardev;   %coreattrs;   > The card element is a container of text and input elements that is sufficiently flexible to allow presentation and layout in a wide variety of devices, with a wide variety of display and input characteristics.  The card element indicates the general layout and required input fields, but does not overly constrain the user agent implementation in the areas of layout or user input.  For example, a card can be presented as a single page on a large-screen device and as a series of smaller pages on a small-screen device. A card can contain markup, input fields and elements indicating the structure of the card.  The order of elements in the card is significant and should be respected by the user agent.  A card's id may be used as a fragment anchor.  See section 5.2 for more information. Attributes title=vdata The title attribute specifies advisory information about the card. The title may be rendered in a variety of ways by the user agent (e.g., suggested bookmark name, pop-up tooltip, etc.). newcontext=boolean This attribute indicates that the current browser context should be re-initialised upon entry to this card.  See section 10.2 for more information. ordered=boolean This attribute specifies a hint to the user agent about the organisation of the card content.  This hint may be used to organise the content presentation or to otherwise influence layout of the card. • ordered=\"true\" - the card is naturally organised as a linear sequence of field elements, e.g., a set of questions or fields which are naturally handled by the user in the order in which they are specified in the group.  This style is best for short forms in which no fields are optional (e.g., sending an email message requires a To: address, a subject and a message, and they are logically specified in this order). It is expected that in small-screen devices, ordered groups may be presented as a sequence of screens, with a screen flip in between each field or fieldset.  Other user agents may elect to present all fields simultaneously. • ordered=\"false\" - the card is a collection of field elements without a natural order.  This is useful for collections of fields containing optional or unordered components or simple record data where the user is updating individual input fields. It is expected that in small-screen devices, unordered groups may be presented by using a hierarchical or tree organisation.  In these types of presentation, the title attribute of each field and fieldset may be used to define the name presented to the user in the top-level summary card.  A user agent may organise an unordered collection of elements in an ordered fashion. The user agent may interpret the ordered attribute in a manner appropriate to its device capabilities (e.g., screen size or input device).  In addition, the user agent should adopt user interface conventions for handling the editing of input elements in a manner that best suits the device's input model. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 44 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedFor example, a phone-class device displaying a card with ordered=\"false\" may use a softkey or button to select individual fields for editing or viewing.  A PDA-class device might create soft buttons on demand, or simply present all fields on the screen for direct manipulation. On devices with limited display capabilities, it is often necessary to insert screen flips or other user-interface transitions between fields.  When this is done, the user agent needs to decide on the proper boundary between fields.  User agents may use the following heuristic for determining the choice of a screen flip location: • fieldset defines a logical boundary between fields. • Fields (e.g., input) may be individually displayed.  When this is done, the line of markup (flow) immediately preceding the field should be treated as a field prompt and displayed with the input element.  The table must be treated differently than input and select.  The user agent must insert a line break before each table element, except when it is the first non-whitespace markup in a card.  The user agent must insert a line break after each table element, except when it is the final element in a card. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) • onenterforward (see section 11.5.1) • onenterbackward (see section 11.5.1) • ontimer (see section 11.5.1) 11.5.2.1 A Card Example The following is an example of a simple card element embedded within a WML deck.  The card contains text, which is displayed by the user agent.  In addition, the example demonstrates the use of a simple DO element, defined at the deck level.  <wml>   <template>    <do type=\"accept\" label=\"Exit\">     <prev/>    </do>   </template>   <card>    <p>     Hello World!    </p>   </card>  </wml> 11.6 Control Elements 11.6.1 The Tabindex Attribute Attributes tabindex=number This attribute specifies the tabbing position of the current element.  The tabbing position indicates the relative order in which elements are traversed when tabbing within a single WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 45 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedWML card.  A numerically greater tabindex value indicates an element that is later in the tab sequence than an element with a numerically lesser tabindex value. Each input element (i.e., input and select) in a card is assigned a position in the card's tab sequence.  In addition, the user agent may assign a tab position to other elements.  The tabindex attribute indicates the tab position of a given element.  Elements that are not designated with an author-specified tab position may be assigned one by the user agent.  User agent specified tab positions must be later in the tab sequence than any author-specified tab positions. Tabbing is a navigational accelerator and is optional for all user agents.  Authors must not assume that a user agent implements tabbing. 11.6.2 Select Lists Select lists are an input element that specifies a list of options for the user to choose from.  Single and multiple choice lists are supported. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 46 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.6.2.1 The Select Element <!ELEMENT select (optgroup|option)+> <!ATTLIST select   title        %vdata;           #IMPLIED   name         NMTOKEN           #IMPLIED   value        %vdata;           #IMPLIED   iname        NMTOKEN           #IMPLIED   ivalue       %vdata;           #IMPLIED   multiple     %boolean;         \"false\"   tabindex     %number;          #IMPLIED   xml:lang     NMTOKEN           #IMPLIED   %coreattrs;   > The select element lets users pick from a list of options. Each option is specified by an option element.  Each option element may have one line of formatted text (which may be wrapped or truncated by the user agent if too long).  Option elements may be organised into hierarchical groups using the optgroup element. Attributes multiple=boolean This attribute indicates that the select list should accept multiple selections.  When not set, the select list should only accept a single selected option. name=nmtoken value=vdata This name attribute indicates the name of the variable to set with the result of the selection.  The variable is set to the string value of the chosen option element, which is specified with the value attribute. The name variable's value is used to pre-select options in the select list. The value attribute indicates the default value of the variable named in the name attribute.  When the element is displayed, and the variable named in the name attribute is not set, the name variable may be assigned the value specified in the value attribute, depending on the values defined in iname and ivalue.  If the name variable already contains a value, the value attribute is ignored. Any application of the default value is done before the list is pre-selected with the value of the name variable. If this element allows the selection of multiple options, the result of the user's choice is a list of all selected values, separated by the semicolon character.  The name variable is set with this result.  In addition, the value attribute is interpreted as a semicolon-separated list of pre-selected options. iname=nmtoken ivalue=vdata The iname attribute indicates the name of the variable to be set with the index result of the selection.  The index result is the position of the currently selected option in the select list.  An index of zero indicates that no option is selected.  Index numbering begins at one and increases monotonically. The ivalue attribute indicates the default-selected option element. When the element is displayed, if the variable named in the iname attribute is not set, it is assigned the default-selected entry. If the variable already contains a value, the ivalue attribute is ignored. If the iname attribute is not specified, the ivalue value is applied every time the element is displayed. If this element allows the selection of multiple options, the index result of the user's choice is a list of the indices of all the selected options, separated by the semicolon character WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 47 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved(e.g., \"1;2\").  The iname variable is set with this result.  In addition, the ivalue attribute is interpreted as a semicolon-separated list of pre-selected options (e.g., \"1;4\"). title=vdata This attribute specifies a title for this element, which may be used in the presentation of this object. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) • tabindex (see section 11.6.1) On entry into a card containing a select element, the user agent must select the initial option element’s options and update associated variables (specified by the name or iname attributes) in the following manner. If the card contains multiple select elements, or input elements along with select elements, the initialisation must take place in the order that the elements appear in the card. Note that values are a semicolon delimited list of values when multiple=\"true\", but are otherwise treated as a single value (even if they contain semicolons).  In addition, the default option index is an aggregate value (a list) when multiple=\"true\" and is otherwise a single index. The selection of initial option elements includes an operation named validate.  This operates on a value, and determines if that value is a legal option index (or indices when multiple=\"true\").  The operation consists of the following steps: 1. Remove all non-integer indices from the value. 2. Remove all out-of-range indices from the value, where out-of-range is defined as any index with a value greater than the number of options in the select or with a value less than one. 3. Remove duplicate indices Note that an invalid index will result in an empty value. The selection of the initial option elements consists of the following steps: Step 1 - the default option index is determined using iname and ivalue: • IF the iname attribute is specified AND names a variable that is set, THEN the default option index is the validated value of that variable. • IF the default option index is empty AND the ivalue attribute is specified, THEN the default option index is the validated attribute value. • IF the default option index is empty, AND the name attribute is specified AND the name attribute names a variable that is set, THEN for each value in the name variable that is present as a value in the select's option elements, the index of the first option element containing that value is added to the default index if that index has not been previously added. • IF the default option index is empty AND the value attribute is specified THEN for each value in the value attribute that is present as a value in the select's option elements, the index of the first option element containing that value is added to the default index if that index has not been previously added. • IF the default option index is empty AND the select is a multi-choice, THEN the default option index is set to zero. • IF the default option index is empty AND the select is a single-choice, THEN the default option index is set to one. Step 2 – initialise variables • IF the name attribute is specified AND the select is a single-choice element, THEN the named variable is set with the value of the value attribute on the option element at the default option index. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 48 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved• Else, IF the name attribute is specified and the select is a multiple-choice element, THEN for each index greater than zero, the value of the value attribute on the option element at the index is added to the name variable. • IF the iname attribute is specified, THEN the named variable is set with the default option index. Step 3 – pre-select option(s) specified by the default option index • Deselect all options • For each index greater than zero, select the option specified by the index. When the user selects or deselects one or more option elements, the name and iname variables are updated with the option's value and index.  The name is unset if all selected option elements contain an empty value attribute.  However, in all cases, the user agent must not exhibit display side effects as a result of updating name and iname variables, except when there is an explicit refresh task (see section 9.4.3).  The user agent must update name and iname variables (if specified) for each select element in the card before each and all task invocations according to steps 1 and 2 above. Multiple choice selection lists result in a value that is a semicolon delimited list (e.g., \"dog;cat\").  This is not an ordered list and the user agent is free to construct the list in any order that is convenient.  Authors must not rely on a particular value ordering.  The user agent must ensure that the iname result contains no duplicate index values.  The name result must contain duplicate values in the situation where multiple selected option elements have the same value.  The name result must not contain empty values (e.g., \"cat;;dog\" is illegal). Conformance Rules: WML-C-43  select M 11.6.2.2 The Option Element <!ELEMENT option (#PCDATA | onevent)*> <!ATTLIST option   value      %vdata;    #IMPLIED   title      %vdata;    #IMPLIED   onpick     %HREF;     #IMPLIED   xml:lang   NMTOKEN    #IMPLIED   %coreattrs;   > This element specifies a single choice option in a select element. Attributes value=vdata The value attribute specifies the value to be used when setting the name variable.  When the user selects this option, the resulting value specified in the value attribute is used to set the select element's name variable. The value attribute may contain variable references, which are evaluated before the name variable is set. title=vdata This attribute specifies a title for this element, which may be used in the presentation of this object. onpick=HREF The onpick event occurs when the user selects or deselects this option.  A multiple-selection option list generates an onpick event whenever the user selects or deselects this option. A single-selection option list generates an onpick event when the user selects this option, i.e., no event is generated for the de-selection of any previously selected option. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 49 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAttributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-41  option M 11.6.2.3 The Optgroup Element <!ELEMENT optgroup (optgroup|option)+ > <!ATTLIST optgroup   title      %vdata;    #IMPLIED   xml:lang   NMTOKEN    #IMPLIED   %coreattrs;   > The optgroup element allows the author to group related option elements into a hierarchy.  Within a hierarchy, all leaf elements must be option elements (i.e., it is an error to build a hierarchy that contains a leaf optgroup element.  The user agent may use this hierarchy to facilitate layout and presentation on a wide variety of devices.  The user agent may choose not to build a hierarchy effectively ignoring optgroup elements.  However, in all cases, the user agent must continue processes all the element’s children. Attributes title=vdata This attribute specifies a title for this element, which may be used in the presentation of this object. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-40  optgroup O WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 50 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.6.2.4 Select list examples In this example, a simple single-choice select list is specified.  If the user were to choose the \"Dog\" option, the variable \"X\" would be set to a value of \"D\".  <wml>   <card>    <p>     Please choose your favourite animal:     <select name=\"X\">      <option value=\"D\">Dog</option>      <option value=\"C\">Cat</option>     </select>    </p>   </card>  </wml> In this example, a single choice select list is specified.  If the user were to choose the \"Cat\" option, the variable \"I\" would be set to a value of \"2\".  In addition, the \"Dog\" option would be pre-selected if the \"I\" variable had not been previously set.  <wml>   <card>    <p>     Please choose your favourite animal:     <select iname=\"I\" ivalue=\"1\">      <option value=\"D\">Dog</option>      <option value=\"C\">Cat</option>     </select>    </p>   </card>  </wml> In this example, a multiple-choice list is specified.  If the user were to choose the \"Cat\" and \"Horse\" options, the variable \"X\" would be set to \"C;H\" and the variable \"I\" would be set to \"2;3\".  In addition, the \"Dog\" and \"Cat\" options would be pre-selected if the variable \"I\" had not been previously set.  <wml>   <card>    <p>    Please choose <i>all</i> of your favourite animals:    <select name=\"X\" iname=\"I\" ivalue=\"1;2\" multiple=\"true\">     <option value=\"D\">Dog</option>     <option value=\"C\">Cat</option>     <option value=\"H\">Horse</option>    </select>    </p>   </card>  </wml> In this example, a single choice select list is specified. The variable \"F\" would be set to the value of \"S\" if the user chooses the first option.  The second option is always pre-selected, regardless of the value of the variable \"F\". WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 51 (84)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved <wml>   <card>    <p>    Please choose from the menu:    <select name=\"F\" ivalue=\"2\">     <option value=\"S\">Sandwich</option>     <option value=\"D\">Drink</option>    </select>    </p>   </card>  </wml> In this example, the use of the onpick intrinsic event is demonstrated.  If the user selects the second option, a go will be performed to the ”/morehelp.wml” URL.  <wml>   <card>    <p>    Select type of help:    <select>     <option onpick=\"/help.wml\">Help</option>     <option onpick=\"/morehelp.wml\">More Help</option>    </select>    </p>   </card>  </wml> In this example, if the name variable is set to the value \"1;2\", the third option will be pre-selected.  This demonstrates that values containing semicolons are treated as a single value in a single-choice selection element.  <wml>   <card>    <p>    Select one:    <select name=\"K\">     <option value=\"1\">One</option>     <option value=\"2\">Two</option>     <option value=\"1;2\">Both</option>    </select>    </p>   </card>  </wml> 11.6.3 The Input Element <!ELEMENT input EMPTY> <!ATTLIST input   name       NMTOKEN           #REQUIRED   type       (text|password)   \"text\"   value      %vdata;           #IMPLIED   format     CDATA             #IMPLIED   emptyok    %boolean;         #IMPLIED   size       %number;          #IMPLIED   maxlength  %number;          #IMPLIED   tabindex   %number;          #IMPLIED   title      %vdata;           #IMPLIED   accesskey  %vdata;           #IMPLIED WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 52 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  xml:lang   NMTOKEN           #IMPLIED   %coreattrs;   > The input element specifies a text entry object. The user’s input is constrained by the combination of the optional format and emptyok attributes.  If a valid input mask is bound to an input object, the user agent must ensure that any value collected by the entry object conforms to the bound input mask when the user attempts to commit the value.  If the input collected does not conform to the input mask, the user agent must not commit that input and must notify the user that the input was rejected and allow the user to resubmit new input.  In this case, the variable specified in the name attribute must not be modified from its original value.  The user agent may validate each character against the input mask as the user enters it. All input objects that represent the input elements (and select elements, if any) within the card must be initialised when the card is rendered, and the initialisation must take place in the order that the elements appear in the card.  The initialisation must be done with the following two steps: • The user agent decides the initial value from the name and value attributes, and if needed sets or unsets the variable specified in the name attribute (see attributes description below). • The user agent pre-loads the initial value into the input object (e.g., renders the initial value into the text entry object). If the user clears the initial value of an input object and attempts to commit that input, it is regarded as a submission of an empty string.  The user agent must accept the submission of an empty string only when the input mask allows an empty string. Attributes name=nmtoken value=vdata The name attribute specifies the name of the variable to set with the result of the user's text input.  The name variable's value is used as the initial value of the input object.  If the name variable contains a value that does not conform to the input mask, the user agent must unset the variable and attempt to initialise the variable with the value attribute. The value attribute indicates the default value of the variable named in the name attribute.  When the element is displayed and the variable named in the name attribute is not set, the name variable is assigned the value specified in the value attribute.  If the name variable already contains a value, the value attribute is ignored. If the value attribute specifies a value that does not conform to the input mask specified by the format attribute, the user agent must ignore the value attribute. In the case where no valid value can be established, the name variable is left unset and the input object must be initialised with the empty string. type=(text|password) This attribute specifies the type of text-input area.  The default type is text.  The following values are allowed: • text - a text entry control.  User agents should echo the input in a manner appropriate to the user agent and the input mask.  If the submitted value conforms to an existing input mask, the user agent must store that input unaltered and in its entirety in the variable named in the name attribute.  For example, the user agent must not trim the input by removing leading or trailing white space from the input. If the variable named by the name attribute is unset, the user agent should echo an empty string in an appropriate manner. • password - a text entry control. Input of each character should be echoed in an obscured or illegible form in a manner appropriate to the user agent.  For example, visual user agents may elect to display an asterisk in place of a character entered by WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 53 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedthe user.  Typically, the password input mode is indicated for password entry or other private data.  Note that Password input is not secure and should not be depended on for critical applications.  Similar to a text type, if the submitted value conforms to an existing input mask, the user agent must store input unaltered and in its entirety in the variable named in the name attribute.  User agents should not obscure non-formatting characters of the input mask.  If the variable named by the name attribute is unset, the user agent should echo an empty string in an appropriate manner. format=cdata The format attribute specifies an input mask for user input entries. The string consists of mask control characters and static text that is displayed in the input area.  The user agent may use the format mask to facilitate accelerated data input (e.g. the user agent may change its input mode according to the format code of the current position of the input cursor).  An input mask is only valid when it contains only legal format codes and static text.  User agents must ignore invalid masks. Character categories are as defined by [Unicode]: • “Letter” refers to character categories Lu, Ll, Lm, and Lo. • “Uppercase letter” refers to character categories Lu and Lm. • “Lowercase letter” refers to character categories Ll and Lm. • “Numeric character” refers to the character category Nd. • “Punctuation” refers to character categories Pc, Pd, Ps, Pe, and Po. • “Symbol” refers to character categories Sm, Sc, Sk, and So. User agents need only be capable of displaying and accepting the subsets of the above sets that are appropriate for all languages that they support.  However, all user agents must support ASCII graphic characters of the Unicode Basic Latin block (U+0020 – U+007E). For a given input element, user agents may choose to restrict the set of allowable characters to those appropriate for the current language(s). The current languages are the superset of: • the current language of the WML deck, plus • the user agent’s accept language(s), plus • the user agent’s interface language. In caseless languages, format codes distinguishing between upper and lowercase are equivalent. The format control characters specify the data format expected to be entered by the user. The default format is \"*M\".  The format codes are: A entry of any uppercase letter, symbol, or punctuation character.  Numeric characters are excluded. a entry of any lowercase letter, symbol, or punctuation character.  Numeric characters are excluded. N entry of any numeric character. n entry of any numeric, symbol, or punctuation character. X entry of any uppercase letter, numeric character, symbol, or punctuation character. x entry of any lowercase letter, numeric character, symbol, or punctuation character. M entry of any character valid in the current languages, including any letter, numeric, symbol, or punctuation character.  If the language supports case and the hardware supports both upper and lower case entry, the user agent may choose to default to uppercase entry mode but must allow entry of any character. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 54 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedm entry of any character valid in the current languages, including any letter, numeric, symbol, or punctuation character. If the language supports case and the hardware supports both upper and lower case entry, the user agent may choose to default to lowercase entry mode but must allow entry of any character. *f  entry of any number of characters; f is one of the above format codes and specifies what kind of characters can be entered.  Note: This format may only be specified once and must appear at the end of the format string. nf entry of up to n characters where n is from 1 to 9; f is one of the above format codes (other than *f format code) and specifies what kind of characters can be entered.  Note: This format may only be specified once and must appear at the end of the format string. \\c display the next character, c, in the entry field; allows escaping of the format codes as well as introducing non-formatting characters so they can be displayed in the entry area.  Escaped characters are considered part of the input's value, and must be preserved by the user agent.  For example, the stored value of the input \"12345-123\" having a mask \"NNNNN\\-3N\" is \"12345-123\" and not \"12345123\".  Similarly, if the value of the variable named by the name attribute is \"12345123\" and the mask is \"NNNNN\\-3N\", the user agent must unset the variable since it does not conform to the mask. emptyok=boolean The emptyok attribute indicates whether this input element accepts empty input or not.  If emptyok is true, input is not required even if the format mask would otherwise require it.  If emptyok is false, input is required even if the format mast would otherwise not require it. If the author does not explicitly specify the emptyok attribute, the format attribute fully defines the input requirement. The implied value of the emptyok attribute is “true” when the format attribute allows empty input (i.e., the format mask is implied or a “*f” format code). Otherwise, the implied value of the attribute is “false”. Whether or not input is required, any input given must match the format specification. For the following input elements, input is required: <input name=”x” format=”M*M”/>        <!-- implied: emptyok=”false” --> <input name=”x” emptyok=”false”/>         <!-- implied: format=”*M” --> <input name=”x” emptyok=”false” format=”M*M”/> <input name=”x” emptyok=”false” format=”*M”/> For the following input elements, input is not required: <input name=”x”/>          <!-- implied: format=”*M” emptyok=”true” --> <input name=”x” format=”*M”/>          <!-- implied: emptyok=”true” --> <input name=”x” emptyok=”true”/>          <!-- implied: format=”*M” --> <input name=”x” emptyok=”true” format=”M*M”/> <input name=”x” emptyok=”true” format=”*M”/> size=number This attribute specifies the width, in characters, of the text-input area.  The user agent may ignore this attribute. maxlength=number This attribute specifies the maximum number of characters that can be entered by the user in the text-entry area.  The default value for this attribute is an unlimited number of characters. title=vdata This attribute specifies a title for this element, which may be used in the presentation of this object. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 55 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAttributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) • tabindex (see section 11.6.1) • accesskey (see section 9.8) Conformance Rules: WML-C-33  input M 11.6.3.1 Input Element Examples In this example, an input element is specified.  This element accepts any characters and displays the input to the user in a human-readable form.  The maximum number of character entered is 32 and the resulting input is assigned to the variable named X.  <input name=\"X\" type=\"text\" maxlength=\"32\"/> The following example requests input from the user and assigns the resulting input to the variable name.  The text field has a default value of \"Robert\".  <input name=\"NAME\" type=\"text\" value=\"Robert\"/> The following example is a card that prompts the user for a first name, last name and age.  <card>   <p>   First name: <input type=\"text\" name=\"first\"/><br/>   Last name: <input type=\"text\" name=\"last\"/><br/>   Age: <input type=\"text\" name=\"age\" format=\"*N\"/>   </p>  </card> 11.6.4 The Fieldset Element <!ELEMENT fieldset (%fields; | do)* > <!ATTLIST fieldset   title           %vdata;      #IMPLIED   xml:lang        NMTOKEN      #IMPLIED   %coreattrs;   > The fieldset element allows the grouping of related fields and text.  This grouping provides information to the user agent, allowing the optimising of layout and navigation.  Fieldset elements may nest, providing the user with a means of specifying behaviour across a wide variety of devices.  It is an error to include empty fieldset elements. See section 11.5.2 for information on how the fieldset element may influence layout and navigation.  If a user agent chooses to discard fieldsets, it must continue to process all its children. Attributes title=vdata This attribute specifies a title for this element, which may be used in the presentation of this object. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-28  fieldset O WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 56 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.6.4.1 Fieldset Element Examples The following example specifies a WML deck that requests basic identity and personal information from the user.  It is separated into multiple field sets, indicating the preferred field grouping to the user agent. <wml>  <card>   <p>    <do type=\"accept\">    <go href=\"/submit?f=$(fname)&amp;l=$(lname)&amp;s=$(sex)&amp;a=$(age)\"/>    </do>     <fieldset title=\"Name\">     First name:     <input type=\"text\" name=\"fname\" maxlength=\"32\"/>     <br/>     Last name:     <input type=\"text\" name=\"lname\" maxlength=\"32\"/>    </fieldset>     <fieldset title=\"Info\">     <select name=\"sex\">      <option value=\"F\">Female</option>      <option value=\"M\">Male</option>     </select>     <br/>     Age: <input type=\"text\" name=\"age\" format=\"*N\"/>    </fieldset>   </p>  </card> </wml> 11.7 The Timer Element <!ELEMENT timer EMPTY> <!ATTLIST timer   name       NMTOKEN           #IMPLIED   value      %vdata;           #REQUIRED   %coreattrs;   > The timer element declares a card timer, which exposes a means of processing inactivity or idle time.  The timer is initialised and started at card entry and is stopped when the card is exited.  Card entry is any task or user action that results in the card being activated, for example, navigating into the card.  Card exit is defined as the execution of any task (see sections 9.5 and 12.5).  The value of a timer will decrement from the initial value, triggering the delivery of an ontimer intrinsic event on transition from a value of one to zero.  If the user has not exited the card at the time of timer expiration, an ontimer intrinsic event is delivered to the card. Timer resolution is implementation dependent.  The interaction of the timer with the user agent's user interface and other time-based or asynchronous device functionality is implementation dependent.  It is an error to have more than one timer element in a card. The timer timeout value is specified in units of one-tenth (1/10) of a second.  The author should not expect a particular timer resolution and should provide the user with another means to invoke a timer's task. If the value of the timeout is not a positive integral number, the user agent must ignore the timer element.  A timeout value of zero (0) disables the timer. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 57 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedInvoking a refresh task is considered an exit.  The task stops the timer, commits it’s value to the context, and updates the user agent accordingly. Completion of the refresh task is considered an entry to the card.  At that time, the timer must resume. Attributes name=nmtoken The name attribute specifies the name of the variable to be set with the value of the timer. The name variable's value is used to set the timeout period upon timer initialisation.  The variable named by the name attribute will be set with the current timer value when the card is exited or when the timer expires.  For example, if the timer expires, the name variable is set to a value of \"0\". value=vdata The value attribute indicates the default value of the variable named in the name attribute.  When the timer is initialised and the variable named in the name attribute is not set, the name variable is assigned the value specified in the value attribute.  If the name variable already contains a value, the value attribute is ignored.  If the name attribute is not specified, the timeout is always initialised to the value specified in the value attribute. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-48  timer M 11.7.1 Timer Example The following deck will display a text message for approximately 10 seconds and will then go to the URL next. <wml>  <card ontimer=\"/next\">   <timer value=\"100\"/>   <p>   Hello World!   </p>  </card> </wml>  The same example could be implemented as: <wml>  <card>   <onevent type=”ontimer\">    <go href=”/next”/>   </onevent>   <timer value=\"100\"/>   <p>   Hello World!   </p>  </card> </wml>  The following example illustrates how a timer can initialise and reuse a counter.  Each time the card is entered, the timer is reset to value of the variable t.  If t is not set, the timer is set to a value of 5 seconds. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 58 (85)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved<wml>  <card ontimer=”/next\">   <timer name=”t” value=\"50\"/>   <p>   Hello World!   </p>  </card> </wml> 11.8 Text This section defines the elements and constructs related to text. 11.8.1 White Space WML white space and line break handling is based on [XML] and assumes the default XML white space handling rules for text.  The WML user agent ignores all insignificant white space in elements and attribute values, as defined by the XML specification. White space immediately before and after an element is ignored. In addition, all other sequences of white space must be compressed into a single inter-word space. User agents should treat inter-word spaces in a locale-dependent manner, as different written languages treat inter-word spacing in different ways. 11.8.2 Emphasis <!ELEMENT em     (%flow;)*> <!ATTLIST em   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > <!ELEMENT strong (%flow;)*> <!ATTLIST strong   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > <!ELEMENT i      (%flow;)*> <!ATTLIST i   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > <!ELEMENT b      (%flow;)*> <!ATTLIST b   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > <!ELEMENT u      (%flow;)*> <!ATTLIST u   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > <!ELEMENT big    (%flow;)*> <!ATTLIST big   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > <!ELEMENT small  (%flow;)*> <!ATTLIST small WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 59 (86)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > The emphasis elements specify text emphasis markup information. em: Render with emphasis. strong: Render with strong emphasis. i: Render with an italic font. b: Render with a bold font. u: Render with underline. big: Render with a large font. small: Render with a small font. Authors should use the strong and em elements where possible.  The b, i and u elements should not be used except where explicit control over text presentation is required. Visual user agents must distinguish emphasised text from non-emphasised text.  A user agent should do a best effort to distinguish the various forms of emphasised text as described above.  It should distinguish text that has been emphasised using the em element from that using strong element.  User agents may use the same style for strong, b, and big emphasis.  It may also use the same style for em, i, u, and small emphasis. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-22  b O WML-C-23  big O WML-C-27  em O WML-C-31  i O WML-C-44  small O WML-C-45  strong O WML-C-51  u O 11.8.3 Paragraphs <!ENTITY % TAlign \"(left|right|center)\"> <!ENTITY % WrapMode \"(wrap|nowrap)\" > <!ELEMENT p (%fields; | do)*> <!ATTLIST p   align       %TAlign;     \"left\"   mode        %WrapMode;   #IMPLIED   xml:lang    NMTOKEN      #IMPLIED   %coreattrs;   > WML has two line-wrapping modes for visual user agents: breaking (or wrapping) and non-breaking (or non-wrapping).  The treatment of a line too long to fit on the screen is specified by the current line-wrap mode.  If mode=\"wrap\" is specified, the line is word-wrapped onto multiple lines. In this case, line breaks should be inserted into a text flow as appropriate for presentation on an individual device. If mode=\"nowrap\" is specified, the line is not automatically wrapped. In this case, the user agent must provide a mechanism to view entire non-wrapped lines (e.g., horizontal scrolling or some other user-agent-specific mechanism). Any inter-word space is a legal line break point.  The non-breaking space entity (&nbsp; or &#160;) indicates a space that must not be treated as an inter-word space by the user agent.  WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 60 (86)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAuthors should use &nbsp; to prevent undesired line-breaks.  The soft-hyphen character entity (&shy; or &#173;) indicates a location that may be used by the user agent for a line break.  If a line break occurs at a soft-hyphen, the user agent must insert a hyphen character (&#45;) at the end of the line.  In all other operations, the soft-hyphen entity should be ignored.  A user agent may choose to entirely ignore soft-hyphens when formatting text lines. The p element establishes both the line wrap and alignment parameters for a paragraph.  If the text alignment is not specified, it defaults to left. If the line-wrap mode is not specified, it is identical to the line-wrap mode of the previous paragraph in the current card. Empty paragraphs (i.e., an empty element or an element with only insignificant white space) should be considered as insignificant and ignored by visual user agents.  Insignificant paragraphs do not impact line-wrap mode.  If the first p element in a card does not specify a line-wrap or alignment mode, that mode defaults to the initial mode for the card.  The user agent must insert a line break into the text flow between significant p elements. Insignificant paragraphs may be removed before the document is delivered to the user agent. Attributes align=(left|right|center) This attribute specifies the text alignment mode for the paragraph.  Text can be centre aligned, left aligned or right aligned when it is displayed to the user.  Left alignment is the default alignment mode.  If not explicitly specified, the text alignment is set to the default alignment. mode=(wrap|nowrap) This attribute specifies the line-wrap mode for the paragraph.  Wrap specifies breaking text mode and nowrap specifies non-breaking text mode.  If not explicitly specified, the line-wrap mode is identical to the line-wrap mode of the previous paragraph in the text flow of a card.  The default mode for the first paragraph in a card is wrap.   Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-36  p M 11.8.4 The Br Element <!ELEMENT br EMPTY> <!ATTLIST br   %coreattrs;   > The br element establishes the beginning of a new line.  The user agent must break the current line and continue on the following line. User agents should do best effort to support the br element in tables (see section 11.8.7). Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-24  br M 11.8.5 The Table Element <!ELEMENT table (tr)+> WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 61 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved<!ATTLIST table   title       %vdata;    #IMPLIED   align       CDATA      #IMPLIED   columns     %number;   #REQUIRED   xml:lang    NMTOKEN    #IMPLIED   %coreattrs;   > The table element is used together with the tr and td elements to create sets of aligned columns of text and images in a card. Nesting of table elements it not allowed. The table elements determine the structure of the columns. The elements separate content into columns, but do not specify column or intercolumn widths. The user agent should do its best effort to present the information of the table in a manner appropriate to the device. Attributes title=vdata This attribute specifies a title for this element, which may be used in the presentation of this object. align=cdata This attribute specifies the layout of text and images within the columns of a table.  A column’s contents can be centre aligned, left aligned or right aligned when it is rendered to the user.  The attribute value is interpreted as a non-separated list of alignment designations, one for each column.  Centre alignment is specified with the value “C”, left alignment is specified with the value “L”, right alignment is specified with the value “R”, and default alignment is specified with the value “D”. Designators are applied to columns as they are defined in the content.  The first designator in the list applies to the first column, the second designator to the second column, and so forth.  Default alignment is applied to columns that are missing alignment designators or have unrecognised designators.  All extra designators are ignored.  Determining the default alignment is implementation dependent.  User agents should consider the current language when determining the default alignment and the direction of the table.  A user agent may use other algorithms to make such decisions. columns=number This required attribute specifies the number of columns for the table.  The user agent must create a table with exactly the number of columns specified by the attribute value.  It is an error to specify a value of zero (“0”). If  the  actual  number  of  columns  in  a  row  is  less  than  the  value  specified  by  the  columns  attribute,  the  row  must  be  padded  with  empty  columns  effectively  as  if  the  user  agent  appended empty td elements to the row. If the actual number of columns in a row is greater than the value specified by this attribute, the  extra  columns  of  the  row  must  be  aggregated  into  the  last  column  such  that  the  row  contains  exactly  the  number  of  columns  specified.    A  single  inter-word  space  must  be  inserted between two cells that are being aggregated. The presentation of the table is likely to depend on the display characteristics of the device.  WML does not define how a user agent renders a table.  User agents may create aligned columns for each table, or it may use a single set of aligned columns for all tables in a card.  User agents that choose to render a table in a traditional tabular manner should determine the width of each column from the maximum width of the text and images in that column to ensure  the  narrowest  display  width.  However,  user  agents  may  use  fixed  width  or  other  appropriate  layout  algorithms  instead.    User  agents  that  choose  to  render  tables  in  a traditional  tabular  manner  must  use  a  non-zero  width  gutter  to  separate  each  non-empty column. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 62 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAttributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-46  table M WML-S-68 The number of columns in a table must not be set to zero M WML-C-73 The number of columns in a table must not be set to zero O 11.8.6 The Tr Element <!ELEMENT tr (td)+> <!ATTLIST tr   %coreattrs;   > The tr element is used as a container to hold a single table row.  Table rows may be empty (i.e., all cells are empty).  Empty table rows are significant and must not be ignored. Attributes defined elsewhere • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-50  tr M 11.8.7 The Td Element <!ELEMENT td ( %text; | %layout; | img | anchor | a )*> <!ATTLIST td   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   > The td element is used as a container to hold a single table cell data within a table row.  Table data cells may be empty.  Empty cells are significant, and must not be ignored.  The user agent should do a best effort to deal with multiple line data cells that may result from using images or line breaks. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-49  td M 11.8.8 Table Example The following example contains a card with a single column group, containing two columns and three rows. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 63 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved<wml>  <card>   <p>    <table columns=\"2\" align=\"LL\">     <tr><td>One </td><td> Two </td></tr>     <!-- row missing cells -->     <tr><td>1</td></tr>     <!-- row with too many cells -->     <tr><td/><td> B </td><td>C<br/>D</td></tr>   </table>   </p>  </card> </wml> An acceptable layout for this card is: One   Two 1     B C     D WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 64 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved11.8.9 The Pre Element <!ELEMENT pre \"(#PCDATA | a | anchor | do | u | br | i | b | em |                  strong | input | select )*\"> <!ATTLIST pre   xml:space    CDATA    #FIXED \"preserve\"   %coreattrs;   > The pre element tells visual user agents that the enclosed text is \"preformatted\". When handling preformatted text, user agents: • May leave white space intact.  • May render text with a fixed-pitch font. • May disable automatic word wrap.  The user agent must make “best effort” to achieve the requirements above.  Conformance Rules: WML-C-75 pre O 11.9 Images <!ENTITY % IAlign \"(top|middle|bottom)\" > <!ELEMENT img EMPTY> <!ATTLIST img   alt        %vdata;      #REQUIRED   src        %HREF;       #REQUIRED   localsrc   %vdata;      #IMPLIED   vspace     %length;     \"0\"   hspace     %length;     \"0\"   align      %IAlign;     \"bottom\"   height     %length;     #IMPLIED   width      %length;     #IMPLIED   xml:lang   NMTOKEN      #IMPLIED   %coreattrs;   > The img element indicates that an image is to be included in the text flow.  Image layout is done within the context of normal text layout. Attributes alt=vdata This attribute specifies an alternative textual representation for the image.  This representation is used when the image can not be displayed using any other method (i.e., the user agent does not support images, or the image contents can not be found). src=HREF This attribute specifies the URI for the image.  If the browser supports images, it downloads the image from the specified URI and renders it when the text is being displayed. localsrc=vdata This attribute specifies an alternative internal representation for the image.  This representation is used if it exists; otherwise the image is downloaded from the URI specified in the src attribute, i.e., any localsrc parameter specified takes precedence over the image specified in the src parameter. vspace=length hspace=length These attributes specify the amount of white space to be inserted to the left and right (hspace) and above and below (vspace) the image. The default value for this attribute is zero indicating that no white space should be inserted. If length is specified as a WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 65 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedpercentage value, the space inserted is based on the available horizontal or vertical space.  These attributes are hints to the user agent and may be ignored. align=(top|middle|bottom) This attribute specifies image alignment within the text flow and with respect to the current insertion point. align has three possible values: • bottom: means that the bottom of the image should be vertically aligned with the current baseline. This is the default value. • middle: means that the centre of the image should be vertically aligned with the centre of the current text line. • top: means that the top of the image should be vertically aligned with the top of the current text line. height=length width=length These attributes give user agents an idea of the size of an image or object so that they may reserve space for it and continue rendering the card while waiting for the image data. User agents may scale objects and images to match these values if appropriate.  If length is specified as a percentage value, the resulting size is based on the available horizontal or vertical space, not on the natural size of the image. These attributes are a hint to the user agent and may be ignored. Attributes defined elsewhere • xml:lang (see section 8.8) • id (see section 8.9) • class (see section 8.9) Conformance Rules: WML-C-32  img M WML-C-54 Display of alt attribute of <img>  M WML-C-55 Support for vspace hint  O WML-C-56 Support for hspace hint  O WML-C-57 Support for <img> align  O WML-C-58 Support for <img> height  O WML-C-59 Support for <img> width  O WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 66 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved12. User Agent Semantics Except where explicitly stated WML does not dictate how a user agent should render or display WML content.  The user agent is not obligated to perform any particular mapping of elements to user interface widgets, and the WML author should not rely on such. 12.1 Deck Access Control The introduction of variables into WML exposes potential security issues that do not exist in other markup languages such as HTML. In particular, certain variable state may be considered private by the user. While the user may be willing to send a private information to a secure service, an insecure or malicious service should not be able to retrieve that information from the user agent by other means. A conforming WML user agent must implement deck-level access control, including the access element and the sendreferer, domain and path attributes. A WML author should remove private or sensitive information from the browser context by clearing the variables containing this information. Conformance Rules: WML-C-14  Deck access control M 12.2 Low-Memory Behaviour WML is targeted at devices with limited hardware resources, including significant restrictions on memory size.  It is important that the author have a clear expectation of device behaviour in error situations, including those caused by lack of memory.  Conformance Rules: WML-C-15  Low-memory  O 12.2.1 Limited History The user agent may limit the size of the history stack (i.e., the depth of the historical navigation information). In the case of history size exhaustion, the user agent should delete the least-recently-used history information. It is recommended that all user agents implement a minimum history stack size of ten entries. 12.2.2 Limited Browser Context Size In some situations, it is possible that the author has defined an excessive number of variables in the browser context, leading to memory exhaustion. In this situation, the user agent should attempt to acquire additional memory by reclaiming cache and history memory as described in sections 12.2.1.  If this fails and the user agent has exhausted all memory, the user should be notified of the error, and the user agent should be reset to a predictable user state.  For example, the browser may be terminated or the context may be cleared and the browser reset to a well-known state. 12.3 Error Handling Conforming user agents must enforce error conditions defined in this specification and must not hide errors by attempting to infer author or origin server intent. Conformance Rules: WML-C-16  Error handling M WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 67 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved12.4 Unknown DTD A WML deck encoded with an alternate DTD may include elements or attributes that are not recognised by certain user agents.  In this situation, a user agent should render the deck as if the unrecognised tags and attributes were not present.  Content contained in unrecognised elements should be rendered. Conformance Rules: WML-C-17  Unknown DTD handling M 12.5 Reference Processing Behaviour - Inter-card Navigation The following process describes the reference model for inter-card traversal in WML. All user agents must implement this process, or one that is indistinguishable from it. Conformance Rules: WML-C-18  Inter-card navigation M 12.5.1 The Go Task The process of executing a go task comprises the following steps: 1. If the originating task contains setvar elements, the variable name and value in each setvar element is converted into a simple string by substituting all referenced variables.  The resulting collection of variable names and values is stored in temporary memory for later processing. See section 10.3.1 for more information on variable substitution. 2. The target URI is identified and fetched by the user agent. The URI attribute value is converted into a simple string by substituting all referenced variables. 3. The access control parameters for the fetched deck are processed as specified in section 11.3.1. 4. The destination card is located using the fragment name specified in the URI. a) If no fragment name was specified as part of the URI, the first card in the deck is the destination card. b) If a fragment name was identified and a card has a name attribute that is identical to the fragment name, then that card is the destination card. c) If the fragment name can not be associated with a specific card, the first card in the deck is the destination card. 5. The variable assignments resulting from the processing done in step #1 (the setvar element) are applied to the current browser context. 6. If the destination card contains a newcontext attribute, the current browser context is re-initialised as described in section 10.2. 7. The destination card is pushed onto the history stack. 8. If the destination card specifies an onenterforward intrinsic event binding, the task associated with the event binding is executed and processing stops.  See section 9.10 for more information. 9. If the destination card contains a timer element, the timer is started as specified in section 11.7. 10. The destination card is displayed using the current variable state and processing stops. 12.5.2 The Prev Task The process of executing a prev task comprises the following steps: 1. If the originating task contains setvar elements, the variable name and value in each setvar element is converted into a simple string by substituting all referenced variables.  The resulting WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 68 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedcollection of variable names and values is stored in temporary memory for later processing. See section 10.3.1 for more information on variable substitution. 2. The target URI is identified and fetched by the user agent.   The history stack is popped and the target URI is the top of the history stack.  If there is no previous card in the history stack, processing stops. 3. The destination card is located using the fragment name specified in the URI. a) If no fragment name was specified as part of the URI, the first card in the deck is the destination card. b) If a fragment name was identified and a card has a name attribute that is identical to the fragment name, then that card is the destination card. 4. The variable assignments resulting from the processing done in step #1 (the setvar element) are applied to the current browser context. 5. If the destination card specifies an onenterbackward intrinsic event binding, the task associated with the event binding is executed and processing stops.  See section 9.10 for more information. 6. If the destination card contains a timer element, the timer is started as specified in section 11.7. 7. The destination card is displayed using the current variable state and processing stops. 12.5.3 The Noop Task No processing is done for a noop task. 12.5.4 The Refresh Task The process of executing a refresh task comprises the following steps: 1. For each setvar element, the variable name and value in each setvar element is converted into a simple string by substituting all referenced variables. See section 10.3.1 for more information on variable substitution. 2. The variable assignments resulting from the processing done in step #1 (the setvar element) are applied to the current browser context. 3. If the card contains a timer element, the timer is started as specified in section 11.7. 4. The current card is re-displayed using the current variable state and processing stops. 12.5.5 Task Execution Failure If a task fails to fetch its target URI or the access control restrictions prevent a successful inter-card transition, the user agent must notify the user and take the following actions: • The invoking card remains the current card. • No changes are made to the browser context, including any pending variable assignments or newcontext processing. • No intrinsic event bindings are executed. WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 69 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved13. WML Reference Information WML is an application of [XML] version 1.0. 13.1 Document Identifiers 13.1.1 SGML Public Identifier -//WAPFORUM//DTD WML 1.3//EN 13.1.2 WML Media Type Textual form: text/vnd.wap.wml Tokenised form:  application/vnd.wap.wmlc WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 70 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved13.2 Document Type Definition (DTD) <!-- Wireless Markup Language (WML) Document Type Definition. WML is an XML language.  Typical usage:  <?xml version=\"1.0\"?>  <!DOCTYPE wml PUBLIC \"-//WAPFORUM//DTD WML 1.3//EN\"       \"http://www.wapforum.org/DTD/wml13.dtd\">  <wml>  ...  </wml> -->  <!ENTITY % length  \"CDATA\">    <!-- [0-9]+ for pixels or [0-9]+\"%\" for                                     percentage length --> <!ENTITY % vdata   \"CDATA\">    <!-- attribute value possibly containing                                     variable references --> <!ENTITY % HREF    \"%vdata;\">  <!-- URI, URL or URN designating a hypertext                                     node. May contain variable references --> <!ENTITY % boolean \"(true|false)\"> <!ENTITY % number  \"NMTOKEN\">  <!-- a number, with format [0-9]+ --> <!ENTITY % coreattrs  \"id    ID     #IMPLIED                         class CDATA  #IMPLIED\"> <!ENTITY % ContentType \"%vdata;\">  <!-- media type. May contain variable                                         references -->  <!ENTITY % emph    \"em | strong | b | i | u | big | small\"> <!ENTITY % layout  \"br\">  <!ENTITY % text     \"#PCDATA | %emph;\">  <!-- flow covers \"card-level\" elements, such as text and images --> <!ENTITY % flow     \"%text; | %layout; | img | anchor | a | table\">  <!-- Task types --> <!ENTITY % task   \"go | prev | noop | refresh\">  <!-- Navigation and event elements --> <!ENTITY % navelmts \"do | onevent\">  <!--================ Decks and Cards ================-->  <!ELEMENT wml ( head?, template?, card+ )> <!ATTLIST wml   xml:lang        NMTOKEN        #IMPLIED   %coreattrs;   >  <!-- card intrinsic events --> <!ENTITY % cardev  \"onenterforward  %HREF;          #IMPLIED   onenterbackward %HREF;          #IMPLIED   ontimer         %HREF;          #IMPLIED\"   >  <!-- card field types --> <!ENTITY % fields  \"%flow; | input | select | fieldset\"> WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 71 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved <!ELEMENT card (onevent*, timer?, (do | p | pre)*)> <!ATTLIST card   title           %vdata;       #IMPLIED   newcontext      %boolean;     \"false\"   ordered         %boolean;     \"true\"   xml:lang        NMTOKEN       #IMPLIED   %cardev;   %coreattrs;   >  <!--================ Event Bindings ================-->  <!ELEMENT do (%task;)> <!ATTLIST do   type         CDATA       #REQUIRED   label        %vdata;     #IMPLIED   name         NMTOKEN     #IMPLIED   optional     %boolean;   \"false\"   xml:lang     NMTOKEN     #IMPLIED   %coreattrs;   >  <!ELEMENT onevent (%task;)> <!ATTLIST onevent   type         CDATA       #REQUIRED   %coreattrs;   >  <!--================ Deck-level declarations ================-->  <!ELEMENT head ( access | meta )+> <!ATTLIST head   %coreattrs;   >  <!ELEMENT template (%navelmts;)*> <!ATTLIST template   %cardev;   %coreattrs;   >  <!ELEMENT access EMPTY> <!ATTLIST access   domain       CDATA       #IMPLIED   path         CDATA       #IMPLIED   %coreattrs;   >  <!ELEMENT meta EMPTY> <!ATTLIST meta   http-equiv     CDATA      #IMPLIED   name           CDATA      #IMPLIED   forua          %boolean;  \"false\"   content        CDATA      #REQUIRED   scheme         CDATA      #IMPLIED   %coreattrs;   > WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 72 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved <!--================ Tasks ================-->  <!ENTITY % cache-control “(no-cache)” > <!ELEMENT go (postfield | setvar)*> <!ATTLIST go   href            %HREF;          #REQUIRED   sendreferer     %boolean;       \"false\"   method          (post|get)      \"get\"   enctype         %ContentType;          \"application/x-www-form-urlencoded\"   cache-control   %cache-control; #IMPLIED   accept-charset  CDATA           #IMPLIED   %coreattrs;   >  <!ELEMENT prev (setvar)*> <!ATTLIST prev   %coreattrs;   >  <!ELEMENT refresh (setvar)*> <!ATTLIST refresh   %coreattrs;   >  <!ELEMENT noop EMPTY> <!ATTLIST noop   %coreattrs;   >  <!--================ postfield ================-->   <!ELEMENT postfield EMPTY> <!ATTLIST postfield   name         %vdata;           #REQUIRED   value        %vdata;           #REQUIRED   %coreattrs;   >  <!--================ variables ================-->  <!ELEMENT setvar EMPTY> <!ATTLIST setvar   name         %vdata;           #REQUIRED   value        %vdata;           #REQUIRED   %coreattrs;   >  <!--================ Card Fields ================-->  <!ELEMENT select (optgroup|option)+> <!ATTLIST select   title        %vdata;           #IMPLIED   name         NMTOKEN           #IMPLIED   value        %vdata;           #IMPLIED   iname        NMTOKEN           #IMPLIED   ivalue       %vdata;           #IMPLIED WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 73 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  multiple     %boolean;         \"false\"   tabindex     %number;          #IMPLIED   xml:lang     NMTOKEN           #IMPLIED   %coreattrs;   >  <!ELEMENT optgroup (optgroup|option)+ > <!ATTLIST optgroup   title      %vdata;    #IMPLIED   xml:lang   NMTOKEN    #IMPLIED   %coreattrs;   >  <!ELEMENT option (#PCDATA | onevent)*> <!ATTLIST option   value      %vdata;    #IMPLIED   title      %vdata;    #IMPLIED   onpick     %HREF;     #IMPLIED   xml:lang   NMTOKEN    #IMPLIED   %coreattrs;   >  <!ELEMENT input EMPTY> <!ATTLIST input   name       NMTOKEN           #REQUIRED   type       (text|password)   \"text\"   value      %vdata;           #IMPLIED   format     CDATA             #IMPLIED   emptyok    %boolean;         #IMPLIED   size       %number;          #IMPLIED   maxlength  %number;          #IMPLIED   tabindex   %number;          #IMPLIED   title      %vdata;           #IMPLIED   accesskey  %vdata;           #IMPLIED   xml:lang   NMTOKEN           #IMPLIED   %coreattrs;   >  <!ELEMENT fieldset (%fields; | do)* > <!ATTLIST fieldset   title           %vdata;      #IMPLIED   xml:lang        NMTOKEN      #IMPLIED   %coreattrs;   >  <!ELEMENT timer EMPTY> <!ATTLIST timer   name       NMTOKEN           #IMPLIED   value      %vdata;           #REQUIRED   %coreattrs;   >  <!--================ Images ================-->  <!ENTITY % IAlign \"(top|middle|bottom)\" >  <!ELEMENT img EMPTY> <!ATTLIST img WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 74 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  alt        %vdata;      #REQUIRED   src        %HREF;       #REQUIRED   localsrc   %vdata;      #IMPLIED   vspace     %length;     \"0\"   hspace     %length;     \"0\"   align      %IAlign;     \"bottom\"   height     %length;     #IMPLIED   width      %length;     #IMPLIED   xml:lang   NMTOKEN      #IMPLIED   %coreattrs;   >  <!--================ Anchor ================-->  <!ELEMENT anchor ( #PCDATA | br | img | go | prev | refresh )*> <!ATTLIST anchor   title        %vdata;      #IMPLIED   accesskey    %vdata;      #IMPLIED   xml:lang     NMTOKEN      #IMPLIED   %coreattrs;   >  <!ELEMENT a ( #PCDATA | br | img )*> <!ATTLIST a   href         %HREF;       #REQUIRED   title        %vdata;      #IMPLIED   accesskey    %vdata;      #IMPLIED   xml:lang     NMTOKEN      #IMPLIED   %coreattrs;   >  <!--================ Tables ================-->  <!ELEMENT table (tr)+> <!ATTLIST table   title       %vdata;    #IMPLIED   align       CDATA      #IMPLIED   columns     %number;   #REQUIRED   xml:lang    NMTOKEN    #IMPLIED   %coreattrs;   >  <!ELEMENT tr (td)+> <!ATTLIST tr   %coreattrs;   >  <!ELEMENT td ( %text; | %layout; | img | anchor | a )*> <!ATTLIST td   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!--=============== Text layout and line breaks ===============-->  <!ELEMENT em     (%flow;)*> <!ATTLIST em   xml:lang        NMTOKEN       #IMPLIED WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 75 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  %coreattrs;   >  <!ELEMENT strong (%flow;)*> <!ATTLIST strong   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!ELEMENT b      (%flow;)*> <!ATTLIST b   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!ELEMENT i      (%flow;)*> <!ATTLIST i   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!ELEMENT u      (%flow;)*> <!ATTLIST u   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!ELEMENT big    (%flow;)*> <!ATTLIST big   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!ELEMENT small  (%flow;)*> <!ATTLIST small   xml:lang        NMTOKEN       #IMPLIED   %coreattrs;   >  <!ENTITY % TAlign \"(left|right|center)\"> <!ENTITY % WrapMode \"(wrap|nowrap)\" > <!ELEMENT p (%fields; | do)*> <!ATTLIST p   align       %TAlign;     \"left\"   mode        %WrapMode;   #IMPLIED   xml:lang    NMTOKEN      #IMPLIED   %coreattrs;   >  <!ELEMENT br EMPTY> <!ATTLIST br   %coreattrs;   >  <!ELEMENT pre \"(#PCDATA | a | anchor | do | u | br | i | b | em |                  strong | input | select )*\"> <!ATTLIST pre   xml:space    CDATA    #FIXED \"preserve\" WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 76 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved  %coreattrs;   >  <!ENTITY quot  \"&#34;\">     <!-- quotation mark --> <!ENTITY amp   \"&#38;#38;\"> <!-- ampersand --> <!ENTITY apos  \"&#39;\">     <!-- apostrophe --> <!ENTITY lt    \"&#38;#60;\"> <!-- less than --> <!ENTITY gt    \"&#62;\">     <!-- greater than --> <!ENTITY nbsp  \"&#160;\">    <!-- non-breaking space --> <!ENTITY shy   \"&#173;\">    <!-- soft hyphen (discretionary hyphen) -->  13.3 Reserved Words WML reserves the use of several strings for future uses.  These strings may not be used in any DTD or extension of WML.  The following words are reserved:    style WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 77 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved14. A Compact Binary Representation of WML WML may be encoded using a compact binary representation. This content format is based upon the WAP Binary XML Content Format [WBXML]. Conformance Rules: WML-S-60  WML token table M 14.1 Extension Tokens 14.1.1 Global Extension Tokens The [WBXML] global extension tokens are used to represent WML variables. Variable references may occur in a variety of places in a WML deck (see section 10.3). There are several codes that indicate variable substitution.  Each code has different escaping semantics (e.g., direct substitution, escaped substitution and unescaped substitution).  The variable name is encoded in the current document character encoding and must be encoded as the specified in the source document (e.g., variable names may not be shortened, mapped or otherwise changed).  For example, the global extension token EXT_I_0 represents an escaped variable substitution, with the variable name inline. 14.1.2 Tag Tokens WML defines a set of single-byte tokens corresponding to the tags defined in the DTD.  All of these tokens are defined within code page zero. 14.1.3 Attribute Tokens WML defines a set of single-byte tokens corresponding to the attribute names and values defined in the DTD.  All of these tokens are defined within code page zero. 14.2 Encoding Semantics 14.2.1 Encoding Variables All valid variable references must be converted to variable reference tokens (e.g., EXT_I_0).  The encoder must validate that a variable reference uses proper syntax.  The encoder should also validate that the placement of the variable reference within the WML deck is valid. 14.2.2 Encoding Tag and Attributes Names All tag and attribute names, for which binary token values are defined in this specification, must be tokenised, literal tokens must not be used. The user-agent must, however, treat literal and binary tokens as equivalent. See [WBXML].  Conformance Rules: WML-S-61  XML Well-formed M WML-S-62  XML Validation O 14.2.3 Document Validation XML document validation (see [XML]) should occur during the process of tokenising a WML deck and must be based on the DOCTYPE declared in the WML deck.  When validating the source text, WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 78 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedthe tokenisation process must accept any DOCTYPE or public identifier, if the document is identified as a WML media type (see section 13.1.2). The tokenisation process should notify the user of any well-formedness or validity errors detected in the source deck. 14.2.3.1 Validate %length; The WML tokenisation process should validate that attribute values defined as %length; contain either a NMTOKEN or a NMTOKEN followed by a percentage sign character.  For example, the following attributes are legal:  vspace=\"100%\"  hspace=\"123\" %length; data is encoded using normal attribute value encoding methods. 14.2.3.2 Validate %vdata; The WML tokenisation process must validate the syntax of all variable references within attribute values defined as %vdata; or %HREF; according to section 10.3.5.  It must also verify that other CDATA attribute values do not contain any variable references.  Attribute values not defined in the DTD must be treated as %vdata; and validated accordingly. 14.3 Numeric Constants 14.3.1 WML Extension Token Assignment The following global extension tokens are used in WML and occupy document-type-specific token slots in the global token range.  As with all tokens in the global range, these codes must be reserved in every code page.  All numbers are in hexadecimal. Table 4. Global extension token assignments Token Name Token Description EXT_I_0 40 Variable substitution - escaped.  Name of the variable is inline and follows the token as a termstr. EXT_I_1 41 Variable substitution - unescaped.  Name of the variable is inline and follows the token as a termstr. EXT_I_2 42 Variable substitution - no transformation.  Name of the variable is inline and follows the token as a termstr. EXT_T_0 80 Variable substitution - escaped.  Variable name encoded as a reference into the string table. EXT_T_1 81 Variable substitution - unescaped.  Variable name encoded as a reference into the string table. EXT_T_2 82 Variable substitution - no transformation.  Variable name encoded as a reference into the string table. EXT_0 C0 Reserved for future use. EXT_1 C1 Reserved for future use. EXT_2 C2 Reserved for future use. 14.3.2 Tag Tokens The following token codes represent tags in code page zero (0).   All numbers are in hexadecimal. Table 5. Tag tokens WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 79 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedTag Name Token a 1C anchor 22 access 23 b 24 big 25 br 26 card 27 do 28 em 29 fieldset 2A go 2B head 2C i 2D img 2E input 2F meta 30 noop 31 p 20 Tag Name Token postfield 21 pre 1B prev 32 onevent 33 optgroup 34 option 35 refresh 36 select 37 setvar 3E small 38 strong 39 table 1F td 1D template 3B timer 3C tr 1E u 3D wml 3F 14.3.3 Attribute Start Tokens The following token codes represent the start of an attribute in code page zero (0).  All numbers are in hexadecimal. Table 6. Attribute start tokensAttribute Name Attribute Value Prefix Token accept-charset  5 accesskey  5E align  52 align bottom 6 align center 7 align left 8 align middle 9 align right A align top B alt  C cache-control no-cache 64 class  54 columns  53 content  D content application/vnd.wap.wmlc;charset= 5C domain  F emptyok false 10 emptyok true 11 enctype  5F enctype application/x-www-form-urlencoded 60 Attribute Name Attribute Value Prefix Token enctype multipart/form-data 61 format  12 forua false 56 forua true 57 height  13 href  4A href http:// 4B href https:// 4C hspace  14 http-equiv  5A http-equiv Content-Type 5B http-equiv Expires 5D id  55 ivalue  15 iname  16 label  18 localsrc  19 maxlength  1A method get 1B method post 1C mode nowrap 1D mode wrap 1E multiple false 1F WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 80 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedAttribute Name Attribute Value Prefix Token multiple true 20 name  21 newcontext false 22 newcontext true 23 onenterbackward  25 onenterforward  26 onpick  24 ontimer  27 optional false 28 optional true 29 path  2A scheme  2E sendreferer false 2F sendreferer true 30 size  31 src  32 src http:// 58 src https:// 59 ordered true 33 ordered false 34 tabindex  35 title  36 Attribute Name Attribute Value Prefix Token type  37 type accept 38 type delete 39 type help 3A type password 3B type onpick 3C type onenterbackward 3D type onenterforward 3E type ontimer 3F type options 45 type prev 46 type reset 47 type text 48 type vnd. 49 value  4D vspace  4E width  4F xml:lang  50 xml:space preserve 62 xml:space default 63 14.3.4 Attribute Value Tokens The following token codes represent attribute values in code page zero (0). All numbers are in hexadecimal. Table 7. Attribute value tokensAttribute Value Token .com/ 85 .edu/ 86 .net/ 87 .org/ 88 accept 89 bottom 8A clear 8B delete 8C help 8D http:// 8E http://www. 8F https:// 90 https://www. 91 middle 93 Attribute Value Token nowrap 94 onenterbackward 96 onenterforward 97 onpick 95 ontimer 98 options 99 password 9A reset 9B text 9D top 9E unknown 9F wrap A0 Www. A1 WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 81 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved14.4 WML Encoding Examples Refer to [WBXML] for additional examples. The following is another example of a tokenised WML deck.  It demonstrates variable encoding, attribute encoding and the use of the string table.  Source deck: <wml>  <card id=\"abc\" ordered=\"true\">   <p>    <do type=\"accept\">     <go href=\"http://xyz.org/s\"/>    </do>    X: $(X)<br/>    Y: $(&#x59;)<br/>    Enter name: <input type=\"text\" name=\"N\"/>   </p>  </card> </wml> Tokenised form (numbers in hexadecimal) follows.  This example only uses inline strings and assumes that the character encoding uses a NULL terminated string format.  It also assumes that the character encoding is UTF-8: 02  08  6A  04  'X' 00  'Y' 00  7F  E7  55  03  'a' 'b' 'c' 00 33  01  60  E8  38  01  AB  4B  03  'x' 'y' 'z' 00  88  03 's' 00  01  01  03  ' ' 'X' ':' ' ' 00  82  00  26  03  ' ' 'Y' ':' ' ' 00  82  02  26  03  ' ' 'E' 'n' 't' 'e' 'r' ' ' 'n' 'a' 'm' 'e' ':' ' ' 00  AF  48  21  03  'N' 00  01  01  01  01 In an expanded and annotated form: Table 8. Example tokenised deck Token Stream Description 02 WBXML Version number 1.2 08 WML 1.2 Public ID 6A Charset=UTF-8 (MIBEnum 106) 04 String table length 'X', 00, 'Y', 00 String table 7F wml, with content E7 card, with content and attributes 55 id= 03 Inline string follows 'a', 'b', 'c', 00 string 33 ordered=\"true\" 01 END (of card attribute list) 60 p E8 do, with content and attributes 38 type=accept 01 END (of do attribute list) AB go, with attributes 4B href=\"http://\" 03 Inline string follows 'x', 'y', 'z', 00 string 88 \".org/\" 03 Inline string follows WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 82 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedToken Stream Description 's', 00 string 01 END (of go element) 01 END (of do element) 03 Inline string follows ' ', 'X', ':', ' ', 00 String 82 Direct variable reference (EXT_T_2) 00 Variable offset 0 26 br 03 Inline string follows ' ', 'Y', ':', ' ', 00 String 82 Direct variable reference (EXT_T_2) 02 Variable offset 2 26 br 03 Inline string follows ' ', 'E', 'n', 't', 'e', 'r', ' ', 'n', 'a', 'm', 'e', ':', ' ', 00 String AF input, with attributes 48 type=\"text\" 21 name= 03 Inline string follows 'N', 00 String 01 END (of input attribute list) 01 END (of p element) 01 END (of card element) 01 END (of wml element) WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 83 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved15. Static Conformance Statement This section defines the static conformance requirements for the WML user agent, documents, and encoder. 15.1 WML User Agent 15.1.1 Character Set and Encoding Item Function Reference Status Requirement WML-C-01 UTF-8 Encoding 6 O WML-C-02 UTF-16 Encoding 6 O  WML-C-03 UCS-4 Encoding 6 O  WML-C-04 Other character encoding 6 O  WML-C-05 Reference processing 6.1 M  WML-C-06 Character entities 6.2 M  15.1.2 Events and Navigation Item Function Reference Status Requirement WML-C-07 History 9.2 M  WML-C-08 Card/Deck task Shadowing 9.6 M  WML-C-09 Intrinsic Events 9.10 M  15.1.3 State Model Item Function Reference Status Requirement WML-C-10 Browser context 10.1 M  WML-C-11 Initialisation (newcontext) 10.2 M  WML-C-12 Variables 10.3 M  WML-C-13 Context restrictions 10.4 M  15.1.4 User Agent Semantics Item Function Reference Status Requirement WML-C-14 Deck access control 12.1 M  WML-C-15 Low-memory behaviour 12.2 O  WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 84 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedItem Function Reference Status Requirement WML-C-16 Error handling 12.3 M  WML-C-17 Unknown DTD handling 12.4 M  WML-C-18 Inter-card navigation 12.5 M  15.1.5 Elements If a user agent does not support an optional element, it should continue to process the children of the element. The children of an element include all elements and character data. Item Element Reference Status Requirement WML-C-19 a 9.9 M  WML-C-20 anchor 9.8 M  WML-C-21 access 11.3.1 M  WML-C-22 b 11.8.2 O  WML-C-23 big 11.8.2 O  WML-C-24 br 11.8.4 M  WML-C-25 card 11.5 M  WML-C-26 do 9.7 M  WML-C-27 em 11.8.2 O  WML-C-28 fieldset 11.6.4 O  WML-C-29 go 9.5.1 M  WML-C-30 head 11.3 M  WML-C-31 i 11.8.2 O  WML-C-32 img 11.9 M WML-C-54  WML-C-33 input 11.6.3 M  WML-C-34 meta 11.3.2 O  WML-C-35 noop 9.5.4 M  WML-C-36 p 11.8.3 M  WML-C-37 postfield 9.3 M  WML-C-75 pre 11.8.9 O  WML-C-38 prev 9.5.2 M  WML-C-39 onevent 9.10.1 M  WML-C-40 optgroup 11.6.2.3 O  WML-C-41 option 11.6.2.2 M  WML-C-42 refresh 9.5.3 M  WML-C-43 select 11.6.2.1 M  WML-C-44 small 11.8.2 O  WML-C-45 strong 11.8.2 O  WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 85 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedItem Element Reference Status Requirement WML-C-46 table 11.8.5 M  WML-C-47 template 11.4 M  WML-C-48 timer 11.7 M  WML-C-49 td 11.8.7 M  WML-C-50 tr 11.8.6 M  WML-C-51 u 11.8.2 O  WML-C-52 setvar 9.4 M  WML-C-53 wml 11.2 M   15.1.6 Image Support Item Function Reference Status Requirement WML-C-54 Display of alt attribute of <img> 11.9 M  WML-C-55 Support for vspace hint 11.9 O  WML-C-56 Support for hspace hint 11.9 O  WML-C-57 Support for <img> align 11.9 O  WML-C-58 Support for <img> height 11.9 O  WML-C-59 Support for <img> width 11.9 O  15.2 WML Encoder 15.2.1 Token Table Item Function Reference Status Requirement WML-S-60 WML token table 14 M  15.2.2 Validation Item Function Reference Status Requirement WML-S-61 XML Well-formed 14.2.2 M  WML-S-62 XML Validation 14.2.2 O  WML-S-63 WML Validation 15.3 O  WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 86 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reserved15.3 WML Document - Server Item Function Reference Status Requirement WML-S-64 Variable references may only occur in vdata attribute values 7.5 M  WML-S-65 Variable references must match the production rule var  10.3.1 M  WML-S-66 Two or more do elements with the same name must not be present in a single card or in the template element. (Note: An unspecified name defaults to the value of the type attribute.) 9.7 M  WML-S-67 A meta element must not contain more than one attribute of name and http-equiv 11.3.2 M  WML-S-68 The number of columns in a table must not be set to zero 11.8.5 M  WML-S-69 Event bindings must not conflict 9.10 M  15.4 WML Document – Client Item Function Reference Status Requirement WML-C-70 Variable references must match the production rule var 10.3.1 O  WML-C-71 Two or more do element with the same name must not be present in a single card or in the template element. (Note: An unspecified name defaults to the value of the type attribute.) 9.7 O  WML-C-72 A meta element must not contain more than one attribute of name and http-equiv 11.3.2 O  WAP-191_104-WML-20010718-a,  Version 1.3, 18-July-2001   Page 87 (87)  2001, Wireless Application Protocol Forum, Ltd.All rights reservedItem Function Reference Status Requirement WML-C-73 The number of columns in a table must not be set to zero 11.8.5 O  WML-C-74 Event bindings must not conflict 9.10 O"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-191_105-WML-20020212-a.pdf","file":"WAP-191_105-WML-20020212-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"This document provides changes and corrections to the following document files: - WAP-191-WML-20000219-a It includes changes from the following change requests: - CR-IBM-WML1.3-20020131  - CR-IBM-WML1.3-20020131-A with modification to specification reference. 2. Notation In the subsections describing the changes new text is underlined. Removed text has strikethrough marks. The presented text is copied from the specification. Text that is not presented is not affected at all. The change descriptions may also include editor’s notes similar to the one below. The notes are not part of the actual changes and must not be included in the changed text."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-192-WBXML-20010725-a.pdf","file":"WAP-192-WBXML-20010725-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope of the WAP Forum is to define a set of specifications to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers.  For additional information on the WAP architecture, refer to \"Wireless Application Protocol Architecture Specification\" [WAP]. This specification defines a compact binary representation of the Extensible Markup Language [XML].  The binary XML content format is designed to reduce the transmission size of XML documents, allowing more effective use of XML data on narrowband communication channels.  Refer to the [WML1] specification for one example use of the binary XML content format. The binary format was designed to allow for compact transmission with no loss of functionality or semantic information.  The format is designed to preserve the element structure of XML, allowing a browser to skip unknown elements or attributes.  The binary format encodes the parsed physical form of an XML document, i.e., the structure and content of the document entities. Meta-information, including the document type definition and conditional sections, is removed when the document is converted to the binary format."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-193-WMLScript-20001025-a.pdf","file":"WAP-193-WMLScript-20001025-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a set of standards to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers. For additional information on the WAP architecture, refer to Wireless Application Protocol Architecture Specification [WAP].  This paper is a specification of the WMLScript language. It is part of the WAP application layer and it can be used to add client side procedural logic. The language is based on ECMAScript [ECMA262] but it has been modified to better support low bandwidth communication and thin clients. WMLScript can be used together with Wireless Markup Language [WML] to provide intelligence to the clients but it has also been designed so that it can be used as a standalone tool.  One of the main differences between ECMAScript and WMLScript is the fact that WMLScript has a defined bytecode and an interpreter reference architecture. This way the narrowband communication channels available today can be optimally utilised and the memory requirements for the client kept to the minimum. Many of the advanced features of the ECMAScript language have been dropped to make the language smaller, easier to compile into bytecode and easier to learn. For example, WMLScript is a procedural language and it supports locally installed standard libraries.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 10(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             2. DOCUMENT STATUS This document is available online in the following formats:  • PDF format at http://www.wapforum.org/.   2.1 Copyright Notice © Wireless Application Protocol Forum Ltd. 2000. Terms and conditions of use are available from the Wireless Application Protocol Forum Ltd. web site (http://www.wapforum.org/docs/copyright.htm).   2.2 Errata Known problems associated with this document are published at http://www.wapforum.org/.   2.3 Comments Comments regarding this document can be submitted to WAP Forum in the manner published at http://www.wapforum.org/.  2.4 Document Changes 2.4.1 WAP-193   24-Mar-2000 Change Request Title Comments WAG-IBM-20000209-MustDefinition RFC2119 Conformance Section 5.1 – definition of SHOULD and MUST  2.4.2 WAP-193    25-Sep-2000 Change Request Title Comments New Static Conformance Format Re-release for WAP 2 WAP-193.100 Added Column for Inter-Specification Dependencies Section 15 New Title Page Format       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 11(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            2.5 Document History Document Name Date of Release SPEC-WMLScript-v1.1 17-Jun-1999 WAP-193.WMLScript-Proposed 24-March-2000 WAP-193.WMLScript    (Approved) June-2000 WAP-193.100-WMLS-20000925  (SCD) 25-September-2000    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 12(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             3. REFERENCES  3.1 Normative references  [ECMA262] Standard ECMA-262: \"ECMAScript Language Specification\", ECMA, June 1997 [IEEE754] ANSI/IEEE Std 754-1985: \"IEEE Standard for Binary Floating-Point Arithmetic\". Institute of Electrical and Electronics Engineers, New York (1985). [ISO10646] \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane\", ISO/IEC 10646-1:1993. [RFC2279] \"UTF-8, a transformation format of Unicode and ISO 10646\", F. Yergeau, January 1998. URL: ftp://ftp.isi.edu/in-notes/rfc2279.txt [RFC2068] \"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, et al., January 1997. URL: ftp://ftp.isi.edu/in-notes/rfc2068.txt [RFC2119] \"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March 1997. URL: ftp://ftp.isi.edu/in-notes/rfc2119.txt [RFC2396] \"Uniform Resource Identifiers (URI): Generic Syntax\", T. Berners-Lee, et al., August 1998. URL: http://info.internet.isi.edu/in-notes/rfc/files/rfc2396.txt [UNICODE] \"The Unicode Standard: Version 2.0\", The Unicode Consortium, Addison-Wesley Developers Press, 1996. URL: http://www.unicode.org/ [WAP] \"Wireless Application Protocol Architecture Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WML] \"Wireless Markup Language Specification\", WAP Forum, 04-November-1999. URL: http://www.wapforum.org/ [WMLSLibs] \"WAP-194-WMLScript Standard Libraries Specification\", WAP Forum, 15-May-2000. URL: http://www.wapforum.org/ [WSP] \"Wireless Session Protocol\", WAP Forum, 05-November-1999. URL: http://www.wapforum.org/ [XML] \"Extensible Markup Language (XML), W3C Proposed Recommendation 10-February-1998, REC-xml-19980210\", T. Bray, et al, February 10, 1998.  URL: http://www.w3.org/TR/REC-xml  3.2 Informative References  [HTML4] \"HTML 4.0 Specification, W3C Recommendation 18-December-1997, REC-HTML40-971218\", D. Raggett, et al., September 17, 1997. URL: http://www.w3.org/TR/REC-html40 [JavaScript] \"JavaScript: The Definitive Guide\", David Flanagan, O'Reilly & Associates, Inc. 1997 [WAE] \"Wireless Application Environment Specification\", WAP Forum, 04-November-1999. URL: http://www.wapforum.org/       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 13(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             4. DEFINITIONS AND ABBREVIATIONS  4.1 Definitions The following are terms and conventions used throughout this specification.  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",  \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\" and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119]. In the absence of any such terms, the specification should be interpreted as \"MUST\".  Bytecode - content encoding where the content is typically a set of low-level opcodes (ie, instructions) and operands for a targeted hardware (or virtual) machine.  Client - a device (or application) that initiates a request for connection with a server.  Content - subject matter (data) stored or generated at an origin server.  Content is typically displayed or interpreted by a user agent in response to a user request.  Content Encoding - when used as a verb, content encoding indicates the act of converting a data object from one format to another.  Typically the resulting format requires less physical space than the original, is easier to process or store and/or is encrypted.  When used as a noun, content encoding specifies a particular format or encoding standard or process.  Content Format – actual representation of content.  Device - a network entity that is capable of sending and receiving packets of information and has a unique device address.  A device can act as both a client or a server within a given context or across multiple contexts.  For example, a device can service a number of clients (as a server) while being a client to another server.  JavaScript - a de facto standard language that can be used to add dynamic behaviour to HTML documents.  JavaScript is one of the originating technologies of ECMAScript.  Origin Server - the server on which a given resource resides or is to be created.  Often referred to as a web server or an HTTP server.  Resource - a network data object or service that can be identified by a URL.  Resources may be available in multiple representations (e.g. multiple languages, data formats, size and resolutions) or vary in other ways.  Server - a device (or application) that passively waits for connection requests from one or more clients.  A server may accept or reject a connection request from a client.  User - a user is a person who interacts with a user agent to view, hear or otherwise use a rendered content.  User Agent - a user agent (or content interpreter) is any software or device that interprets WML, WMLScript or resources.  This may include textual browsers, voice browsers, search engines, etc.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 14(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             Web Server - a network host that acts as an HTTP server.  WML - the Wireless Markup Language is a hypertext markup language used to represent information for delivery to a narrowband device, e.g. a phone.  WMLScript - a scripting language used to program the mobile device.  WMLScript is an extended subset of the JavaScript scripting language.   4.2 Abbreviations For the purposes of this specification, the following abbreviations apply:  API Application Programming Interface BNF Backus-Naur Form ECMA European Computer Manufacturer Association HTML HyperText Markup Language [HTML4] HTTP HyperText Transfer Protocol [RFC2068] IANA Internet Assigned Number Authority LSB Least Significant Bits MSB Most Significant Bits RFC Request For Comments UI User Interface URL Uniform Resource Locator [RFC2396] UTF UCS Transformation Format UCS Universal Multiple-Octet Coded Character Set W3C World Wide Web Consortium WWW World Wide Web WSP Wireless Session Protocol WTP Wireless Transport Protocol WAP Wireless Application Protocol WAE Wireless Application Environment WTA Wireless Telephony Applications WTAI Wireless Telephony Applications Interface WBMP Wireless BitMaP     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 15(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             5. OVERVIEW  5.1 Why Scripting? WMLScript is designed to provide general scripting capabilities to the WAP architecture. Specifically, WMLScript can be used to complement the Wireless Markup Language [WML]. WML is a markup language based on Extensible Markup Language [XML]. It is designed to be used to specify application content for narrowband devices like cellular phones and pagers. This content can be represented with text, images, selection lists etc. Simple formatting can be used to make the user interfaces more readable as long as the client device used to display the content can support it. However, all this content is static and there is no way to extend the language without modifying WML itself. The following list contains some capabilities that are not supported by WML:  • Check the validity of user input (validity checks for the user input) • Access to facilities of the device. For example, on a phone, allow the programmer to make phone calls, send messages, add phone numbers to the address book, access the SIM card etc. • Generate messages and dialogs locally thus reducing the need for expensive round-trip to show alerts, error messages, confirmations etc. • Allow extensions to the device software and configuring a device after it has been deployed.  WMLScript was designed to overcome these limitations and to provide programmable functionality that can be used over narrowband communication links in clients with limited capabilities.   5.2 Benefits of using WMLScript Many of the services that can be used with thin mobile clients can be implemented with WML. Scripting enhances the standard browsing and presentation facilities of WML with behavioural capabilities. They can be used to supports more advanced UI functions, add intelligence to the client, provide access to the device and its peripheral functionality and reduces the amount of bandwidth needed to send data between the server and the client.  WMLScript is loosely based on ECMAScript [ECMA262] and does not require the developers to learn new concepts to be able to generate advanced mobile services.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 16(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             6. WMLSCRIPT CORE One objective for the WMLScript language is to be close to the core of the ECMAScript Language specification [ECMA262]. The part in the ECMAScript Language specification that defines basic types, variables, expressions and statements is called core and can almost be used \"as is\" for the WMLScript specification. This section gives an overview of the core parts of WMLScript.  See section WMLScript Grammar (7) for syntax conventions and precise language grammar.   6.1 Lexical Structure This section describes the set of elementary rules that specify how you write programs in WMLScript.  6.1.1 Case Sensitivity WMLScript is a case-sensitive language. All language keywords, variables and function names must use the proper capitalisation of letters.  6.1.2 Whitespace and Line Breaks WMLScript ignores spaces, tabs, newlines etc. that appear between tokens in programs, except those that are part of string constants.  Syntax: WhiteSpace :: <TAB> <VT> <FF> <SP> <LF> <CR> LineTerminator :: <LF> <CR> <CR><LF>  6.1.3 Usage of Semicolons The following statements in WMLScript have to be followed by a semicolon:1  • Empty statement (see section 6.5.1) • Expression statement (see section 6.5.2) • Variable statement (see section 6.5.4) • Break statement (see section 6.5.8) • Continue statement (see section 6.5.9)                                                  1 Compatibility note: ECMAScript supports optional semicolons.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 17(132)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            • Return statement (see section 6.5.10)  6.1.4 Comments The language defines two comment constructs: line comments (ie, start with // and end in the end of the line) and block comments (ie, consisting of multiple lines starting with /* and ending with */). It is illegal to have nested block comments.2  Syntax: Comment :: MultiLineComment SingleLineComment MultiLineComment :: /* MultiLineCommentCharsopt */ SingleLineComment :: // SingleLineCommentCharsopt  6.1.5 Literals 6.1.5.1 Integer Literals Integer literals can be represented in three different ways: decimal, octal and hexadecimal integers.  Syntax: DecimalIntegerLiteral :: 0 NonZeroDigit DecimalDigitsopt NonZeroDigit :: one of 1 2 3 4 5 6 7 8 9 DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9 HexIntegerLiteral :: 0x HexDigit 0X HexDigit HexIntegerLiteral HexDigit HexDigit :: one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F                                                  2 Compatibility note: ECMAScript also supports HTML comments.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 18(133)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            OctalIntegerLiteral :: 0 OctalDigit OctalIntegerLiteral OctalDigit OctalDigit :: one of 0 1 2 3 4 5 6 7  The minimum and maximum sizes for integer literals and values are specified in the section 6.2.7.1. An integer literal that is not within the specified value range must result in a compile time error.  6.1.5.2 Floating-Point Literals Floating-point literals can contain a decimal point as well as an exponent.  Syntax: DecimalFloatLiteral :: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPart DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit ExponentPart :: ExponentIndicator SignedInteger ExponentIndicator :: one of e E SignedInteger :: DecimalDigits + DecimalDigits - DecimalDigits  The minimum and maximum sizes for floating-point literals and values are specified in the section 6.2.7.2. A floating-point literal that is not within the specified value range must result in a compile time error. A floating-point literal underflow results in a floating-point literal zero (0.0).  6.1.5.3 String Literals Strings are any sequence of zero or more characters enclosed within double (\") or single quotes (').  Syntax: StringLiteral :: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt  '    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 19(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Examples of valid strings are:  \"Example\"    'Specials: \\x00 \\' \\b'    \"Quote: \\\"\"  Since some characters are not representable within strings, WMLScript supports special escape sequences by which these characters can be represented:  Sequence Character represented3 Unicode Symbol \\’ Apostrophe or single quote \\u0027 ' \\\" Double quote \\u0022 \" \\\\ Backslash \\u005C \\ \\/ Slash \\u002F / \\b Backspace \\u0008  \\f Form feed \\u000C  \\n Newline \\u000A  \\r Carriage return \\u000D  \\t Horizontal tab \\u0009  \\xhh The character with the encoding specified by two hexadecimal digits hh (Latin-1 ISO8859-1)   \\ooo The character with the encoding specified by the three octal digits ooo (Latin-1 ISO8859-1)   \\uhhhh The Unicode character with the encoding specified by the four hexadecimal digits hhhh.    An escape sequence occurring within a string literal always contributes a character to the string value of the literal and is never interpreted as a line terminator or as a quote mark that might terminate the string literal.  6.1.5.4 Boolean Literals A \"truth value\" in WMLScript is represented by a boolean literal. The two boolean literals are: true and false.  Syntax: BooleanLiteral :: true false  6.1.5.5 Invalid Literal WMLScript supports a special invalid literal to denote an invalid value.                                                   3 Compatibility note: ECMAScript supports also non-escape characters preceded by a backslash.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 20(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Syntax: InvalidLiteral :: invalid  6.1.6 Identifiers Identifiers are used to name and refer to three different elements of WMLScript: variables (see section 6.2), functions (see section 6.4) and pragmas (see section 6.7). Identifiers4 cannot start with a digit but can start with an underscore (_).  Syntax: Identifier :: IdentifierName but not ReservedWord IdentifierName :: IdentifierLetter IdentifierName IdentifierLetter IdentifierName DecimalDigit IdentifierLetter :: one of a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _                          DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9  Examples of legal identifiers are:  timeOfDay  speed  quality  HOME_ADDRESS  var0  _myName  ____  The compiler looks for the longest string of characters make up a valid identifier. Identifiers cannot contain any special characters except underscore (_). WMLScript keywords and reserved words cannot be used as identifiers. Examples of illegal identifiers are:  while  for  if  my~name  $sys  123  3pieces  take.this  Uppercase and lowercase letters are distinct which means that the identifiers speed and Speed are different.  6.1.7 Reserved Words WMLScript specifies a set of reserved words that have a special meaning in programs and they cannot be used as identifiers. Examples of such words are (full list can be found from the WMLScript grammar specification, see section 7):                                                  4 Compatibility note: ECMAScript supports the usage of $ character in any position of the name, too.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 21(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             break  continue  false  true  while  6.1.8 Name Spaces WMLScript supports name spaces for identifiers that are used for different purposes. The following name spaces are supported:  • Function names (see section 6.4.1) • Function parameters (see section 6.4.2) and variables (see section 6.2) • Pragmas (see section 6.7)  Thus, the same identifiers can be used to specify a function name, variable/parameter name or a name for a pragma within the same compilation unit:  use url myTest \"http://www.host.com/script\";  function myTest(myTest) {   var value = myTest#myTest(myTest);   return value; };   6.2 Variables and Data Types This section describes the two important concepts of WMLScript language: variables and internal data types. A variable is a name associated with a data value. Variables can be used to store and manipulate program data. WMLScript supports local variables5 only declared inside functions or passed as function parameters (see section 6.4).  6.2.1 Variable Declaration Variable declaration is compulsory6 in WMLScript. Variable declaration is done simply by using the var keyword and a variable name (see section 6.5.4 for information about variable statements). Variable names follow the syntax defined for all identifiers (see section 6.1.6):  var x; var price; var x,y; var size = 3;  Variables must be declared before they can be used. Initialisation of variables is optional. Uninitialised variables are automatically initialised to contain an empty string (\"\").  6.2.2 Variable Scope and Lifetime The scope of WMLScript variables is the remainder of the function (see section 6.4) in which they have been declared. All variable names within a function must be unique. Block statements (see section 6.5.3) are not used for scoping.                                                  5 Compatibility note: ECMAScript supports global variables, too. 6 Compatibility note: ECMAScript supports automatic declaration, too.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 22(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             function priceCheck(givenPrice) {   if (givenPrice > 100) {     var newPrice = givenPrice;   } else {     newPrice = 100;   };   return newPrice; };  The lifetime of a variable is the time between the variable declaration and the end of the function.  function foo() {   x = 1;          // Error: usage before declaration   var x,y;   if (x) {     var y;        // Error: redeclaration   }; };  6.2.3 Variable Access Variables are accessible only within the function in which they have been declared. Accessing the content of a variable is done by using the variable name:  var myAge   = 37; var yourAge = 63; var ourAge  = myAge + yourAge;  6.2.4 Variable Type WMLScript is a weakly typed language. The variables are not typed but internally the following basic data types are supported: boolean, integer, floating-point and string. In addition to these, a fifth data type invalid is specified to be used in cases an invalid data type is needed to separate it from the other internal data types. Since these data types are supported only internally, the programmer does not have to specify variable types and any variable can contain any type of data at any given time. WMLScript will attempt automatically convert between the different types as needed.  var flag        = true;       // Boolean var number      = 12;         // Integer var temperature = 37.7;       // Float number          = \"XII\";      // String var except      = invalid;    // Invalid  6.2.5 L-Values Some operators (see section 6.3.1 for more information about assignment operators) require that the left operand is a reference to a variable (L-value) and not the variable value. Thus, in addition to the five data types supported by WMLScript, a sixth type variable is used to specify that a variable name must be provided.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 23(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             result += 111;  // += operator requires a variable  6.2.6 Type Equivalency WMLScript supports operations on different data types. All operators (see section 6.3) specify the accepted data types for their operands. Automatic data type conversions (see section 6.8) are used to convert operand values to required data types.  6.2.7 Numeric Values WMLScript supports two different numeric variable values: integer and floating-point values7. Variables can be initialised with integer and floating-point literals and several operators can be used to modify their values during the run-time. Conversion rules between integer and floating-point values are specified in chapter 6.8  var pi     = 3.14; var length = 0; var radius = 2.5; length     = 2*pi*radius;  6.2.7.1 Integer Size The size of the integer is 32 bits (two's complement). This means that the supported value range8 for integer values is: -2147483648 and 2147483647. Lang [WMLSLibs] library functions can be used to get these values during the run-time:  Lang.maxInt() Maximum representable integer value Lang.minInt() Minimum representable integer value   6.2.7.2 Floating-point Size The minimum/maximum values9 and precision for floating-point values are specified by [IEEE754]. WMLScript supports  32-bit single precision floating-point format:  • Maximum value: 3.40282347E+38 • Minimum positive nonzero value (at least the normalised precision must be supported):  1.17549435E-38 or smaller  The Float [WMLSLibs] library can be used to get these values during the run-time:  Float.maxFloat() Maximum representable floating-point value supported.                                                  7 Convention: In cases where the value can be either an integer or a floating-point, a more generic term number is used instead. 8 Compatibility note: ECMAScript does not specify maximum and minimum values for integers. All numbers are represented as floating-point values. 9 Compatibility note: ECMAScript uses double-precision 64-bit format [IEEE754] floating-point values for all numbers.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 24(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Float.minFloat() Smallest positive nonzero floating-point value supported.  The special floating-point number types are handled by using the following rules:  • If an operation results in a floating-point number that is not part of the set of finite real numbers (not a number, positive infinity etc.) supported by the single precision floating-point format then the result is an invalid value. • If an operation results in a floating-point underflow the result is zero (0.0). • Negative and positive zero are equal and undistinguishable.   6.2.8 String Values WMLScript supports strings that can contain letters, digits, special characters etc. Variables can be initialised with string literals and string values can be manipulated both with WMLScript operators and functions specified in the standard String library [WMLSLibs].  var msg = \"Hello\"; var len = String.length(msg); msg     = msg + ' Worlds!';  6.2.9 Boolean Values Boolean values can be used to initialise or assign a value to a variable or in statements which require a boolean value as one of the parameters. Boolean value can be a literal or the result of a logical expression evaluation (see section 6.3.3 for more information).  var truth = true; var lie   = !truth;   6.3 Operators and Expressions The following sections describe the operators supported by WMLScript and how they can be used to form complex expressions.  6.3.1 Assignment Operators WMLScript supports several ways to assign a value to a variable. The simplest one is the regular assignment (=) but assignments with operation are also supported:   Operator Operation = assign += add (numbers)/concatenate (strings) and assign -= subtract and assign *= multiply and assign /= divide and assign div= divide (integer division) and assign    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 25(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Operator Operation %= remainder (the sign of the result equals the sign of the dividend) and assign <<= bitwise left shift and assign >>= bitwise right shift with sign and assign >>>= bitwise right shift zero fill and assign &= bitwise AND and assign ^= bitwise XOR and assign |= bitwise OR and assign  Assignment does not necessarily imply sharing of structure nor does assignment of one variable change the binding of any other variable.  var a = \"abc\"; var b =  a; b     = \"def\";  // Value of a is \"abc\"  6.3.2 Arithmetic Operators WMLScript supports all the basic binary arithmetic operations:  Operator Operation + add (numbers)/concatenation (strings) - subtract * multiply / divide div integer division  In addition to these, a set of more complex binary operations are supported, too:  Operator Operation % remainder, the sign of the result equals the sign of the dividend << bitwise left shift >> bitwise right shift with sign >>> bitwise shift right with zero fill & bitwise AND | bitwise OR ^ bitwise XOR  The basic unary operations supported are:  Operator Operation + plus - minus -- pre-or-post decrement    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 26(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Operator Operation ++ pre-or-post increment ~ bitwise NOT  Examples: var y = 1/3; var x = y*3+(++b);  6.3.3 Logical Operators WMLScript supports the basic logical operations:  Operator Operation && logical AND || logical OR ! logical NOT (unary)  Logical AND operator evaluates the first operand and tests the result. If the result is false, the result of the operation is false and the second operand is not evaluated. If the first operand evaluates to true, the result of the operation is the result of the evaluation of the second operand. If the first operand evaluates to invalid, the second operand is not evaluated and the result of the operation is invalid.  Similarly, the logical OR evaluates the first operand and tests the result. If the result is true, the result of the operation is true and the second operand is not evaluated. If the first operand evaluates to false, the result of the operation is the result of the evaluation of the second operand. If the first operand evaluates to invalid, the second operand is not evaluated and the result of the operation is invalid.  weAgree = (iAmRight && youAreRight) ||           (!iAmRight && !youAreRight);  WMLScript requires a value of boolean type for logical operations. Automatic conversions from other types to boolean type and vice versa are supported (see section 6.8).  Notice: If the value of the first operand for logical AND or OR is invalid, the second operand is not evaluated and the result of the operand is invalid:  var a = (1/0) || foo(); // result: invalid, no call to foo() var b = true  || (1/0); // true var c = false || (1/0); // invalid     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 27(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            6.3.4 String Operators WMLScript supports string concatenation as a built-in operation. The + and += operators used with strings perform a concatenation on the strings. Other string operations10 are supported by a standard String library (see [WMLSLibs]).  var str = \"Beginning\" + \"End\"; var chr = String.charAt(str,10); // chr = \"E\"  6.3.5 Comparison Operators WMLScript supports all the basic comparison operations:  Operator Operation < less than <= less than or equal == equal >= greater or equal > greater than != inequality  Comparison operators use the following rules:  • Boolean: true is larger than false • Integer: Comparison is based on the given integer values • Floating-point: Comparison is based on the given floating-point values • String: Comparison is based on the order of character codes of the given string values. Character codes are defined by the character set supported by the WMLScript Interpreter • Invalid: If at least one of the operands is invalid then the result of the comparison is invalid  Examples: var res = (myAmount > yourAmount); var val = ((1/0) == invalid);      // val = invalid  6.3.6 Array Operators WMLScript does not support arrays11 as such. However, the standard String library (see [WMLSLibs]) supports functions by which array like behaviour can be implemented by using strings. A string can contain elements that are separated by a separator specified by the application programmer. For this purpose, the String library contains functions by which creation and management of string arrays can be done.                                                  10 Compatibility note: ECMAScript supports String objects and a length attribute for each string. WMLScript does not support objects. However, similar functionality is provided by WMLScript libraries. 11 Compatibility note: ECMAScript supports arrays.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 28(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             function dummy() {   var str  = \"Mary had a little lamb\";   var word = String.elementAt(str,4,\" \"); };  6.3.7 Comma Operator WMLScript supports the comma (,) operator by which multiple evaluations can be combined into one expression. The result of the comma operator is the value of the second operand:  for (a=1, b=100; a < 10; a++,b++) {   ... do something ... };  Commas used in the function call to separate parameters and in the variable declarations to separate multiple variable declarations are not comma operators. In these cases, the comma operator must be placed inside the parenthesis:  var a=2; var b=3, c=(a,3); myFunction(\"Name\", 3*(b*a,c)); // Two parameters: \"Name\",9  6.3.8 Conditional Operator WMLScript supports the conditional (?:) operator which takes three operands. The operator selectively evaluates one of the given two operands based on the boolean value of the first operand. If the value of the first operand (condition) is true then the result of the operation is the result of the evaluation of the second operand. If the value of the first operand is false or invalid then the result of the operation is the result of the evaluation of the third operand.  myResult = flag ? \"Off\" : \"On (value=\" + level + \")\";  Notice: This operator behaves like an if statement (see section 6.5.5). The third operand is evaluated if the evaluation of the condition results in false or invalid.  6.3.9 typeof Operator Although WMLScript is a weakly typed language, internally the following basic data types are supported: boolean, integer, floating-point, string and invalid. Typeof (typeof) operator returns an integer value12 that describes the type of the given expression. The possible results are:  Type Code Integer: 0 Floating-point: 1 String: 2                                                  12 Compatibility note: ECMAScript specifies that the typeof operator returns a string representing the variable type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 29(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Type Code Boolean: 3 Invalid: 4  Typeof operator does not try to convert the result from one type to another but returns the type as it is after the evaluation of the expression.  var str    = \"123\"; var myType = typeof str; // myType = 2  6.3.10 isvalid Operator This operator can be used to check the type of the given expression. It returns a boolean value false if the type of the expression is invalid, otherwise true is returned. isvalid operator does not try to convert the result from one type to another but returns the type as it is after the evaluation of the expression.  var str = \"123\"; var ok  = isvalid str;   // true var tst = isvalid (1/0); // false  6.3.11 Expressions WMLScript supports most of the expressions supported by other programming languages. The simplest expressions are constants and variable names, which simply evaluate to either the value of the constant or the variable.  567 66.77 \"This is too simple\" 'This works too' true myAccount  Expressions that are more complex can be defined by using simple expressions together with operators and function calls.  myAccount + 3 (a + b)/3 initialValue + nextValue(myValues);  6.3.12 Expression Bindings The following table contains all operators supported by WMLScript. The table also contains information about operator precedence (the order of evaluation) and the operator associativity (left-to-right (L) or right-to-left (R)):     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 30(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Preced-ence13 Associativity Operator Operand types Result type Operation performed 1 R ++ number number* pre- or post-increment (unary) 1 R -- number number* pre- or post-decrement (unary) 1 R + number number* unary plus 1 R - number number* unary minus (negation) 1 R ~ integer integer* bitwise NOT (unary) 1 R ! boolean boolean* logical NOT (unary) 1 R typeof any integer return internal data type (unary) 1 R isvalid any boolean check for validity (unary) 2 L * numbers number* multiplication 2 L / numbers floating-point* division 2 L div integers integer* integer division 2 L % integers integer* remainder 3 L - numbers number* subtraction 3 L + numbers or strings number or string* addition (numbers) or string concatenation 4 L << integers integer* bitwise left shift 4 L >> integers integer* bitwise right shift with sign 4 L >>> integers integer* bitwise right shift with zero fill 5 L <, <= numbers or strings boolean* less than, less than or equal 5 L >, >= numbers or strings boolean* greater than, greater or equal 6 L == numbers or strings boolean* equal (identical values) 6 L != numbers or strings boolean* not equal (different values) 7 L & integers integer* bitwise AND 8 L ^ integers integer* bitwise XOR 9 L | integers integer* bitwise OR 10 L && booleans boolean* logical AND 11 L || booleans boolean* logical OR 12 R ? : boolean, any, any any* conditional expression 13 R = variable, any any assignment 13 R *=, -= variable, number number* assignment with numeric operation 13 R /= variable, number floating-point* assignment with numeric operation 13 R %=, div= variable, integer integer* assignment with integer operation                                                  13 Binding: 0 binds tightest    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 31(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Preced-ence13 Associativity Operator Operand types Result type Operation performed 13 R += variable, number or string number or string* assignment with addition or concatenation 13 R <<=, >>=, >>>=, &=, ^=, |= variable, integer integer* assignment with bitwise operation 14 L , any any multiple evaluation  * The operator can return an invalid value in case the data type conversions fail (see section 6.8 for more information about conversion rules) or one of the operands is invalid.  6.4 Functions A WMLScript function is a named part of the WMLScript compilation unit that can be called to perform a specific set of statements and to return a value. The following sections describe how WMLScript functions can be declared and used. 6.4.1 Declaration Function declaration can be used to declare a WMLScript function name (Identifier) with the optional parameters (FormalParameterList) and a block statement that is executed when the function is called. All functions have the following characteristics:  • Function declarations cannot be nested. • Function names must be unique within one compilation unit. • All parameters to functions are passed by value. • Function calls must pass exactly the same number of arguments to the called function as specified in the function declaration. • Function parameters behave like local variables that have been initialised before the function body (block of statements) is executed. • A function always returns a value. By default it is an empty string (\"\"). However, a return statement can be used to specify other return values.  Functions in WMLScript are not data types14 but a syntactical feature of the language.  Syntax: FunctionDeclaration : externopt  function Identifier ( FormalParameterListopt ) Block ;opt FormalParameterList : Identifier FormalParameterList , Identifier                                                   14 Compatibility note: Functions in ECMAScript are actual data types.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 32(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Arguments: The optional extern keyword can be used to specify a function to be externally accessible. Such functions can be called from outside the compilation unit in which they are defined. There must be at least one externally accessible function in a compilation unit. Identifier is the name specified for the function. FormalParameterList (optional) is a comma-separated list of argument names. Block is the body of the function that is executed when the function is called and the parameters have been initialised by the passed arguments.  Examples: function currencyConverter(currency, exchangeRate) {   return currency*exchangeRate; };  extern function testIt() {   var UDS = 10;   var FIM = currencyConverter(USD, 5.3); };  6.4.2 Function Calls The way a function is called depends on where the called (target) function is declared. The following sections describe the three function calls supported by WMLScript: local script function call, external function call and library function call.  6.4.2.1 Local Script Functions Local script functions (defined inside the same compilation unit) can be called simply by providing the function name and a comma separated list of arguments (number of arguments must match the number of parameters15 accepted by the function).  Syntax: LocalScriptFunctionCall : FunctionName Arguments FunctionName : Identifier Arguments : ( ) ( ArgumentList  ) ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression Functions inside the same compilation unit can be called before the function has been declared:                                                  15 Compatibility note: ECMAScript supports a variable number of arguments in a function call.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 33(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             function test2(param) {   return test1(param+1); };  function test1(val) {   return val*val; };  6.4.2.2 External Functions External function calls must be used when the called function is declared in an external compilation unit. The function call is similar to a local function call but it must be prefixed with the name of the external compilation unit.  Syntax: ExternalScriptFunctionCall : ExternalScriptName # FunctionName Arguments ExternalScriptName : Identifier Pragma use url (see section 6.7) must be used to specify the external compilation unit. It defines the mapping between the external unit and a name that can be used within function declarations. This name and the hash symbol (#) are used to prefix the standard function call syntax:  use url OtherScript \"http://www.host.com/script\";  function test3(param) {   return OtherScript#test2(param+1); };  6.4.2.3 Library Functions Library function calls must be used when the called function is a WMLScript standard library function [WMLSLibs].  Syntax: LibraryFunctionCall : LibraryName . FunctionName Arguments LibraryName : Identifier A library function can be called by prefixing the function name with the name of the library (see section 6.6 for more information) and the dot symbol (.):    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 34(134)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             function test4(param) {   return Float.sqrt(Lang.abs(param)+1); };  6.4.3 Default Return Value The default return value for a function is an empty string (\"\"). Return values of functions can be ignored (ie, function call as a statement):  function test5() {   test4(4); };   6.5 Statements WMLScript statements consist of expressions and keywords used with the appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line.  The following sections define the statements available in WMLScript16: empty statement, expression statement, block statement, break, continue, for, if...else, return, var, while.  6.5.1 Empty Statement Empty statement is a statement that can be used where a statement is needed but no operation is required.  Syntax: EmptyStatement : ;   Examples: while (!poll(device)) ; // Wait until poll() is true  6.5.2 Expression Statement Expression statements are used to assign values to variables, calculate mathematical expressions, make function calls etc.  Syntax: ExpressionStatement : Expression ; Expression : AssignmentExpression Expression , AssignmentExpression                                                  16 Compatibility note: ECMAScript supports also for..in and with statements.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 35(135)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             Examples: str  = \"Hey \" + yourName; val3 = prevVal + 4; counter++; myValue1 = counter, myValue2 = val3; alert(\"Watch out!\"); retVal = 16*Lang.max(val3,counter);  6.5.3 Block Statement A set of statements enclosed in the curly brackets is a block statement. It can be used anywhere a single statement is needed.  Syntax: Block : { StatementListopt } StatementList : Statement   StatementList Statement   Example: {   var i = 0;   var x = Lang.abs(b);   popUp(\"Remember!\"); }  6.5.4 Variable Statement This statement declares variables with initialisation (optional, variables are initialised to empty string (\"\") by default). The scope of the declared variable is the rest of the current function (see section 6.2.2 for more information about variable scoping).   Syntax: VariableStatement : var VariableDeclarationList ; VariableDeclarationList : VariableDeclaration VariableDeclarationList , VariableDeclaration VariableDeclaration : Identifier VariableInitializeropt VariableInitializer : = ConditionalExpression    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 36(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             Arguments: Identifier is the variable name. It can be any legal identifier. ConditionalExpression is the initial value of the variable and can be any legal expression. This expression (or the default initialisation to an empty string) is evaluated every time the variable statement is executed.  Variable names must be unique within a single function.  Examples: function count(str) {   var result = 0;      // Initialized once   while (str != \"\") {     var ind = 0;       // Initialized every time     // modify string   };   return result };  function example(param) {   var a = 0;   if (param > a) {     var b = a+1;       // Variables a and b can be used   } else {     var c = a+2;       // Variables a, b and c can be used   };   return a;            // Variable a, b and c are accessible };  6.5.5 If Statement This statement is used to specify conditional execution of statements. It consists of a condition and one or two statements and executes the first statement if the specified condition is true. If the condition is false, the second (optional) statement is executed.  Syntax: IfStatement : if ( Expression ) Statement else Statement  if ( Expression ) Statement   Arguments: Expression (condition) can be any WMLScript expression that evaluates (directly or after conversion) to a boolean or an invalid value. If condition evaluates to true, the first statement is executed. If condition evaluates to false or invalid, the second (optional) else statement is executed. Statement can be any WMLScript statement, including another (nested) if statement. else is always tied to the closest if.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 37(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Example: if (sunShines) {   myDay = \"Good\";   goodDays++; } else   myDay = \"Oh well...\";  6.5.6 While Statement This statement is used to create a loop that evaluates an expression and, if it is true, execute a statement. The loop repeats as long as the specified condition is true.  Syntax: WhileStatement : while ( Expression ) Statement    Arguments: Expression (condition) can be any WMLScript expression that evaluates (directly or after the conversion) to a boolean or an invalid value. The condition is evaluated before each execution of the loop statement. If this condition evaluates to true, the Statement is performed. When condition evaluates to false or invalid, execution continues with the statement following Statement. Statement is executed as long as the condition evaluates to true.  Example: var counter = 0; var total   = 0; while (counter < 3) {   counter++;   total += c; };  6.5.7 For Statement This statement is used to create loops. The statement consists of three optional expressions enclosed in parentheses and separated by semicolons followed by a statement executed in the loop.  Syntax: ForStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement  for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement   Arguments: The first Expression or VariableDeclarationList (initialiser) is typically used to initialise a counter variable. This expression may optionally declare new variables with the var keyword. The scope of the defined variables is the rest of the function (see section 6.2.2 for more information about variable scoping).  The second Expression (condition) can be any WMLScript expression that evaluates (directly or after the conversion) to a boolean or an invalid value. The condition is evaluated on each pass through the    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 38(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            loop. If this condition evaluates to true, the Statement is performed. This conditional test is optional. If omitted, the condition always evaluates to true.  The third Expression (increment-expression) is generally used to update or increment the counter variable. Statement is executed as long as the condition evaluates to true.  Example:  for (var index = 0; index < 100; index++) {   count += index;   myFunc(count); };  6.5.8 Break Statement This statement is used to terminate the current while or for loop and continue the program execution from the statement following the terminated loop. It is an error to use break statement outside a while or a for statement.  Syntax: BreakStatement : break ;  Example: function testBreak(x) {   var index = 0;   while (index < 6) {     if (index == 3) break;     index++;   };   return index*x; };  6.5.9 Continue Statement This statement is used to terminate execution of a block of statements in a while or for loop and continue execution of the loop with the next iteration. Continue statement does not terminate the execution of the loop:  • In a while loop, it jumps back to the condition.  • In a for loop, it jumps to the update expression.   It is an error to use continue statement outside a while or a for statement.  Syntax: ContinueStatement : continue ;     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 39(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Example:  var index = 0; var count = 0; while (index < 5) {    index++;    if (index == 3)       continue;    count += index; };  6.5.10 Return Statement This statement can be used inside the function body to specify the function return value. If no return statement is specified or none of the function return statements is executed, the function returns an empty string by default.  Syntax: ReturnStatement : return Expressionopt ;  Example: function square( x ) {   if (!(Lang.isFloat(x))) return invalid;   return x * x; };   6.6 Libraries WMLScript supports the usage of libraries17. Libraries are named collections of functions that belong logically together. These functions can be called by using a dot (‘.’) separtor with the library name and the function name with parameters:  An example of a library function call:  function dummy(str) {   var i = String.elementAt(str,3,\" \"); };  6.6.1 Standard Libraries Standard libraries are specified in more detail in the WAP-194-WMLScript Standard Libraries Specification [WMLSLibs].                                                    17 Compatibility note: ECMAScript does not support libraries. It supports a set of predefined objects with attributes. WMLScript uses libraries to support similar functionality.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 40(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            6.7 Pragmas WMLScript supports the usage of pragmas that specify compilation unit level information. Pragmas are specified at the beginning of the compilation unit before any function declaration. All pragmas start with the keyword use and are followed by pragma specific attributes.  Syntax: CompilationUnit : Pragmasopt FunctionDeclarations Pragmas : Pragma Pragmas Pragma Pragma : use PragmaDeclaration ; PragmaDeclaration : ExternalCompilationUnitPragma AccessControlPragma MetaPragma The following sections contain more information about the supported pragmas.  6.7.1 External Compilation Units WMLScript compilation units can be accessed by using a URL. Thus, each WMLScript function can be accessed by specifying the URL of the WMLScript resource and its name. A use url pragma must be used when calling a function in an external compilation unit.  Syntax: ExternalCompilationUnitPragma : url Identifier StringLiteral  The use url pragma specifies the location (URL) of the external WMLScript resource and gives it a local name. This name can then be used inside the function declarations to make external function calls (see section 6.4.2.2).  use url OtherScript \"http://www.host.com/app/script\";  function test(par1, par2) {   return OtherScript#check(par1-par2); };  The behaviour of the previous example is the following:  • The pragma specifies a URL to a WMLScript compilation unit. • The function call loads the compilation unit by using the given URL (http://www.host.com/app/script) • The content of the compilation unit is verified and the specified function (check) is executed    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 41(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             The use url pragma has its own name space for local names. However, the local names must be unique within one compilation unit. The following URLs are supported:  • Uniform Resource Locators [RFC2396] without a hash mark (#) or a fragment identifier. The schemes supported are specified in [WAE]. • Relative URLs [RFC2396] without a hash mark (#) or a fragment identifier: The base URL is the URL that identifies the current compilation unit.  The given URL must be escaped according to the URL escaping rules. No compile time automatic escaping, URL syntax or URL validity checking is performed.  6.7.2 Access Control A WMLScript compilation unit can protect its content by using an access control pragma. Access control must be performed before calling external functions. It is an error for a compilation unit to contain more than one access control pragma.  Syntax: AccessControlPragma : access AccessControlSpecifier AccessControlSpecifier : domain StringLiteral path StringLiteral domain StringLiteral path StringLiteral Every time an external function is invoked an access control check is performed to determine whether the destination compilation unit allows access from the caller. Access control pragma is used to specify domain and path attributes against which these access control checks are performed. If a compilation unit has a domain and/or path attribute, the referring compilation unit's URL must match the values of the attributes. Matching is done as follows: the access domain is suffix-matched against the domain name portion of the referring URL and the access path is prefix-matched against the path portion of the referring URL. Domain and path attributes follow the URL capitalisation rules.  Domain suffix matching is done using the entire element of each sub-domain and must match each element exactly (e.g. www.wapforum.org shall match wapforum.org, but shall not match forum.org).  Path prefix matching is done using entire path elements and must match each element exactly (e.g. /X/Y matches /X, but does not match /XZ).  The domain attribute defaults to the current compilation unit's domain. The path attribute defaults to the value \"/\".   To simplify the development of applications that may not know the absolute path to the current compilation unit, the path attribute accepts relative URLs [RFC2396]. The user agent converts the relative path to an absolute path and then performs prefix matching against the path attribute.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 42(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Given the following access control attributes for a compilation unit:  use access domain \"wapforum.org\" path \"/finance\";  The following referring URLs would be allowed to call the external functions specified in this compilation unit:  http://wapforum.org/finance/money.cgi https://www.wapforum.org/finance/markets.cgi http://www.wapforum.org/finance/demos/packages.cgi?x=123&y=456  The following referring URLs would not be allowed to call the external functions:  http://www.test.net/finance http://www.wapforum.org/internal/foo.wml  By default, access control is disabled (ie, all external functions have public access).  6.7.3 Meta-Information Pragmas can also be used to specify compilation unit specific meta-information. Meta-information is specified with property names and values. This specification does not define any properties, nor does it define how user agents must interpret meta-data. User agents are not required to act on the meta-data.  Syntax: MetaPragma : meta MetaSpecifier MetaSpecifier : MetaName MetaHttpEquiv MetaUserAgent MetaName : name MetaBody MetaHttpEquiv : http equiv MetaBody MetaUserAgent : user agent MetaBody MetaBody : MetaPropertyName MetaContent MetaSchemeopt Meta-pragmas have three attributes: property name, content (the value of the property) and optional scheme (specifies a form or structure that may be used to interpret the property value – the values vary depending on the type of meta-data). The attribute values are string literals.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 43(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            6.7.3.1 Name Name meta-pragma is used to specify meta-information intended to be used by the origin servers. The user agent should ignore any meta-data named with this attribute. Network servers should not emit WMLScript content containing meta-name pragmas.  use meta name \"Created\" \"18-March-1998\";  6.7.3.2 HTTP Equiv HTTP equiv meta-pragma is used to specify meta-information that indicates that the property should be interpreted as an HTTP header (see [RFC2068]). Meta-data named with this attribute should be converted to a WSP or HTTP response header if the compilation unit is compiled before it arrives at the user agent.  use meta http equiv \"Keywords\" \"Script,Language\";  6.7.3.3 User Agent User agent meta-pragma is used to specify meta-information intended to be used by the user agents. This meta-data must be delivered to the user agent and must not be removed by any network intermediary.  use meta user agent \"Type\" \"Test\";      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 44(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             6.8 Automatic Data Type Conversion Rules In some cases, WMLScript operators require specific data types as their operands. WMLScript supports automatic data type conversions to meet the requirements of these operators. The following sections describe the different conversions in detail.   6.8.1 General Conversion Rules WMLScript is a weakly typed language and the variable declarations do not specify a type. However, internally the language handles the following data types:  • Boolean: represents a boolean value true or false. • Integer: represents an integer value • Floating-point: represents a floating-point value • String: represents a sequence of characters • Invalid: represents a type with a single value invalid  A variable at any given time can contain a value of one of these types. WMLScript provides an operator typeof, which can be used to determine what is the current type of a variable or any expression (no conversions are performed).  Each WMLScript operator accepts a predefined set of operand types. If the provided operands are not of the right data type an automatic conversion must take place. The following sections specify the legal automatic conversions between two data types.  6.8.2 Conversions to String Legal conversions from other data types to string are:  • Integer value must be converted to a string of decimal digits that follows the numeric string grammar rules for decimal integer literals. See section 7.4 for more information about the numeric string grammar. • Floating-point value must be converted to an implementation-dependent string representation that follows the numeric string grammar rules for decimal floating-point literals (see section 7.1.4 for more information about the numeric string grammar). The resulting string representation must be equal to the original value (ie .5 can be represented as \"0.5\", \".5e0\", etc.). • The boolean value true is converted to string \"true\" and the value false is converted to string \"false\". • Invalid can not be converted to a string value.  6.8.3 Conversions to Integer Legal conversions from other data types to integer are:  • A string can be converted into an integer value only if it contains a decimal representation of an integer number (see section 7.4 for the numeric string grammar rules for a decimal integer literal). • Floating-point value cannot be converted to an integer value.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 45(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            • The boolean value true is converted to integer value 1, false to 0. • Invalid can not be converted to an integer value.  6.8.4 Conversions to Floating-Point Legal conversions from other data types to floating-point are:  • A string can be converted into a floating-point value only if it contains a valid representation of a floating-point number (see section 7.4 for the numeric string grammar rules for a decimal floating-point literal). • An integer value is converted to a corresponding floating-point value. • The boolean value true is converted to a floating-point value 1.0, false to 0.0. • Invalid can not be converted to a floating-point value.  The conversions between a string and a floating-point type must be transitive within the ability of the data types to accurately represent the value. A conversion could result in loss of precision.  6.8.5 Conversions to Boolean Legal conversions from other data types to boolean are:  • The empty string (\"\") is converted to false. All other strings are converted to true. • An integer value 0 is converted to false. All other integer numbers are converted to true. • A floating-point value 0.0 is converted to false. All other floating-point numbers are converted to true. • Invalid can not be converted to a boolean value. 6.8.6 Conversions to Invalid There are no legal conversion rules for converting any of the other data types to an invalid type. Invalid is either a result of an operation error or a literal value. In most cases, an operator that has an invalid value as an operand evaluates to invalid (see the operators in sections 6.3.8, 6.3.9 and 6.3.10 for the exceptions to this rule).  6.8.7 Summary The following table contains a summary of the legal conversions between data types:  Given \\ Used as: Boolean Integer Floating-point String Boolean true - 1 1.0 \"true\" Boolean false - 0 0.0 \"false\" Integer 0 false - 0.0 \"0\" Any other integer true - floating-point value of number string representation of a decimal integer    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 46(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Given \\ Used as: Boolean Integer Floating-point String Floating-point 0.0 false Illegal - implementation-dependent string representation of a floating-point value, e.g. \"0.0\" Any other floating-point true Illegal - implementation-dependent string representation of a floating-point value Empty string false Illegal Illegal - Non-empty string true integer value of its string representation (if valid – see section 7.4 for numeric string grammar for decimal integer literals) or illegal floating-point value of its string representation (if valid – see section 7.4 for numeric string grammar for decimal floating-point literals) or illegal - invalid Illegal Illegal Illegal Illegal   6.9 Operator Data Type Conversion Rules The previous conversion rules specify when a legal conversion is possible between two data types. WMLScript operators use these rules, the operand data type and values to select the operation to be performed (in case the type is used to specify the operation) and to perform the data type conversions needed for the selected operation. The rules are specified in the following way:  • The additional conversion rules are specified in steps. Each step is performed in the given order until the operation and the data types for its operands are specified and the return value defined. • If the type of the operand value matches the required type then the value is used as such. • If the operand value does not match the required type then a conversion from the current data type to the required one is attempted: • Legal conversion: Conversion can be done only if the general conversion rules (see section 6.9) specify a legal conversion from the current operator data type to the required one. • Illegal conversion: Conversion can not be done if the general conversion rules (see section 6.9) do not specify a legal conversion from the current type to the required type. • If a legal conversion rule is specified for the operand (unary) or for all operands then the conversion is performed, the operation performed on the converted values and the result returned as the value of the operation. If a legal conversion results in an invalid value then the operation returns an invalid value. • If no legal conversion is specified for one or more of the operands then no conversion is performed and the next step in the additional conversion rules is performed.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 47(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            The following table contains the operator data type conversion rules based on the given operand data types:  Operand types Additional conversion rules Examples Boolean(s) ß If the operand is of type boolean or can be converted into a boolean value18 then perform a boolean operation and return its value, otherwise ß return invalid true && 3.4 => boolean 1 && 0 => boolean \"A\" || \"\" => boolean !42 => boolean !invalid => invalid 3 && invalid => invalid Integer(s) ß If the operand is of type integer or can be converted into an integer value18 then perform an integer operation and return its value, otherwise ß return invalid \"7\" << 2 => integer true << 2 => integer 7.2 >> 3 => invalid 2.1 div 4 => invalid Floating-point(s) ß If the operand is of type floating-point or can be converted into a floating-point value18 then perform a floating-point operation and return its value, otherwise ß return invalid - String(s) ß If the operand is of type string or can be converted into a string value18 then perform a string operation and return its value, otherwise ß return invalid - Integer or floating-point (unary) ß If the operand is of type integer or can be converted into an integer value then perform an integer operation and return its value, otherwise ß if the operand is of type floating-point or can be converted into a floating-point value18 then perform a floating-point operation and return its value, otherwise ß return invalid +10 =>   integer -10.3 =>     float -\"33\" =>   integer +\"47.3\" =>     float +true => integer 1 -false => integer 0 -\"ABC\" =>   invalid -\"9e9999\" =>   invalid                                                   18 Conversion can be done if the general conversion rules (see section Error! Reference source not found.) specify a legal conversion from the current type to the required type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 48(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Operand types Additional conversion rules Examples Integers or floating-points ß If  at least one of the operands is of type floating-point then convert the remaining operand to a floating-point value, perform a floating-point operation and return its value, otherwise ß if the operands are of type integer or can be converted into integer values18 then perform an integer operation and return its value, otherwise ß if the operands can be converted into floating-point values18 then perform a floating-point operation and return its value, otherwise ß return invalid 100/10.3 =>   float 33*44 => integer \"10\"*3 => integer 3.4*\"4.3\" =>   float \"10\"-\"2\" => integer \"2.3\"*\"3\" =>   float 3.2*\"A\" => invalid .9*\"9e999\" => invalid invalid*1 => invalid Integers, floating-points or strings ß If at least one of the operands is of type string then convert the remaining operand to a string value, perform a string operation and return its value, otherwise ß if  at least one of the operands is of type floating-point then convert the remaining operand to a floating-point value, perform a floating-point operation and return its value, otherwise ß if the operands are of type integer or can be converted into integer values18 then perform an integer operation and return its value, otherwise ß return invalid 12+3 => integer 32.4+65 =>   float \"12\"+5.4 =>  string 43.2<77 =>   float \"Hey\"<56 =>  string 2.7+\"4.2\" =>  string 9.9+true =>   float 3<false => integer \"A\"+invalid => invalid Any ß Any type is accepted a = 37.3 =>  float b = typeof \"s\" => string   6.10 Summary of Operators and Conversions The following sections contain a summary on how the conversion rules are applied to WMLScript operators and what are their possible return value types.  6.10.1 Single-Typed Operators Operators that accept operands of one specific type use the general conversion rules directly. The following list contains all single type WMLScript operators:     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 49(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Operator Operand types Result type19 Operation performed ! boolean boolean logical NOT (unary) && booleans boolean logical AND || booleans boolean logical OR ~ integer integer bitwise NOT (unary) << integers integer bitwise left shift >> integers integer bitwise right shift with sign >>> integers integer bitwise right shift with zero fill & integers integer bitwise AND ^ integers integer bitwise XOR | integers integer bitwise OR % integers integer remainder div integers integer integer division <<=, >>=, >>>=, &=, ^=, |= first operand: variable second operand: integer integer assignment with bitwise operation %=, div= first operand: variable second operand: integer integer assignment with numeric operation  6.10.2 Multi-Typed Operators The following sections contain the operators that accept multi-typed operands:   Operator Operand types Result type20 Operation performed ++ integer or floating-point integer/floating-point pre- or post-increment (unary) -- integer or floating-point integer/floating-point pre- or post-decrement (unary) + integer or floating-point integer/floating-point unary plus - integer or floating-point integer/floating-point unary minus (negation) * integers or floating-points integer/floating-point multiplication / integers or floating-points floating-point division - integers or floating-points integer/floating-point subtraction + integers, floating-points or strings integer/floating-point/string addition or string concatenation                                                  19 All operators may have an invalid result type. 20 All operators (unless otherwise stated) may have an invalid result type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 50(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Operator Operand types Result type20 Operation performed <, <= integers, floating-points or strings boolean less than, less than or equal >, >= integers, floating-points or strings boolean greater than, greater or equal == integers, floating-points or strings boolean equal (identical values) != integers, floating-points or strings boolean not equal (different values) *=, -= first operand: variable second operand: integer or floating-point integer/floating-point assignment with numeric operation /= first operand: variable second operand: integer or floating-point floating-point assignment with division += first operand: variable second operand: integer, floating-point or string integer/floating-point/string assignment with addition or concatenation typeof any integer21 return internal data type (unary) isvalid any boolean21 check for validity (unary) ? : first operand: boolean second operand: any third operand: any any conditional expression = first operand: variable second operand: any any assignment , first operand: any second operand: any any multiple evaluation                                                   21 Operator does not generate an invalid result type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 51(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             7. WMLSCRIPT GRAMMAR The grammars used in this specification are based on [ECMA262]. Since WMLScript is not compliant with ECMAScript, the standard has been used only as the basis for defining WMLScript language.   7.1 Context-Free Grammars This section describes the context-free grammars used in this specification to define the lexical and syntactic structure of a WMLScript program.  7.1.1 General A context-free grammar consists of a number of productions. Each production has an abstract symbol called a nonterminal as its left-hand side and a sequence of one or more nonterminal and terminal symbols as its right-hand side. For each grammar, the terminal symbols are drawn from a specified alphabet.  A given context-free grammar specifies a language. It begins with a production consisting of a single distinguished nonterminal called the goal symbol followed by a (perhaps infinite) set of possible sequences of terminal symbols. They are the result of repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.  7.1.2 Lexical Grammar A lexical grammar for WMLScript is given in section 7.2. This grammar has as its terminal symbols the characters of the Universal Character set of ISO/IEC-10646 ([ISO10646]). It defines a set of productions, starting from the goal symbol Input that describes how sequences of characters are translated into a sequence of input elements.  Input elements other than white space and comments form the terminal symbols for the syntactic grammar for WMLScript and are called WMLScript tokens. These tokens are the reserved words, identifiers, literals and punctuators of the WMLScript language. Simple white space and single-line comments are simply discarded and do not appear in the stream of input elements for the syntactic grammar. Likewise, a multi-line comment is simply discarded if it contains no line terminator; but if a multi-line comment contains one or more line terminators, then it is replaced by a single line terminator, which becomes part of the stream of input elements for the syntactic grammar.  Productions of the lexical grammar are distinguished by having two colons \"::\" as separating punctuation.  7.1.3 Syntactic Grammar The syntactic grammar for WMLScript is given in section 7.3. This grammar has WMLScript tokens defined by the lexical grammar as its terminal symbols. It defines a set of productions, starting from the goal symbol CompilationUnit, that describe how sequences of tokens can form syntactically correct WMLScript programs.  When a stream of Unicode characters is to be parsed as a WMLScript, it is first converted to a stream of input elements by repeated application of the lexical grammar; this stream of input elements is then parsed by a single application of the syntax grammar. The program is syntactically    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 52(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal CompilationUnit, with no tokens left over.  Productions of the syntactic grammar are distinguished by having just one colon \":\" as punctuation.  7.1.4 Numeric String Grammar A third grammar is used for translating strings into numeric values. This grammar is similar to the part of the lexical grammar having to do with numeric literals and has as its terminal symbols the characters of the Unicode character set. This grammar appears in section 7.4.  Productions of the numeric string grammar are distinguished by having three colons “:::” as punctuation.  7.1.5 Grammar Notation Terminal symbols of the lexical and string grammars and some of the terminal symbols of the syntactic grammar, are shown in fixed width font, both in the productions of the grammars and throughout this specification whenever the text directly refers to such a terminal symbol. These are to appear in a program exactly as written.  Nonterminal symbols are shown in italic type. The definition of a nonterminal is introduced by the name of the nonterminal being defined followed by one or more colons. (The number of colons indicates to which grammar the production belongs.) One or more alternative right-hand sides for the nonterminal then follow on succeeding lines. For example, the syntactic definition: WhileStatement : while ( Expression ) Statement states that the nonterminal WhileStatement represents the token while, followed by a left parenthesis token, followed by an Expression, followed by a right parenthesis token, followed by a Statement. The occurrences of Expression and Statement are themselves nonterminals. As another example, the syntactic definition: ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression states that an ArgumentList may represent either a single AssignmentExpression or an ArgumentList, followed by a comma, followed by an AssignmentExpression. This definition of ArgumentList is recursive, that is to say, it is defined in terms of itself. The result is that an ArgumentList may contain any positive number of arguments, separated by commas, where each argument expression is an AssignmentExpression. Such recursive definitions of nonterminals are common.  The subscripted suffix \"opt\", which may appear after a terminal or nonterminal, indicates an optional symbol. The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it. This means that: VariableDeclaration : Identifier VariableInitializeropt  is a convenient abbreviation for:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 53(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            VariableDeclaration : Identifier Identifier VariableInitializer and that: IterationStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement is a convenient abbreviation for: IterationStatement : for ( ; Expressionopt ; Expressionopt ) Statement for ( Expression ; Expressionopt ; Expressionopt ) Statement which in turn is an abbreviation for: IterationStatement : for ( ; ; Expressionopt ) Statement for ( ; Expression ; Expressionopt ) Statement for ( Expression ; ; Expressionopt ) Statement for ( Expression ; Expression ; Expressionopt ) Statement which in turn is an abbreviation for: IterationStatement : for ( ; ; ) Statement for ( ; ; Expression ) Statement for ( ; Expression ; ) Statement for ( ; Expression ; Expression ) Statement for ( Expression ; ; ) Statement for ( Expression ; ; Expression ) Statement for ( Expression ; Expression ; ) Statement for ( Expression ; Expression ; Expression ) Statement therefore, the nonterminal IterationStatement actually has eight alternative right-hand sides.  Any number of occurrences of LineTerminator may appear between any two consecutive tokens in the stream of input elements without affecting the syntactic acceptability of the program.  When the words \"one of\" follow the colon(s) in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition. For example, the lexical grammar for WMLScript contains the production: ZeroToThree :: one of 0 1 2 3 which is merely a convenient abbreviation for: ZeroToThree :: 0 1 2    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 54(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            3 When an alternative in a production of the lexical grammar or the numeric string grammar appears to be a multicharacter token, it represents the sequence of characters that would make up such a token.  The right-hand side of a production may specify that certain expansions are not permitted by using the phrase \"but not\" and then indicating the expansions to be excluded. For example, the production: Identifier :: IdentifierName but not ReservedWord means that the nonterminal Identifier may be replaced by any sequence of characters that could replace IdentifierName provided that the same sequence of characters could not replace ReservedWord.  Finally, a few nonterminal symbols are described by a descriptive phrase in roman type in cases where it would be impractical to list all the alternatives: SourceCharacter: any Unicode character  7.1.6 Source Text WMLScript source text is represented as a sequence of characters representable using the Universal Character set of ISO/IEC-10646 ([ISO10646]). Currently, this character set is identical to Unicode 2.0 ([UNICODE]). Within this document, the terms ISO10646 and Unicode are used interchangeably and will indicate the same document character set. SourceCharacter :: any Unicode character There is no requirement that WMLScript documents be encoded using the full Unicode encoding (e.g. UCS-4). Any character encoding (\"charset\") that contains an inclusive subset of the characters in Unicode may be used (e.g. US-ASCII, ISO-8859-1, etc.).  Every WMLScript program can be represented using only ASCII characters (which are equivalent to the first 128 Unicode characters). Non-ASCII Unicode characters may appear only within comments and string literals. In string literals, any Unicode character may also be expressed as a Unicode escape sequence consisting of six ASCII characters, namely \\u plus four hexadecimal digits. Within a comment, such an escape sequence is effectively ignored as part of the comment. Within a string literal, the Unicode escape sequence contributes one character to the string value of the literal.   7.1.7 Character Set Resolution When a WMLScript document is accompanied by external information (e.g. HTTP or MIME) there may be multiple sources of information available to determine the character encoding. In this case, their relative priority and the preferred method of handling conflict should be specified as part of the higher-level protocol. See, for example, the documentation of the \"text/vnd.wap.wmlscript\" and \"application/vnd.wap.wmlscriptc\" MIME media types.  The pragma meta http equiv (see section 6.7.3.2), if present in the document, is never used to determine the character encoding.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 55(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            If a WMLScript document is transformed into a different format - for example, into the WMLScript bytecode (see section 9.2) - then the rules relevant for that format are used to determine the character encoding.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 56(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             7.2 WMLScript Lexical Grammar The following contains the specification of the lexical grammar for WMLScript:  SourceCharacter :: any Unicode character WhiteSpace :: <TAB> <VT> <FF> <SP> <LF> <CR> LineTerminator :: <LF> <CR> <CR><LF> Comment :: MultiLineComment SingleLineComment MultiLineComment :: /* MultiLineCommentCharsopt */ MultiLineCommentChars :: MultiLineNotAsteriskChar MultiLineCommentCharsopt * PostAsteriskCommentCharsopt PostAsteriskCommentChars :: MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt * PostAsteriskCommentCharsopt MultiLineNotAsteriskChar :: SourceCharacter but not asterisk * MultiLineNotForwardSlashOrAsteriskChar :: SourceCharacter but not forward-slash / or asterisk * SingleLineComment :: // SingleLineCommentCharsopt SingleLineCommentChars :: SingleLineCommentChar SingleLineCommentCharsopt    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 57(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            SingleLineCommentChar :: SourceCharacter but not LineTerminator Token :: ReservedWord Identifier Punctuator Literal ReservedWord :: Keyword KeywordNotUsedByWMLScript FutureReservedWord BooleanLiteral InvalidLiteral Keyword :: one of access equiv meta while agent extern name url break for path  continue function return  div header typeof  div= http use  domain if user  else isvalid var  KeywordNotUsedByWMLScript :: one of delete null in this lib void new with FutureReservedWord :: one of case default finally struct catch do import super class enum private switch const export public throw debugger extends sizeof try Identifier :: IdentifierName but not ReservedWord IdentifierName :: IdentifierLetter IdentifierName IdentifierLetter IdentifierName DecimalDigit    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 58(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            IdentifierLetter :: one of22 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _                          DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9 Punctuator :: one of23 = > < == <= >= != , ! ~ ? : . && || ++ -- + - * / & | ^ % << >> >>> += -= *= /= &= |= ^= %= <<= >>= >>>= ( ) { } ; #    Literal ::24 InvalidLiteral BooleanLiteral NumericLiteral StringLiteral InvalidLiteral ::25 invalid BooleanLiteral ::26 true false NumericLiteral :: DecimalIntegerLiteral HexIntegerLiteral OctalIntegerLiteral DecimalFloatLiteral DecimalIntegerLiteral :: 0 NonZeroDigit DecimalDigitsopt                                                  22 Compatibility note: ECMAScript supports the usage of dollar sign ($) in identifier names, too. 23 Compatibility note: ECMAScript supports arrays and square brackets ([ ]), too. 24 Compatibility note: ECMAScript supports Null literal, too. 25 Compatibility note: ECMAScript does not support invalid. 26 Compatibility note: ECMAScript supports both lower and upper case boolean literals.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 59(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            NonZeroDigit :: one of 1 2 3 4 5 6 7 8 9 HexIntegerLiteral :: 0x HexDigit 0X HexDigit HexIntegerLiteral HexDigit HexDigit :: one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F OctalIntegerLiteral :: 0 OctalDigit OctalIntegerLiteral OctalDigit OctalDigit :: one of 0 1 2 3 4 5 6 7 DecimalFloatLiteral :: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPart DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit ExponentPart :: ExponentIndicator SignedInteger ExponentIndicator :: one of e E SignedInteger :: DecimalDigits + DecimalDigits - DecimalDigits StringLiteral :: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt  ' DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharactersopt SingleStringCharacters :: SingleStringCharacter SingleStringCharactersopt    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 60(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            DoubleStringCharacter :: SourceCharacter but not double-quote \"or backslash \\ or LineTerminator EscapeSequence SingleStringCharacter :: SourceCharacter but not single-quote 'or backslash \\ or LineTerminator EscapeSequence EscapeSequence :: CharacterEscapeSequence OctalEscapeSequence HexEscapeSequence UnicodeEscapeSequence CharacterEscapeSequence ::  \\ SingleEscapeCharacter SingleEscapeCharacter ::  one of ' \" \\ / b f n r t HexEscapeSequence :: \\x HexDigit HexDigit OctalEscapeSequence :: \\ OctalDigit \\ OctalDigit OctalDigit \\ ZeroToThree OctalDigit OctalDigit ZeroToThree :: one of 0 1 2 3 UnicodeEscapeSequence :: \\u HexDigit HexDigit HexDigit HexDigit    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 61(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             7.3 WMLScript Syntactic Grammar The following contains the specification of the syntactic grammar for WMLScript: PrimaryExpression :27 Identifier Literal ( Expression ) CallExpression : 28 PrimaryExpression LocalScriptFunctionCall ExternalScriptFunctionCall LibraryFunctionCall LocalScriptFunctionCall : FunctionName Arguments ExternalScriptFunctionCall : ExternalScriptName # FunctionName Arguments LibraryFunctionCall : LibraryName . FunctionName Arguments FunctionName : Identifier ExternalScriptName : Identifier LibraryName : Identifier Arguments : ( ) ( ArgumentList  ) ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression                                                  27 Compatibility note: ECMAScript supports objects and this, too. 28 Compatibility note: ECMAScript support for arrays ([]) and object allocation (new) removed. MemberExpression is used for specifying library functions, e.g. String.length(\"abc\"), not for accessing members of an object.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 62(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            PostfixExpression : CallExpression  Identifier ++ Identifier -- UnaryExpression :29 PostfixExpression typeof UnaryExpression isvalid UnaryExpression ++ Identifier -- Identifier + UnaryExpression - UnaryExpression ~ UnaryExpression ! UnaryExpression MultiplicativeExpression :30 UnaryExpression MultiplicativeExpression * UnaryExpression MultiplicativeExpression / UnaryExpression MultiplicativeExpression div UnaryExpression MultiplicativeExpression % UnaryExpression AdditiveExpression : MultiplicativeExpression AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression ShiftExpression : AdditiveExpression ShiftExpression << AdditiveExpression ShiftExpression >> AdditiveExpression ShiftExpression >>> AdditiveExpression RelationalExpression : ShiftExpression RelationalExpression < ShiftExpression RelationalExpression > ShiftExpression RelationalExpression <= ShiftExpression RelationalExpression >= ShiftExpression                                                  29 Compatibility note: ECMAScript operators delete and void are not supported. parseInt and parseFloat are supported as library functions. ECMAScipt does not support operator isvalid. 30 Compatibility note: Integer division (div) is not supported by ECMAScript.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 63(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            EqualityExpression : RelationalExpression EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression BitwiseANDExpression : EqualityExpression BitwiseANDExpression & EqualityExpression BitwiseXORExpression : BitwiseANDExpression BitwiseXORExpression ^ BitwiseANDExpression BitwiseORExpression : BitwiseXORExpression BitwiseORExpression | BitwiseXORExpression LogicalANDExpression : BitwiseORExpression LogicalANDExpression && BitwiseORExpression LogicalORExpression : LogicalANDExpression LogicalORExpression || LogicalANDExpression ConditionalExpression : LogicalORExpression LogicalORExpression ? AssignmentExpression : AssignmentExpression AssignmentExpression : ConditionalExpression Identifier AssignmentOperator AssignmentExpression AssignmentOperator :: one of = *= /= %= += -= <<= >>= >>>= &= ^= |= div= Expression : AssignmentExpression Expression , AssignmentExpression    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 64(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Statement :31 Block VariableStatement EmptyStatement ExpressionStatement IfStatement  IterationStatement ContinueStatement BreakStatement ReturnStatement Block : { StatementListopt } StatementList : Statement   StatementList Statement  VariableStatement : var VariableDeclarationList ; VariableDeclarationList : VariableDeclaration VariableDeclarationList , VariableDeclaration VariableDeclaration : Identifier VariableInitializeropt VariableInitializer : = ConditionalExpression EmptyStatement : ; ExpressionStatement : Expression ; IfStatement :32 if ( Expression ) Statement else Statement  if ( Expression ) Statement  IterationStatement :33 WhileStatement  ForStatement                                                    31 Compatibility note: ECMAScript with statement is not supported. 32 else is always tied to the closest if. 33 Compatibility note: ECMAScript for in statement is not supported.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 65(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            WhileStatement : while ( Expression ) Statement   ForStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement  for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement  ContinueStatement :34 continue ; BreakStatement :35 break ; ReturnStatement : return Expressionopt ; FunctionDeclaration :36 externopt  function Identifier ( FormalParameterListopt ) Block ;opt FormalParameterList : Identifier FormalParameterList , Identifier CompilationUnit : Pragmasopt FunctionDeclarations Pragmas :37 Pragma Pragmas Pragma Pragma : use PragmaDeclaration ; PragmaDeclaration : ExternalCompilationUnitPragma AccessControlPragma MetaPragma ExternalCompilationUnitPragma : url Identifier StringLiteral                                                   34 Continue statement can only be used inside a while or a for statement. 35 Break statement can only be used inside a while or a for statement. 36 Compatibility note: ECMAScript does not support keyword extern. 37 Compatibility note: ECMAScript does not support pragmas.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 66(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            AccessControlPragma :38 access AccessControlSpecifier AccessControlSpecifier : domain StringLiteral path StringLiteral domain StringLiteral path StringLiteral MetaPragma : meta MetaSpecifier MetaSpecifier : MetaName MetaHttpEquiv MetaUserAgent MetaName : name MetaBody MetaHttpEquiv : http equiv MetaBody MetaUserAgent : user agent MetaBody MetaBody : MetaPropertyName MetaContent MetaSchemeopt MetaPropertyName : StringLiteral MetaContent : StringLiteral MetaScheme : StringLiteral FunctionDeclarations : FunctionDeclaration FunctionDeclarations FunctionDeclaration   7.4 Numeric String Grammar The following contains the specification of the numeric string grammar for WMLScript. This grammar is used for translating strings into numeric values. This grammar is similar to the part of the lexical                                                  38 Compilation unit can contain only one access control pragma.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 67(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            grammar having to do with numeric literals and has as its terminal symbols the characters of the US-ASCII character set.  The following grammar can be used to convert strings into the following numeric literal values:   • Decimal Integer Literal: Use the following productions starting from the goal symbol StringDecimalIntegerLiteral. • Decimal Floating-Point Literal: Use the following productions starting from the goal symbol StringDecimalFloatingPointLiteral.  StringDecimalIntegerLiteral ::: StrWhiteSpaceopt StrSignedDecimalIntegerLiteral StrWhiteSpaceopt StringDecimalFloatingPointLiteral ::: StrWhiteSpaceopt StrSignedDecimalIntegerLiteral StrWhiteSpaceopt StrWhiteSpaceopt StrSignedDecimalFloatingPointLiteral StrWhiteSpaceopt StrWhiteSpace ::: StrWhiteSpaceChar StrWhiteSpaceopt StrWhiteSpaceChar ::: <TAB> <VT> <FF> <SP> <LF> <CR> StrSignedDecimalIntegerLiteral ::: StrDecimalDigits  + StrDecimalDigits - StrDecimalDigits StrSignedDecimalFloatingPointLiteral ::: StrDecimalFloatingPointLiteral  + StrDecimalFloatingPointLiteral  - StrDecimalFloatingPointLiteral StrDecimalFloatingPointLiteral ::: StrDecimalDigits . StrDecimalDigitsopt StrExponentPartopt . StrDecimalDigits StrExponentPartopt StrDecimalDigits StrExponentPart StrDecimalDigits ::: StrDecimalDigit StrDecimalDigits StrDecimalDigit    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 68(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            StrDecimalDigit ::: one of 0 1 2 3 4 5 6 7 8 9 StrExponentPart ::: StrExponentIndicator StrSignedInteger StrExponentIndicator ::: one of e E StrSignedInteger ::: StrDecimalDigits + StrDecimalDigits - StrDecimalDigits     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 69(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             8. WMLSCRIPT BYTECODE INTERPRETER The textual format of WMLScript language must be compiled into a binary format before it can be interpreted by the WMLScript bytecode interpreter. WMLScript compiler encodes one WMLScript compilation unit into WMLScript bytecode using the encoding format presented in the chapter 9. A WMLScript compilation unit (see section 7.1.3) is a unit containing pragmas and any number of WMLScript functions. WMLScript compiler takes one compilation unit as input and generates the WMLScript bytecode as its output.   8.1 Interpreter Architecture WMLScript interpreter takes WMLScript bytecode as its input and executes encoded functions as they are called. The following figure contains the main parts related to WMLScript bytecode interpretation:  IPVariablesCall StackFunctionscall http://www.host.com/script#myFunc(“Test”,12)OperandStackStateWMLScriptBytecodeWMLScriptLibrariesInterpreterFunctions...myFunc()...www.host.com/script: Figure 1: General architecture of the WMLScript interpreter  The WMLScript interpreter can be used to call and execute functions in a compilation unit encoded as WMLScript bytecode. Each function specifies the number of parameters it accepts and the instructions used to express its behaviour. Thus, a call to a WMLScript function must specify the function, the function call arguments and the compilation unit in which the function is declared. Once the execution completes normally, the WMLScript interpreter returns the control and the return value back to the caller.  Execution of a WMLScript function means interpreting the instructions residing in the WMLScript bytecode. While a function is being interpreted, the WMLScript interpreter maintains the following state information:  • IP (Instruction Pointer): This points to an instruction in the bytecode that is being interpreted. • Variables: Maintenance of function parameters and variables.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 70(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            • Operand stack: It is used for expression evaluation and passing arguments to called functions and back to the caller. • Function call stack: WMLScript function can call other functions in the current or separate compilation unit or make calls to library functions. The function call stack maintains the information about functions and their return addresses.    8.2 Character Set The WMLScript Interpreter must use only one character set (native character set) for all of its string operations. Transcoding between different character sets and their encodings is allowed as long as the WMLScript string operations are performed using only the native character set. The native character set can be requested by using the Lang library function Lang.characterSet() (see [WMLSLibs])   8.3 WMLScript and URLs The World Wide Web is a network of information and devices. Three areas of specification ensure widespread interoperability:  • A unified naming model. Naming is implemented with Uniform Resource Locators (URLs), which provide standard way to name any network resource. See [RFC2396]. • Standard protocols to transport information (e.g. HTTP). • Standard content types (e.g. HTML, WMLScript).  WMLScript assumes the same reference architecture as HTML and the World Wide Web. WMLScript compilation unit is named using URLs and can be fetched over standard protocols that have HTTP semantics, such as [WSP]. URLs are defined in [RFC2396]. The character set used to specify URLs is also defined in [RFC2396].  In WMLScript, URLs are used in the following situations:  • When a user agent wants to make a WMLScript call (see section 8.3.4) • When specifying external compilation units (see section 6.7.1) • When specifying access control information (see section 6.7.2)  8.3.1 URL Schemes A WMLScript interpreter must implement the URL schemes specified in [WAE].  8.3.2 Fragment Anchors WMLScript has adopted the HTML de facto standard of naming locations within a resource. A WMLScript fragment anchor is specified by the document URL, followed by a hash mark (#), followed by a fragment identifier. WMLScript uses fragment anchors to identify individual WMLScript functions within a WMLScript compilation unit. The syntax of the fragment anchor is specified in the following section.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 71(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            8.3.3 URL Call Syntax This section contains the grammar for specifying the syntactic structure of the URL call. This grammar is similar to the part of the WMLScript lexical and syntactic grammars having to do with function calls and literals and has as its terminal symbols the characters of the US-ASCII character set.  http://www.host.com/scr#foo(1,-3,'hello')       // OK http://www.host.com/scr#bar(1,-3+1,'good')      // Error http://www.host.com/scr#test(foo(1,-3,'hello')) // Error  Only the syntax for the fragment anchor (#) is specified (see [RFC2396] for more information about URL syntax).  URLCallFragmentAnchor ::: FunctionName( ) FunctionName( ArgumentList ) FunctionName ::: FunctionNameLetter FunctionName FunctionNameLetter FunctionName DecimalDigit FunctionNameLetter ::: one of a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _                          DecimalDigit ::: one of 0 1 2 3 4 5 6 7 8 9 ArgumentList : Argument ArgumentList , Argument Argument ::: WhiteSpacesopt Literal WhiteSpacesopt WhiteSpaces : WhiteSpace White Spaces WhiteSpace WhiteSpace ::: <TAB> <VT> <FF> <SP> <LF> <CR>    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 72(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Literal ::: InvalidLiteral BooleanLiteral NumericLiteral StringLiteral InvalidLiteral ::: invalid BooleanLiteral ::: true false NumericLiteral ::: SignedDecimalIntegerLiteral SignedDecimalFloatLiteral SignedDecimalIntegerLiteral ::: DecimalIntegerLiteral + DecimalIntegerLiteral - DecimalIntegerLiteral DecimalIntegerLiteral ::: DecimalDigit DecimalDigitsopt SignedDecimalFloatLiteral ::: DecimalFloatLiteral + DecimalFloatLiteral - DecimalFloatLiteral DecimalFloatLiteral ::: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPart DecimalDigits ::: DecimalDigit DecimalDigits DecimalDigit ExponentPart ::: ExponentIndicator SignedInteger ExponentIndicator ::: one of e E SignedInteger ::: DecimalDigits + DecimalDigits - DecimalDigits    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 73(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            StringLiteral ::: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt  ' DoubleStringCharacters ::: DoubleStringCharacter DoubleStringCharactersopt SingleStringCharacters ::: SingleStringCharacter SingleStringCharactersopt DoubleStringCharacter ::: SourceCharacter but not double-quote \" SingleStringCharacter ::: SourceCharacter but not single-quote '  8.3.4 URL Calls and Parameter Passing A user agent can make a call to an external WMLScript function by providing the following information using URLs and fragment anchors:  • URL of the compilation unit (e.g. http://www.x.com/myScripts.scr) • Function name and parameters as the fragment anchor (e.g. testFunc('Test%20argument',-8))  The final URL with the fragment is:  http://www.x.com/myScripts.scr#testFunc('Test%20argument',-8)  If the given URL denotes a valid WMLScript compilation unit then:  • Access control checks are performed (see section 6.7.2). The call fails if the caller does not have rights to call the compilation unit. • The function name specified in the fragment anchor is matched against the external functions in the compilation unit. The call fails if no match is found. • The parameter list in the fragment anchor (see section 8.3.2) is parsed and the given arguments with their appropriate types (string literals as string data types, integer literals as integer data types etc.) are passed to the function. The call fails if the parameter list has an invalid syntax.  8.3.5 Character Escaping URL calls can use URL escaping (see [RFC2396]) and any other escaping mechanism provided by the content format containing the URL call to specify the URL. However, the URL Call Syntax is applied to the URL fragment only after it has been properly unescaped.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 74(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            8.3.6 Relative URLs WMLScript has adopted the use of relative URLs, as specified in [RFC2396]. [RFC2396] specifies the method used to resolve relative URLs in the context of a WMLScript compilation unit. The base URL of a WMLScript compilation unit is the URL that identifies the compilation unit.   8.4 Bytecode Semantics The following sections describe the general encoding rules that must be used to generate WMLScript bytecode. These rules specify what the WMLScript compiler can assume from the behaviour of the WMLScript interpreter.  8.4.1 Passing of Function Arguments Arguments must be present in the operand stack in the same order as they are presented in a WMLScript function declaration at the time of a WMLScript or library function call. Thus, the first argument is pushed into the operand stack first, the second argument is pushed next, etc. The instruction executing the call must pop the arguments from the operand stack and use them to initialise the appropriate function variables.  8.4.2 Allocation of Variable Indexes A WMLScript function refers to variables by using unique variable indexes. These indexes must match with the information specified for each called WMLScript function: the number of arguments the function accepts and the number of local variables used by the function. Thus, the variable index allocation must be done using the following rules:  1) Function Arguments: Indexes for function arguments must be allocated first. The allocation must be done in the same order as the arguments are pushed into the operand stack (0 is allocated for the first argument, 1 for the second argument, etc.). The number of indexes allocated for function arguments must match the number of arguments accepted by the function. Thus, if the function accepts N arguments then the last variable index must be N-1. If the function does not accept any arguments (N = 0) then no variable indexes are allocated.  2) Local variables: Indexes for local variables must be allocated subsequently from the first variable index (N) that is not used for function arguments. The number of indexes allocated for local variables must match the number of local variables used by the function.  8.4.3 Automatic Function Return Value WMLScript function must return an empty string in case the end of the function is encountered without a return statement. The compiler can rely on the WMLScript interpreter to automatically return an empty string every time the interpreter reaches the end of the function without encountering a return instruction.  8.4.4 Initialisation of Variables The WMLScript compiler should rely on the WMLScript interpreter to initialise all function local variables initially to an empty string. Thus, the compiler does not have to generate initialization code for variables declared without initialisation.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 75(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            8.5 Access Control WMLScript provides two mechanisms for controlling the access to the functions in the WMLScript compilation unit: external keyword and a specific access control pragma. Thus, the WMLScript interpreter must support the following behaviour:  • External functions: Only functions specified as external can be called from other compilation units (see section 6.4.2.2). • Access control: Access to the external functions defined inside a compilation unit is allowed from other compilation units that match the given access domain and access path definitions (see section 6.7.2).      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 76(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             9. WMLSCRIPT BINARY FORMAT The following sections contain the specifications for the WMLScript bytecode, a compact binary representation for compiled WMLScript functions. The format was designed to allow for compact transmission over narrowband channels, with no loss of functionality or semantic information.  9.1 Conventions The following sections describe the general encoding conventions and data types used to generate WMLScript bytecode.  9.1.1 Used Data Types The following data types are used in the specification of the WMLScript Bytecode:  Data Type Definition bit 1 bit of data byte 8 bits of opaque data int8 8 bit signed integer (two's complement encoding) u_int8 8 bit unsigned integer int16 16 bit signed integer (two's complement encoding) u_int16 16 bit unsigned integer mb_u_int16 16 bit unsigned integer, in multi-byte integer format. See section 9.1.2 for more information. int32 32 bit signed integer (two's complement encoding) u_int32 32 bit unsigned integer mb_u_int32 32 bit unsigned integer, in multi-byte integer format. See section 9.1.2 for more information. float32 32 bit signed floating-point value in ANSI/IEEE Std 754-1985  [IEEE754] format.  Network byte order for multi-byte integer values is \"big-endian\". In other words, the most significant byte is transmitted on the network first followed subsequently by the less significant bytes. Network bit ordering for bit fields within a byte is \"big-endian\". In other words, bit fields described first are placed in the most significant bits of the byte.  9.1.2 Multi-byte Integer Format This encoding uses a multi-byte representation for integer values. A multi-byte integer consists of a series of octets, where the most significant bit is the continuation flag and the remaining seven bits are a scalar value. The continuation flag is used to indicate that an octet is not the end of the multi-byte sequence. A single integer value is encoded into a sequence of N octets. The first N-1 octets have the continuation flag set to a value of one (1). The final octet in the series has a continuation flag value of zero.  The remaining seven bits in each octet are encoded in a big-endian order, e.g., most significant bit first. The octets are arranged in a big-endian order, e.g. the most significant seven bits are transmitted first. In the situation where the initial octet has less than seven bits of value, all unused bits must be set to zero (0).    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 77(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             For example, the integer value 0xA0 would be encoded with the two-byte sequence 0x81 0x20. The integer value 0x60 would be encoded with the one-byte sequence 0x60.  9.1.3 Character Encoding WMLScript bytecode supports the following character encoding:  • UTF-8 (see [RFC2279])  Other character sets and their encodings are supported by a special string type (string with external character encoding definition, see section 9.4.1.3.3) that does not explicitly specify the used character set or its encoding but assumes that this information is provided as part of the compilation unit itself (constant pool). The following rules must be applied when defining the used character encoding for these special strings:  • If the value of the character set number in the constant pool is non-zero then this number defines the used character encoding (the number denotes the MIBEnum value assigned by the IANA for all character sets). • If the value of the character set number in the constant pool is zero (0) then the character set is unknown.  The compiler must select one of these encodings to encode character strings in the WMLScript bytecode.  WMLScript language constructs, such as function names in WMLScript, are written by using only a subset of Unicode character set i.e, a subset of US-ASCII characters. Thus, function names in the WMLScript bytecode must use a fixed UTF-8 encoding.  9.1.4 Notational Conventions WMLScript bytecode is a set of bytes that represent WMLScript functions in a binary format. It contains all the information needed by the WMLScript interpreter to execute the encoded functions as specified. The bytecode can be divided into sections and subsections each of which containing a binary representation of a logical WMLScript unit.  The WMLScript bytecode structure and content is presented using the following table based notation:  Name Data type and size Comment This is a name of a section inside the bytecode. This specifies a data type and its size reserved for a section in case it cannot be divided into smaller subsections. Subsection specification is given in a separate table. Reference to the table is provided. This gives a general overview of the meaning of this section.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 78(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Name Data type and size Comment The name of the next section. Any number of sections can be presented in one table.   ...     The following conventions apply:  • Sections of bytecode are represented as rows in a table. • Each section may be divided into subsections and represented in separate tables. In such case a reference to the subsection table is provided. • Repetitive sections are denoted by section name followed by three dots (...).   9.2 WMLScript Bytecode The WMLScript encoding contains two major elements: constant literals and the constructs needed to describe the behaviour of each WMLScript function. Thus, the WMLScript bytecode consists of the following sections:  Name Data type and size Comment HeaderInfo See section 9.3 Contains general information related to the bytecode. ConstantPool See section 9.4 Contains the information of all constants specified as part of the WMLScript compilation unit that are encoded into bytecode. PragmaPool See section 9.5  Contains the information related to pragmas specified as part of the WMLScript compilation unit that are encoded into bytecode. FunctionPool See section 9.6 Contains all the information related to the encoding of functions and their behaviour.  The following sections define the encoding of these sections and their subsections in detail.   9.3 Bytecode Header The header of the WMLScript bytecode contains the following information:     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 79(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Name Data type and size Comment VersionNumber byte Version number of the WMLScript bytecode. The version byte contains the major version minus one in the upper 4 bits and the minor version in the lower 4 bits.  The current version is 1.1. Thus, the version number must be encoded as 0x01. CodeSize mb_u_int32 The size of the rest of the bytecode (not including the version number and this variable) in bytes   9.4 Constant Pool Constant pool contains all the constants used by the WMLScript functions. Each of the constants has an index number starting from zero that is defined by its position in the list of constants. The instructions use this index to refer to specific constants.  Name Data type and size Comment NumberOfConstants mb_u_int16 Specifies how many constants are encoded in this pool. CharacterSet mb_u_int16 Specifies the character set used by the string constants in the constant pool. The character set is specified as an integer that denotes a MIBEnum value assigned by the IANA for all character sets (see [WSP] for more information). Constants... See section 9.4.1 Contains the definitions for each constant in the constant pool. The number of constants is specified by NumberOfConstants.   9.4.1 Constants Constants are stored into the bytecode one after each other. Encoding of each constant starts with the definition of its type (integer, floating-point, string etc.). It is being followed by constant type specific data that represents the actual value of the constant:  Name Data type and size Comment ConstantType u_int8 The type of the constant. ConstantValue See sections 9.4.1.1, 9.4.1.2 and 9.4.1.3 Type specific value definition.  The following encoding for constant types is used:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 80(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             Code Type Encoding 0 8 bit signed integer 9.4.1.1.1 1 16 bit signed integer 9.4.1.1.2 2 32 bit signed integer 9.4.1.1.3 3 32 bit signed floating-point 9.4.1.2 4 UTF-8 String 9.4.1.3.1 5 Empty String 9.4.1.3.2 6 String with external character encoding definition 9.4.1.3.3 7-255 Reserved for future use   9.4.1.1 Integers WMLScript bytecode supports 8 bit, 16 bit and 32 bit signed integer constants. The compiler can optimise the WMLScript bytecode size by selecting the smallest integer constant type that can still hold the integer constant value.  9.4.1.1.1 8 Bit Signed Integer 8 bit signed integer constants are represented in the following format:  Name Data type and size Comment ConstantInteger8 int8 The value of the 8 bit signed integer constant.  9.4.1.1.2 16 Bit Signed Integer 16 bit signed integer constants are represented in the following format:  Name Data type and size Comment ConstantInteger16 int16 The value of the 16 bit signed integer constant.  9.4.1.1.3 32 Bit Signed Integer 32 bit signed integer constants are represented in the following format:  Name Data type and size Comment ConstantInteger32 int32 The value of the 32 bit signed integer constant.   9.4.1.2 Floats Floating-point constants are represented in 32-bit ANSI/IEEE Std 754-1985 [IEEE754] format:     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 81(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Name Data type and size Comment ConstantFloat32 float32 The value of the 32 bit floating point constant.  9.4.1.3 Strings WMLScript bytecode supports several ways to encode string constants39 into the constant pool. The compiler can select the most suitable character encoding supported by the client and optimise the WMLScript bytecode size by selecting the smallest string constant type that can still hold the string constant value.  9.4.1.3.1 UTF-8 Strings Strings that use UTF-8 encoding are encoded into the bytecode by first specifying their length and then the content:  Name Data type and size Comment StringSizeUTF8 mb_u_int32 The size of the following string in bytes (not containing this variable). ConstantStringUTF8 StringSizeUTF8 bytes The value of the Unicode string (non-null terminated) constant encoded using UTF-8. See 9.1.3 for more information about transfer encoding of strings.  9.4.1.3.2 Empty Strings Empty strings do not need any additional encoding for their value.   9.4.1.3.3 Strings with External Character Encoding Definition Strings that use external character encoding definition are encoded into the bytecode by first specifying their length and then the content:  Name Data type and size Comment StringSizeExt mb_u_int32 The size of the following string in bytes (not containing this field). ConstantStringExt StringSizeExt bytes The value of the string (non-null terminated) constant using external character encoding definition. See 9.1.3 for more information about transfer encoding of strings.                                                     39 Note that string constants can contain embedded null characters.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 82(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            9.5  Pragma Pool The pragma pool contains the information for pragmas defined in the compiled compilation unit.  Name Data type and size Comment NumberOfPragmas mb_u_int16 The number of pragmas. Pragmas... See 9.5.1 Contains the definitions for each pragma in the pragma pool. The number of pragmas is specified by NumberOfPragmas.  9.5.1 Pragmas Pragmas are stored into the bytecode one after each other. Encoding of each pragma starts with the definition of its type. It is being followed by pragma type specific data that represents the actual value of the pragma:  Name Data type and size Comment PragmaType u_int8 The type of the pragma following pragma value. PragmaValue See sections 9.5.1.1 and 9.5.1.2 Pragma type specific value definition.  The following encoding for pragma types is used:  Code Type Encoding 0 Access Domain 9.5.1.1.1 1 Access Path 9.5.1.1.2 2 User Agent Property 9.5.1.2.1 3 User Agent Property and Scheme 9.5.1.2.2 4-255 Reserved for future use   9.5.1.1 Access Control Pragmas Access control information is encoded into the bytecode using two different pragma types: access domain and access path. The pragma pool can contain only one entry for each access control pragma type.  9.5.1.1.1 Access Domain This pragma specifies the access domain to be used for the access control.  Name Data type and size Comment AccessDomainIndex mb_u_int16 Constant pool index to a string constant containing the value of the access domain. The referred constant type must be between 4 and 6.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 83(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             9.5.1.1.2 Access Path This pragma specifies the access path to be used for access control.  Name Data type and size Comment AccessPathIndex mb_u_int16 Constant pool index to a string constant containing the value of the access path. The referred constant type must be between 4 and 6.  9.5.1.2 Meta-Information Pragmas These pragmas contain meta-information that is mean for the WMLScript interpreter. Meta-information contains following entities: name, content and scheme (optional)  9.5.1.2.1 User Agent Property User agent properties are encoded by first specifying their name and then their value as indexes to the constant pool:  Name Data type and size Comment PropertyNameIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property name. ContentIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property value.  9.5.1.2.2 User Agent Property and Scheme This pragma is encoded by specifying the property name, the value and the additional scheme:  Name Data type and size Comment PropertyNameIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property name. ContentIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property value. SchemeIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property schema.       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 84(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            9.6 Function Pool The function pool contains the function definitions. Each of the functions has an index number starting from zero that is defined by its position in the list of functions. The instructions use this index to refer to specific functions.  Name Data type and size Comment NumberOfFunctions u_int8 The number of functions specified in this function pool. FunctionNameTable See section 9.6.1 Function name table contains the names of all external functions present in the bytecode. Functions... See section 9.6.2 Contains the bytecode for each function.  9.6.1 Function Name Table The names of the functions that are specified as external (extern) are stored into a function name table. The names must be presented in the same order as the functions are represented in the function pool. Functions that are not specified as external are not represented in the function name table. The format of the table is the following:  Name Data type and size Comment NumberOfFunctionNames u_int8 The number of function names stored into the following table. FunctionNames... See section 9.6.1.1  Each external function name represented in the same order as the functions are stored into the function pool.  9.6.1.1 Function Names Function name is provided only for functions that are specified as external in WMLScript. Each name is represented in the following manner:  Name Data type and size Comment FunctionIndex u_int8 The index of the function for which the following name is provided. FunctionNameSize u_int8 The size of the following function name in bytes (not including this variable). FunctionName FunctionNameSize bytes The characters of the function name encoded by using UTF-8. See section 9.1.3 for more information about function name encoding.   9.6.2 Functions Each function is defined by its prologue and code array:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 85(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             Name Data type and size Comment NumberOfArguments u_int8 The number of arguments accepted by the function. NumberOfLocalVariables u_int8 The number of local variables used by the function (not including arguments). FunctionSize mb_u_int32 Size of the following CodeArray (not including this variable) in bytes. CodeArray See section 9.6.2.1 Contains the code of the function.   9.6.2.1 Code Array Code array contains all instructions that are needed to implement the behaviour of a WMLScript function. See 10 for more information about WMLScript instruction set.  Name Data type and size Comment Instructions... See section 10 The encoded instructions.   9.7 Limitations The following table contains the limitations inherent in the selected bytecode format and instructions:  Maximum size of the bytecode 4294967295 bytes Maximum number of constants in the constant pool 65535 Maximum number of different constant types 256 Maximum size of a constant string 4294967295 bytes Maximum size of a constant URL 4294967295 bytes Maximum length of function name 255 Maximum number of different pragma types 256 Maximum number of pragmas in the pragma pool 65536 Maximum number of functions in the function pool 255 Maximum number of function parameters 255 Maximum number of local variables / function 255 Maximum number of local variables and function parameters 256 Maximum number of libraries 65536 Maximum number of functions / library 256     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 86(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             10. WMLSCRIPT INSTRUCTION SET The WMLScript instruction set specifies a set of assembly level instructions that must be used to encode all WMLScript language constructs and operations. These instructions are defined in such a way that they are easy to implement efficiently on a variety of platforms.  10.1 Conversion Rules The following table contains a summary of the conversion rules specified for the WMLScript interpreter:  Rule – Operand type(s) Conversions 1 – Boolean(s) See the conversion rules for Boolean(s) in section Operator Data Type Conversion Rules (6.9) 2 – Integer(s) See the conversion rules for Integer(s) in section Operator Data Type Conversion Rules (6.9) 3 – Floating-point(s) See the conversion rules for Floating-point(s) in section Operator Data Type Conversion Rules (6.9) 4 – String(s) See the conversion rules for String(s) in section Operator Data Type Conversion Rules (6.9) 5 – Integer or floating-point (unary) See the conversion rules for Integer or floating-point (unary) in section Operator Data Type Conversion Rules (6.9) 6 – Integers or floating-points See the conversion rules for Integers or floating-points in section Operator Data Type Conversion Rules (6.9) 7 – Integers, floating-points or strings See the conversion rules for Integers, floating-points or strings in section Operator Data Type Conversion Rules (6.9) 8 - Any See the conversion rules for Any in section Operator Data Type Conversion Rules (6.9)   10.2 Fatal Errors The following table contains a summary of the fatal errors specified for the WMLScript interpreter:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 87(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             Error code: Fatal Error: 1 (Verification Failed) See section Verification Failed (12.3.1.1) for details 2 (Fatal Library Function Error) See section Fatal Library Function Error (12.3.1.2) for details 3 (Invalid Function Arguments) See section Invalid Function Arguments (12.3.1.3) for details 4 (External Function Not Found) See section External Function Not Found (12.3.1.4) for details 5 (Unable to Load Compilation Unit) See section Unable to Load Compilation Unit (12.3.1.5) for details 6 (Access Violation) See section Access Violation (12.3.1.6) for details 7 (Stack Underflow) See section Stack Underflow (12.3.1.7) for details 8 (Programmed Abort) See section Programmed Abort (12.3.2.1) for details 9 (Stack Overflow) See section Stack Overflow (12.3.3.1) for details* 10 (Out of Memory) See section Out of Memory (12.3.3.2) for details* 11 (User Initiated) See section User Initiated (12.3.4.1) for details* 12 (System Initiated) See section System Initiated (12.3.4.2) for details*  * These fatal errors are not related to computation but can be generated as a result of memory exhaustion or external signals.   10.3 Optimisations WMLScript instruction set has been defined so that it provide at least the minimal set of instructions by which WMLScript language operations can be presented. Since the WMLScript bytecode is being transferred from the gateway to the client through a narrowband connection, the selected instructions have been optimised so that the compilers can generate code of minimal size. In some cases, this    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 88(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            has meant that several instructions with different parameters have been introduced to perform the same operation. The compiler should use the one that generates optimal code.  Inline parameters have been used to optimally pack information into as few bytes as possible. The following inline parameter optimisations have been introduced:  Signature Available instructions Used for 1XXPPPPP 4 JUMP_FW_S, JUMP_BW_S, TJUMP_FW_S, LOAD_VAR_S 010XPPPP 2 STORE_VAR_S, LOAD_CONST_S 011XXPPP 4 CALL_S, CALL_LIB_S, INCR_VAR_S 00XXXXXX 63 The rest of the instructions   10.4 Notational Conventions The following sections contain the definitions of instructions in the WMLScript instruction set. For each instruction, the following information is provided:   • Instruction: A symbolic name given to the instruction and its parameters. • Opcode: The 8-bit encoding of the instruction. • Parameters: Parameter description specifying their ranges and semantics. Some instructions are optimised and can contain an implicit parameter as part of the encoding, ie, a set of bits from the 8 bit encoding is reserved for a parameter value. • Operation: Description of the operation of the instruction, its parameters and the effects they have on the execution and the operand stack. • Operands: Specifies the number of operands required by the instruction and all acceptable operand types. • Conversion: Specifies the used conversion rule (see section 10.1). • Result: Specifies the result and its type. • Operand stack: Specifies the effect on the operand stack. It is described by using notation where the part before the arrow (=>) represents the stack before the instruction has been executed and the part after the arrow the stack after the execution. • Errors: Specifies the possible fatal errors that can occur during the execution of the instruction (see section 10.2).  All instructions except the control flow instructions continue the execution at the following instruction. Control flow instructions specify the next instruction explicitly.  Fatal errors that can be encountered at any time (see section External Exceptions in 12.3.4 and Memory Exhaustion Errors in 12.3.3) are assumed to be possible with every instruction.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 89(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            The result of the instruction can be an invalid value. This is not explicitly stated with each instruction but is assumed to be the result of the used conversion rule, a load of an invalid or unsupported floating-point constant or a result of an operation with an invalid operand.   10.5 Instructions The following sections contain the descriptions of each instruction divided into subcategories.  10.5.1 Control Flow Instructions 10.5.1.1 Instruction: JUMP_FW_S Opcode: 100iiiii (iiiii is the implicit unsigned offset) Parameter: Offset is an unsigned 5-bit integer in the range of 0..31. Operation: Jumps forward to an offset. Execution proceeds at the given offset from the address of the first byte following this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 1 + offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.1.2 Instruction: JUMP_FW offset Opcode: 00000001 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Jumps forward to an offset. Execution proceeds at the given offset from the address of the first byte following this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 2 + offset. Operands: - Conversion: - Operand stack: No change Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 90(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.1.3 Instruction: JUMP_FW_W <offset1,offset2> Opcode: 00000010 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Jumps forward to an offset. Execution proceeds at the given offset from the address of the first byte following this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 3 + offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.1.4 Instruction: JUMP_BW_S Opcode: 101iiiii (iiiii is the implicit unsigned offset) Parameter: Offset is an unsigned 5-bit integer in the range of 0..31. Operation: Jumps backward to an offset. Execution proceeds at the given offset from the address of this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 91(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.1.5 Instruction: JUMP_BW offset Opcode: 00000011 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Jumps backward to an offset. Execution proceeds at the given offset from the address of this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.1.6 Instruction: JUMP_BW_W <offset1,offset2> Opcode: 00000100 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Jumps backward to an offset. Execution proceeds at the given offset from the address of this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 92(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.1.7 Instruction: TJUMP_FW_S Opcode: 110iiiii (iiiii is the implicit unsigned offset) Parameter: Offset is an unsigned 5-bit integer in the range of 0..31. Operation: Pops a value from the operand stack and jumps forward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of the first byte following this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 1 + offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.1.8 Instruction: TJUMP_FW offset Opcode: 00000101 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value from the operand stack and jumps forward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of the first byte following this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 2 + offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 93(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.1.9 Instruction: TJUMP_FW_W <offset1,offset2> Opcode: 00000110 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Pops a value from the operand stack and jumps forward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of the first byte following this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 3 + offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.1.10 Instruction: TJUMP_BW offset Opcode: 00000111 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value from the operand stack and jumps backward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 94(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.1.11 Instruction: TJUMP_BW_W <offset1,offset2> Opcode: 00001000 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Pops a value from the operand stack and jumps backward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)   10.5.2 Function Call Instructions 10.5.2.1 Instruction: CALL_S Opcode: 01100iii (iii is the implicit findex) Parameter: Findex is an unsigned 3-bit integer in the range of 0..7. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a local function defined in the same function pool. Execution proceeds from the first instruction of the function findex. Operands: Variable number, any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 95(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.2.2 Instruction: CALL findex Opcode: 00001001 Parameter: Findex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a local function defined in the same function pool. Execution proceeds from the first instruction of the function findex. Operands: Variable number, any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.2.3 Instruction: CALL_LIB_S lindex Opcode: 01101iii (iii is the implicit findex) Parameters: Findex is an unsigned 3-bit integer in the range of 0..7. Lindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a library function findex defined in the specified library lindex. Operands: Variable number (specified by the called library function), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 2 (Fatal Library Function Error), 7 (Stack Underflow), 8 (Programmed Abort)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 96(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.2.4 Instruction: CALL_LIB  findex  lindex Opcode: 00001010 Parameters: Findex is an unsigned 8-bit integer in the range of 0..255. Lindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a library function findex defined in the specified library lindex. Operands: Variable number (specified by the called library function), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 2 (Fatal Library Function Error), 7 (Stack Underflow), 8 (Programmed Abort)  10.5.2.5 Instruction: CALL_LIB_W findex  <lindex1, lindex2> Opcode: 00001011 Parameters: Findex is an unsigned 8-bit integer in the range of 0..255. Lindex is an unsigned 16-bit integer <lindex1,lindex2> in the range of 0..65535. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a library function findex defined in the specified library lindex. Operands: Variable number (specified by the called library function), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 2 (Fatal Library Function Error), 7 (Stack Underflow), 8 (Programmed Abort)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 97(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.2.6 Instruction: CALL_URL  urlindex  findex  args Opcode: 00001100 Parameters: Urlindex is an unsigned 8-bit integer in the range of 0..255 that must point to the constant pool containing a valid URL. The referred constant type must be between 4 and 6.  Findex is an unsigned 8-bit integer in the range of 0..255 that must point to the constant pool containing a valid function name. The referred constant type must be 4.  Args is an unsigned 8-bit integer in the range of 0..255 that must contain the number of function arguments pushed on the operand stack. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a function specified by findex defined in the specified URL address urlindex. Operands: Variable number (specified by args), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 3 (Invalid Function Arguments), 4 (External Function Not Found), 5 (Unable to Load Compilation Unit), 6 (Access Violation), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 98(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.2.7 Instruction: CALL_URL_W  <urlindex1,urlindex2>  <findex1,findex2>  args Opcode: 00001101 Parameters: Urlindex is an unsigned 16-bit integer <urlindex1,urlindex2> in the range of 0..65535 that must point to the constant pool containing a valid URL. The referred constant type must be between 4 and 6.  Findex is an unsigned 16-bit integer <findex1,findex2> in the range of 0..65535 that must point to the constant pool containing a valid function name. The referred constant type must be 4.  Args is an unsigned integer in the range of 0..255 that must contain the number of function arguments pushed on the operand stack. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a function specified by findex defined in the specified URL address urlindex. Operands: Variable number (specified by args), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 3 (Invalid Function Arguments), 4 (External Function Not Found), 5 (Unable to Load Compilation Unit), 6 (Access Violation), 7 (Stack Underflow)   10.5.3 Variable Access and Manipulation 10.5.3.1 Instruction: LOAD_VAR_S Opcode: 111iiiii (iiiii is the implicit vindex) Parameter: Vindex is an unsigned 5-bit integer in the range of 0..31. Operation: Pushes the value of the variable vindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the variable) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 99(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.3.2 Instructions: LOAD_VAR vindex Opcode: 00001110 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pushes the value of the variable vindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the variable) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)  10.5.3.3 Instruction: STORE_VAR_S Opcode: 0100iiii  (iiii is the implicit vindex) Parameter: Vindex is an unsigned 4-bit integer in the range of 0..15. Operation:  Pops the value from the operand stack and stores it into the variable vindex. Operand: Any Conversion: 8 - Any Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.3.4 Instruction: STORE_VAR vindex Opcode: 00001111 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops the value from the operand stack and stores it into the variable vindex. Operand: Any Conversion: 8 - Any Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 100(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.3.5 Instruction: INCR_VAR_S Opcode: 01110iii (iii is the implicit vindex) Parameter: Vindex is an unsigned 3-bit integer in the range of 0..7. Operation: Increments the value of a variable vindex by one. Operands: - Conversion: 5 – Integer or floating-point (unary) Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.3.6 Instruction: INCR_VAR vindex Opcode: 00010000 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Increments the value of a variable vindex by one. Operands: - Conversion: 5 – Integer or floating-point (unary) Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.3.7 Instruction: DECR_VAR vindex Opcode: 00010001 Operation: Decrements the value of a variable vindex by one. Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operands: - Conversion: 5 – Integer or floating-point (unary) Result:  - Operand stack: No change Errors:  1 (Verification Failed)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 101(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.4 Access To Constants 10.5.4.1 Instruction: LOAD_CONST_S Opcode: 0101iiii (iiii is the implicit cindex) Parameter: Cindex is an unsigned 4-bit integer in the range of 0..15 that points to the constant pool containing the actual constant. The referred constant type must be between 0 and 6. Operation: Pushes the value of the constant denoted by cindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the constant) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)  10.5.4.2 Instruction: LOAD_CONST cindex Opcode: 00010010 Parameter: Cindex is an unsigned 8-bit integer in the range of 0..255 that points to the constant pool containing the actual constant. The referred constant type must be between 0 and 6. Operation: Pushes the value of the constant denoted by cindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the constant) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)  10.5.4.3 Instruction: LOAD_CONST_W <cindex1,cindex2> Opcode: 00010011 Parameter: Cindex is an unsigned 16-bit integer <cindex1,cindex2> in the range of 0..65535 that points to the constant pool containing the actual constant. The referred constant type must be between 0 and 6. Operation: Pushes the value of the constant cindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the constant) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 102(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.4.4 Instruction: CONST_0 Opcode: 00010100 Parameters: - Operation: Pushes an integer value 0 on the operand stack. Operands: - Conversion: - Result:  Integer Operand stack: ...  =>  ..., value_0 Errors:  -  10.5.4.5 Instruction: CONST_1 Opcode: 00010101 Parameters: - Operation: Pushes an integer value 1 on the operand stack. Operands: - Conversion: - Result:  Integer Operand stack: ...  =>  ..., value_1 Errors:  -  10.5.4.6 Instruction: CONST_M1 Opcode: 00010110 Parameters: - Operation: Pushes an integer value –1 on the operand stack. Operands: - Conversion: - Result:  Integer Operand stack: ...  =>  ..., value_-1 Errors:  -     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 103(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.4.7 Instruction: CONST_ES Opcode: 00010111 Parameters: - Operation: Pushes an empty string on the operand stack. Operands: - Conversion: - Result:  String Operand stack: ...  =>  ..., value_\"\" Errors:  -  10.5.4.8 Instruction: CONST_INVALID Opcode: 00011000 Parameters: - Operation: Pushes an invalid value on the operand stack. Operands: - Conversion: - Result:  Invalid Operand stack: ...  =>  ..., value_invalid Errors:  -  10.5.4.9 Instruction: CONST_TRUE Opcode: 00011001 Parameters: - Operation: Pushes a boolean value true on the operand stack. Operands: - Conversion: - Result:  Boolean Operand stack: ...  =>  ..., value_true Errors:  -     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 104(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.4.10 Instruction: CONST_FALSE Opcode: 00011010 Parameters: - Operation: Pushes a boolean value false on the operand stack. Operands: - Conversion: - Result:  Boolean Operand stack: ...  =>  ..., value_false Errors:  -   10.5.5 Arithmetic Instructions 10.5.5.1 Instruction: INCR Opcode: 00011011  Parameters: - Operation: Increments the value on the top of the operand stack by one. Operand: Integer or floating-point Conversion: 5 – Integer or floating-point (unary) Result:  Integer or floating-point (incremented by one) Operand stack: ..., value  =>  ..., value+1 Errors:  7 (Stack Underflow)  10.5.5.2 Instruction: DECR Opcode: 00011100 Parameters: - Operation: Decrements the value on the top of the operand stack by one. Operand: Integer or floating-point Conversion: 5 – Integer or floating-point (unary) Result:  Integer or floating-point (decremented by one) Operand stack: ..., value  =>  ..., value-1 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 105(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.5.3 Instruction: ADD_ASG vindex Opcode: 00011101 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value from the operand stack and adds the value to the variable vindex. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  For integers or floating-points: variable containing the result of the addition For strings: variable containing the result of string concatenation Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.5.4 Instruction: SUB_ASG vindex Opcode: 00011110 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value (subtractor) from the operand stack and subtracts the value from the variable vindex. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Variable containing the result of the subtraction Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.5.5 Instruction: UMINUS Opcode: 00011111 Parameters: - Operation: Pops a value from the operand stack and performs a unary minus operation on it and pushes the result back on the operand stack. Operand: Integer or floating-point Conversion: 5 – Integer or floating-point (unary) Result:  Integer or floating-point (negated) Operand stack: ..., value  =>  ..., -value Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 106(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.5.6 Instruction: ADD Opcode: 00100000 Parameters: - Operation: Pops two values from the operand stack and performs an add operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  For integers or floating-points: the result of the addition For strings: the result of the concatenation Operand stack: ..., value1, value2  =>  ..., value1 + value2 Errors:  7 (Stack Underflow)  10.5.5.7 Instruction: SUB Opcode: 00100001 Parameters: - Operation: Pops two values from the operand stack and performs a subtract operation on them and pushes the result back on the operand stack. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Integer or floating-point Operand stack: ..., value1, value2  =>  ..., value1 - value2 Errors:  7 (Stack Underflow)  10.5.5.8 Instruction: MUL Opcode: 00100010 Parameters: - Operation: Pops two values from the operand stack, performs a multiplication operation on them and pushes the result back on the operand stack. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Integer or floating-point Operand stack: ..., value1, value2  =>  ..., value1 * value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 107(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.5.9 Instruction: DIV Opcode: 00100011 Parameters: - Operation: Pops two values from the operand stack, performs a division operation on them and pushes the result back on the operand stack. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Floating-point Operand stack: ..., value1, value2  =>  ..., value1 / value2 Errors:  7 (Stack Underflow)  10.5.5.10 Instruction: IDIV Opcode: 00100100 Parameters: - Operation: Pops two values from the operand stack, performs an integer division operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 IDIV value2 Errors:  7 (Stack Underflow)  10.5.5.11 Instruction: REM Opcode: 00100101 Parameters: - Operation: Pops two values from the operand stack, performs a reminder operation on them (the sign of the result equals the sign of the dividend) and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 % value2 Errors:  7 (Stack Underflow)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 108(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.6 Bitwise Instructions 10.5.6.1 Instruction: B_AND Opcode: 00100110 Parameters: - Operation: Pops two values from the operand stack and performs a bitwise and operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 & value2 Errors:  7 (Stack Underflow)  10.5.6.2 Instruction: B_OR Opcode: 00100111 Parameters: - Operation: Pops two values from the operand stack and performs a bitwise or operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 | value2 Errors:  7 (Stack Underflow)  10.5.6.3 Instruction: B_XOR Opcode: 00101000 Parameters: - Operation: Pops two values from the operand stack, performs a bitwise xor operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 ^ value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 109(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.6.4 Instruction: B_NOT Opcode: 00101001 Parameters: - Operation: Pops a value from the operand stack and performs a bitwise complement operation on it and pushes the result back on the operand stack. Operands: Integer Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value  =>  ..., ~value Errors:  7 (Stack Underflow)  10.5.6.5 Instruction: B_LSHIFT Opcode: 00101010 Parameters: - Operation: Pops two values from the operand stack, performs a bitwise left-shift operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value, amount  =>  ..., value << amount Errors:  7 (Stack Underflow)  10.5.6.6 Instruction: B_RSSHIFT Opcode: 00101011 Parameters: - Operation: Pops two values from the operand stack, performs a bitwise signed right-shift operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value, amount  =>  ..., value >> amount Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 110(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.6.7 Instruction: B_RSZSHIFT Opcode: 00101100 Parameters: - Operation: Pops two values from the operand stack and performs a bitwise right-shift with zero operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value, amount  =>  ..., value >>> amount Errors:  7 (Stack Underflow)   10.5.7 Comparison Instructions 10.5.7.1 Instruction: EQ Opcode: 00101101 Parameters: - Operation: Pops two values from the operand stack, performs a logical equality operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 EQ value2 Errors:  7 (Stack Underflow)  10.5.7.2 Instruction: LE Opcode: 00101110 Parameters: - Operation: Pops two values from the operand stack, performs a logical less-or-equal operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 LE value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 111(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.7.3 Instruction: LT Opcode: 00101111 Parameters: - Operation: Pops two values from the operand stack, performs a logical less-than operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 LT value2 Errors:  7 (Stack Underflow)  10.5.7.4 Instruction: GE Opcode: 00110000 Parameters: - Operation: Pops two values from the operand stack, performs a logical greater-or-equal operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 GE value2 Errors:  7 (Stack Underflow)  10.5.7.5 Instruction: GT Opcode: 00110001 Parameters: - Operation: Pops two values from the operand stack, performs a greater-than operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 GT value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 112(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.7.6 Instruction: NE Opcode: 00110010 Parameters: - Operation: Pops two values from the operand stack, performs a logical not-equal operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 NE value2 Errors:  7 (Stack Underflow)   10.5.8 Logical Instructions 10.5.8.1 Instruction: NOT Opcode: 00110011 Parameters: - Operation: Pops a value from the operand stack and performs a logical complement operation on it and pushes the result back on the operand stack. Operands: Boolean Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., !value Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 113(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.8.2 Instruction: SCAND Opcode: 00110100 Parameters: - Operation: Pops a value from the operand stack and converts it to a boolean value. If the converted value is false or invalid then the converted value itself is pushed on the operand stack and the boolean value false is pushed on the operand stack. If the converted value is true then the converted value itself is pushed on the operand stack. Operands: Any Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., false, false (in case the value is false) ..., value  =>  ..., true (in case the value is true) ..., value  =>  ..., invalid, false (in case the value is invalid) Errors:  7 (Stack Underflow)  10.5.8.3 Instruction: SCOR Opcode: 00110101 Parameters: - Operation: Pops a value from the operand stack and converts it to a boolean value. If the converted value is false then the boolean value true is pushed on the operand stack. If the converted value is true or invalid then the converted value itself is pushed on the operand stack and the boolean value false is pushed on the operand stack. Operands: Any Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., true (in case the value is false) ..., value  =>  ..., true, false (in case the value is true) ..., value  =>  ..., invalid, false (in case the value is invalid) Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 114(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.8.4 Instruction: TOBOOL Opcode: 00110110 Parameters: - Operation: Pops a value from the operand stack and converts the value to a boolean value and pushes the converted value on the operand stack. If the popped value is invalid then an invalid value is pushed back on the operand stack. Operands: Any Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., tobool Errors:  7 (Stack Underflow)   10.5.9 Stack Instructions 10.5.9.1 Instruction: POP Opcode: 00110111 Parameters: - Operation: Pops a value from the operand stack. Operands: Any Conversion: - Result:  - Operand stack: ..., value  =>  ... Errors:  7 (Stack Underflow)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 115(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.10 Access to Operand Type 10.5.10.1 Instruction: TYPEOF Opcode: 00111000 Parameters: - Operation: Pops a value from the operand stack and checks its type. Pushes the result as an integer on the operand stack. The possible results are: 0 = Integer, 1 = Floating-point, 2 = String, 3 = Boolean, 4 = Invalid Operands: Any Conversion: - Result:  Integer Operand stack: ..., value  =>  ..., typeof? Errors:  7 (Stack Underflow)  10.5.10.2 Instruction: ISVALID Opcode: 00111001 Parameters: - Operation: Pops a value from the operand stack and checks its type. If the type is invalid a boolean value false is pushed on the operand stack, otherwise a boolean value true is pushed on the operand stack. Operands: Any Conversion: - Result:  Boolean Operand stack: ..., value  =>  ..., valid? Errors:  7 (Stack Underflow)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 116(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.11 Function Return Instructions 10.5.11.1 Instruction: RETURN Opcode: 00111010 Parameters: - Operation: Returns the control back to the caller. The return value is on the top of the operand stack. The execution continues at the next instruction following the function call of the calling function. Operands: Any Conversion: - Result:  - Operand stack: ..., ret-value  =>  ..., ret-value Errors:  7 (Stack Underflow)  10.5.11.2 Instruction: RETURN_ES Opcode: 00111011 Parameters: - Operation: Pushes an empty string on the operand stack and returns the control back to the caller. The execution continues at the next instruction following the function call of the calling function. Operands: - Conversion: - Result:  - Operand stack: ...  =>  ..., \"\" Errors:  -      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 117(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            10.5.12 Miscellaneous Instructions 10.5.12.1 Instruction: DEBUG Opcode: 00111100 Parameters: - Operation: No operation. Reserved for debugging and profiling purposes. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  -      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 118(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             11. BYTECODE VERIFICATION Bytecode verification takes place before or while the bytecode is used for execution. The purpose of the verification is to make sure that the content follows the WMLScript bytecode specification. In case of verification failure, the failed bytecode should not be used for execution or the execution must be aborted and failure signalled to the caller of the WMLScript interpreter.  The following checks are to be executed in the WMLScript Interpreter either before the execution is started or during the execution of WMLScript bytecode.  11.1 Integrity Check The following list contains checks that must be used to verify the integrity of the WMLScript bytecode before it is executed:  • Check that the version number is correct: The bytecode version number must be compared with the bytecode version number supported by the WMLScript interpreter. The major version numbers must match. The minor version number of the bytecode must be less than or equal to the minor version number supported by the WMLScript interpreter.  • Check that the size of the bytecode is correct: The size specified in the bytecode must match exactly the byte size of the content.  • Check the constant pool: • The number of constants is correct: The number of constants specified in the constant pool must match the number of constants stored into the constant pool. • The types of constants are valid: The numbers used to specify the constant types in the constant pool must match the supported constant types. Reserved constant types (7-255) result in a verification failure. • The sizes of constants are valid: Each constant must allocate only the correct number of bytes specified by the WMLScript bytecode specification (fixed size constants such as integers) or the size parameter provided as part of the constant entity (constants of varying size such as strings).  • Check the pragma pool: • The number of pragmas is correct: The number of pragmas specified in the pragma pool must match the number of pragmas stored into the pragma pool. • The types of pragmas are valid: The numbers used to specify the pragma types in the pragma pool must match the supported pragma types. Reserved pragma types (4-255) result in a verification failure. • The constant pool indexes are valid: • The access control domain and path must point to string constants. • The constant pool indexes used in meta-information pragmas must point to string constants.  • Check the function pool: • The number of functions is correct: The number of functions specified in the function pool must match the number of functions stored into the function pool. • The function name table is correct:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 119(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            • The number of function names is correct: The number of function names specified in the function name table must match the number of function names stored into the function name table. • The function name indexes are correct: The indexes must point to existing functions in the function pool. • The function names contain only valid function name characters: Function names must follow the WMLScript function name syntax. • There is at least one name in the table. • The function prologue is correct: • The number of arguments and local variables is correct: The sum of the number of arguments and local variables must be less or equal to 256. • The size of the function is correct: The size specified in the function prologue must match exactly the byte size of the function.  11.2 Runtime Validity Checks The following list contains the checks that must be done during the execution to verify that the used instructions are valid and they use valid parameter values:  • Check that the bytecode contains only valid instructions: Only instructions that are defined in chapter 10 are valid. • Check that local variable references are valid: The references must be within the boundaries specified by the number of function local variables in the function prologue. • Check that constant references are valid: • The references must be within the boundaries specified by the number of constants in the constant pool. • The references must point to the valid constant types specified by each instruction: • In case of URL references, the referred constant strings must contain a valid URL (see [RFC2396]). • In case of Function Name references, the referred constant strings must contain a valid WMLScript function name. • Check that the standard library indexes and library function indexes are valid: The indexes must be within the boundaries specified by the WMLScript Standard Libraries specification [WMLSLibs]. • Check that local function call indexes are valid: The function indexes must match with the number of functions specified in the function pool. • Check that the jumps are within function boundaries: All jumps must have a target inside the function in which they are specified. • Check that the targets of jumps are valid: The target of all jumps must be the beginning of an instruction. • Check that the ends of the functions are valid: Functions must not end in the middle of an instruction.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 120(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             12. RUN-TIME ERROR DETECTION AND HANDLING Since WMLScript functions are used to implement services for users that expect the terminals (in particular mobile phones) to work properly in all situations, error handling is of utmost importance. This means that while the language does not provide, for example, an exception mechanism, it should provide tools to either prevent errors from happening or tools to notice them and take appropriate actions. Aborting a program execution should be the last resort used only in cases where nothing else is possible.  The following section lists errors that can happen when downloading bytecode and executing it. It does not contain programming errors (such as infinite loop etc.). For these cases a user controlled abortion mechanism is needed.   12.1 Error Detection The goal of error detection is to give tools for the programmer to detect errors (if possible) that would lead to erroneous behaviour. Since WMLScript is a weakly typed language, special functionality has been provided to detect errors that are caused by invalid data types :  • Check that the given variable contains the right value: WMLScript supports type validation library [WMLSLibs] functions such as Lang.isInt(), Lang.isFloat(), Lang.parseInt() and Lang.parseFloat(). • Check that the given variable contains a value that is of right type: WMLScript supports the operators typeof and isvalid that can be used for this purpose.   12.2 Error Handling Error handling takes place after an error has already happened. This is the case when the error could not be prevented by error detection (memory limits, external signals etc.) or it would have been too difficult to do so (overflow, underflow etc.). These cases can be divided into two classes:  • Fatal errors: These are errors that cause the program to abort. Since WMLScript functions are always called from some other user agents, program abortion should always be signalled to the calling user agent. It is then its responsibility to take the appropriate actions to signal the user of errors. • Non-fatal errors: These are errors that can be signalled back to the program as special return values and the program can decide on the appropriate action.  The following error descriptions are divided into sections based on their fatality.   12.3 Fatal Errors 12.3.1 Bytecode Errors These errors are related to the bytecode and the instructions being executed by the WMLScript Bytecode Interpreter. They are indications of erroneous constant pool elements, invalid instructions, invalid arguments to instructions or instructions that cannot be completed.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 121(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            12.3.1.1 Verification Failed Description: Reports that the specified bytecode for the called compilation unit did not pass the verification (see section 11 for more information about bytecode verification). Generated: At any time when a program attempts to call an external function. Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: Is detected during the bytecode verification. Solution: Abort program and signal an error to the caller of the WMLScript interpreter. 12.3.1.2 Fatal Library Function Error Description: Reports that a call to a library function resulted in a fatal error. Generated: At any time when a call to a library function is used (CALL_LIB). Typically, this is an unexpected error in the library function implementation. Example: var a = String.format(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.3 Invalid Function Arguments Description: Reports that the number of arguments specified for a function call do not match with the number of arguments specified in the called function. Generated: At any time a call to an external function is used (CALL_URL). Example: Compiler generates an invalid parameter to an instruction or the number of parameters in the called function has changed. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.4 External Function Not Found Description: Reports that a call to an external function could not be found from the specified compilation unit. Generated: At any time, when a program attempts to call an external function (CALL_URL). Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 122(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            12.3.1.5 Unable to Load Compilation Unit Description: Reports that the specified compilation unit could not be loaded due to unrecoverable errors in accessing the compilation unit in the network server or the specified compilation unit does not exist in the network server. Generated: At any time, when a program attempts to call an external function (CALL_URL). Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.6 Access Violation Description: Reports an access violation. The called external function resides in a protected compilation unit. Generated: At any time when a program attempts to call an external function (CALL_URL). Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.7 Stack Underflow Description: Indicates a stack underflow because of a program error (compiler generated bad code). Generated: At any time when a program attempts to pop an empty stack. Example: Only generated if compiler generates bad code. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.   12.3.2 Program Specified Abortion This error is generated when a WMLScript function calls the library function Lang.abort() (see [WMLSLibs]) to abort the execution.  12.3.2.1 Programmed Abort Description: Reports that the execution of the bytecode was aborted by a call to Lang.abort() function. Generated: At any time when a program makes a cal to Lang.abort() function.. Example: Lang.abort(\"Unrecoverable error\"); Severity: Fatal. Predictable: No.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 123(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Solution: Abort program and signal an error to the caller of the WMLScript interpreter.   12.3.3 Memory Exhaustion Errors These errors are related to the dynamic behaviour of the WMLScript interpreter (see section 8.1 for more information) and its memory usage.  12.3.3.1 Stack Overflow Description: Indicates a stack overflow. Generated: At any time when a program recourses too deep or attempts to push too many variables onto the operand stack. Example: function f(x) { f(x+1); }; Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.3.2 Out of Memory Description: Indicates that no more memory resources are available to the interpreter. Generated: At any time when the operating system fails to allocate more space for the interpreter. Example: function f(x) {   x=x+”abcdefghijklmnopqrstuvzyxy”;   f(x); }; Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.   12.3.4 External Exceptions The following exceptions are initiated outside of the WMLScript Bytecode Interpreter.  12.3.4.1 User Initiated Description: Indicates that the user wants to abort the execution of the program (reset button etc.) Generated: At any time. Example: User presses reset button while an application is running. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 124(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            12.3.4.2 System Initiated Description: Indicates that an external fatal exception occurred while a program is running and it must be aborted. Exceptions can be originated from a low battery, power off, etc. Generated: At any time. Example: The system is automatically switching off due to a low battery. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.4 Non-Fatal Errors 12.4.1 Computational Errors These errors are related to arithmetic operations supported by the WMLScript.  12.4.1.1 Divide by Zero Description: Indicates a division by zero. Generated: At any time when a program attempts to divide by 0 (integer or floating-point division or remainder). Example: var a = 10; var b = 0; var x = a / b; var y = a div b; var z = a % b; a /= b; Severity: Non-fatal. Predictable: Yes. Solution: The result is an invalid value.  12.4.1.2 Integer Overflow Description: Reports an arithmetic integer overflow. Generated: At any time when a program attempts to execute an integer operation. Example: var a = Lang.maxInt(); var b = Lang.maxInt(); var c = a + b; Severity: Non-fatal. Predictable: Yes (but difficult in certain cases). Solution: The result is an invalid value.  12.4.1.3 Floating-Point Overflow Description: Reports an arithmetic floating-point overflow. Generated: At any time when a program attempts to execute a floating-point operation.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 125(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Example: var a = 1.6e308; var b = 1.6e308; var c = a * b; Severity: Non-fatal. Predictable: Yes (but difficult in certain cases). Solution: The result is an invalid value.  12.4.1.4 Floating-Point Underflow Description: Reports an arithmetic underflow. Generated: At any time when the result of a floating-point operation is smaller than what can be represented. Example: var a = Float.precision(); var b = Float.precision(); var c = a * b; Severity: Non-fatal. Predictable: Yes (but difficult in certain cases). Solution: The result is a floating-point value 0.0.   12.4.2 Constant Reference Errors These errors are related to run-time references to constants in the constant pool.  12.4.2.1 Not a Number Floating-Point Constant Description: Reports a reference to a floating-point literal in the constant pool that is Not a Number [IEEE754]. Generated: At any time when a program attempts to access a floating-point literal and the compiler has generated a Not a Number as a floating-point constant. Example: A reference to a floating-point literal. Severity: Non-fatal. Predictable: Yes. Solution: The result is an invalid value.  12.4.2.2 Infinite Floating-Point Constant Description: Reports a reference to a floating-point literal in the constant pool that is either positive or negative infinity [IEEE754]. Generated: At any time when a program attempts to access a floating-point literal and the compiler has generated a floating-point constant with a value of positive or negative infinity. Example: A reference to a floating-point literal. Severity: Non-fatal. Predictable: Yes. Solution: The result is an invalid value.  12.4.2.3 Illegal Floating-Point Reference Description: Reports an erroneous reference to a floating-point value in the constant pool.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 126(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Generated: At any time when a program attempts to use floating-point values and the environments supports only integer values. Example: var a = 3.14; Severity: Non-fatal. Predictable: Can be detected during the run-time. Solution: The result is an invalid value.   12.4.3 Conversion Errors These errors are related to automatic conversions supported by the WMLScript.  12.4.3.1 Integer Too Large Description: Indicates a conversion to an integer value where the integer value is too large (positive/negative). Generated: At any time when an application attempts to make an automatic conversion to an integer value. Example: var a = -\"999999999999999999999999999999999999999999\"; Severity: Non-fatal. Predictable: No. Solution: The result is an invalid value.  12.4.3.2 Floating-Point Too Large Description: Indicates a conversion to a floating-point value where the floating-point value is too large (positive/negative). Generated: At any time when an application attempts to make an automatic conversion to a floating-point value. Example: var a = -\"9999999.9999999999e99999\"; Severity: Non-fatal. Predictable: No. Solution: The result is an invalid value.  12.4.3.3 Floating-Point Too Small Description: Indicates a conversion to a floating-point value where the floating-point value is too small (positive/negative). Generated: At any time when an application attempts to make an automatic conversion to a floating-point value. Example: var a = -\"0.01e-99\"; Severity: Non-fatal. Predictable: No. Solution: The result is a floating-point value 0.0.   12.5 Library Calls and Errors Since WMLScript supports the usage of libraries, there is a possibility that errors take place inside the library functions. Design and the behaviour of the library functions are not part of the WMLScript language specification. However, following guidelines should be followed when designing libraries:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 127(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             • Provide the library users mechanisms by which errors can be detected before they happen. • Use the same error handling mechanisms as WMLScript operators in cases where error should be reported back to the caller. • Minimise the possibility of fatal errors in all library functions.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 128(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             13. SUPPORT FOR INTEGER ONLY DEVICES The WMLScript language has been designed to run also on devices that do not support floating-point operations. The following rules apply when WMLScript is used with such devices:  • Variables can only contain the following internal data types: • Boolean • Integer • String • Invalid • Any LOAD_CONST bytecode that refers to a floating point constant in the constant pool will push an invalid value on the operand stack instead of the constant value. • Division (/) operation returns always an invalid value. • Assignment with division (/=) operation always results in an invalid value. • All conversion rules related to floating-points are ignored. • URL call with a floating-point value as an argument results in a failure to execute the call due to an invalid URL syntax.  The programmer can use Lang.float() [WMLSLibs] to test (during the run-time) if floating-point operations are supported.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 129(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             14. CONTENT TYPES The content types specified for WMLScript compilation unit and its textual and binary encoding are:  • Textual form: text/vnd.wap.wmlscript • Binary form: application/vnd.wap.wmlscriptc     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 130(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             15. STATIC CONFORMANCE REQUIREMENTS  This static conformance clause defines a minimum set of features that can be implemented to ensure that WMLScript encoders and interpreters will be able to inter-operate. While both interpreter behavior and encoder behavior is described in the WMLScript specification, not all items apply to both entities, so there are separate tables for each. A feature can be optional or mandatory.   15.1 Encoder   15.1.1 Core Capabilities   Item Function Reference Status Requirement WMLS-001 Support for both Floating point capable and Integer only devices Support for Integer Only Devices M  WMLS-002 WMLScript Standard Libraries [WMLSLibs] M    15.1.2 WMLScript Language Core  Item Function Reference Status Requirement WMLS-003 Language is case-sensitive Case Sensitivity  M  WMLS-004 Ignore extra white space and line break between program tokens Whitespace and Line Breaks  M  WMLS-005 Semicolon is used to terminate certain statements Usage of Semicolons  M  WMLS-006 Multi-line and single-line comments Comments  M  WMLS-007 Disallows nested comments  Comments  M  WMLS-008 Integer literals Integer Literals  M  WMLS-009 Floating point literals Floating-Point Literals  M  WMLS-010 String literals, single and double quoted String Literals  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 131(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Item Function Reference Status Requirement WMLS-011 Special escape sequences String Literals  M  WMLS-012 Boolean literals Boolean Literals  M  WMLS-013 Invalid literal Invalid Literal  M  WMLS-014 Identifier syntax Identifiers  M  WMLS-015 Variable scope and lifetime Variable Scope and Lifetime  M  WMLS-016 Integer size Integer Size  M  WMLS-017 Floating point size Floating-point Size  O  WMLS-018 Assignment operators Assignment Operators  M  WMLS-019 Arithmetic operators Arithmetic Operators  M  WMLS-020 Logical operators Logical Operators  M  WMLS-021 String operators String Operators  M  WMLS-022 Comparison operators Comparison Operators  M  WMLS-023 Array operators Array Operators  M  WMLS-024 Comma operator Comma Operator  M  WMLS-025 Conditional operator Conditional Operator  M  WMLS-026 typeof operator typeof Operator  M  WMLS-027 isvalid operator isvalid Operator M  WMLS-028 Expression bindings Expression Bindings  M  WMLS-029 Function declaration 1Declaration  M  WMLS-030 Local script functions calls Local Script Functions  M  WMLS-031 External function calls External Functions  M  WMLS-032 Library function calls Library Functions  M  WMLS-033 Default function return value Default Return Value  M  WMLS-034 Empty statement Empty Statement  M  WMLS-035 Block statement Block Statement  M  WMLS-036 Variable statement Variable Statement  M  WMLS-037 if statement If Statement  M  WMLS-038 while statement While Statement  M  WMLS-039 for statement For Statement  M  WMLS-040 break statement Break Statement  M  WMLS-041 continue statement Continue Statement  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 132(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Item Function Reference Status Requirement WMLS-042 return statement Return Statement  M  WMLS-043 External compilation unit pragma External Compilation Units  M  WMLS-044 Access control pragma Access Control  M  WMLS-045 Meta information pragma Meta-Information M    15.1.3 Function Calls  Item Function Reference Status Requirement WMLS-046 Function argument passing Passing of Function Arguments  M  WMLS-047 Allocation of variable indexes Allocation of Variable Indexes  M  WMLS-048 Automatic function return value Automatic Function Return Value  M  WMLS-049 Variable initialization Initialisation of Variables M    15.1.4 Binary Format  Item Function Reference Status Requirement WMLS-050 Binary format data types Used Data Types  M  WMLS-051 Multi-byte integer format Multi-byte Integer Format  M  WMLS-052 Character encoding Character Encoding  M  WMLS-053 Header Info Bytecode Header  M  WMLS-054 Constant Pool Constant Pool  M  WMLS-055 Pragma Pool  Pragma Pool  M  WMLS-056 Function Pool Function Pool M    15.1.5 Instruction Set  Item Function Reference Encoder Status Requirement WMLS-057 Control flow instructions Control Flow Instructions  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 133(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Item Function Reference Encoder Status Requirement WMLS-058 Function call instructions Function Call Instructions  M  WMLS-059 Variable access and manipulation Variable Access and Manipulation  M  WMLS-060 Access to constants Access To Constants  M  WMLS-061 Arithmetic instructions Arithmetic Instructions  M  WMLS-062 Bitwise instructions Bitwise Instructions  M  WMLS-063 Comparison instructions Comparison Instructions  M  WMLS-064 Logical instructions Logical Instructions  M  WMLS-065 Stack instructions Stack Instructions  M  WMLS-066 Access to operand type Access to Operand Type  M  WMLS-067 Return instructions Function Return Instructions  M  WMLS-068 Debug instruction Miscellaneous Instructions O       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 134(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                             15.2 Interpreter   15.2.1 Core Capabilities   Item Function Reference Status Requirement WMLS-069 Support for interpreting WMLScript bytecode WMLScript Bytecode Interpreter M  WMLS-070 WMLScript Standard Libraries [WMLSLibs] M    15.2.2 Automatic Data Conversion  Item Function Reference Status Requirement WMLS-071 Conversions to String Conversions to String  M  WMLS-072 Conversions to Integer Conversions to Integer  M  WMLS-073 Conversions to Floating Point Conversions to Floating-Point  O  WMLS-074 Conversions to Boolean Conversions to Boolean  M  WMLS-075 Conversions to Invalid Conversions to Invalid  M  WMLS-076 Operator data type conversion rules Operator Data Type Conversion Rules M    15.2.3 Function Calls  Item Function Reference Status Requirement WMLS-077 URL schemes URL Schemes  M  WMLS-078 Fragment anchor Fragment Anchors  M  WMLS-079 URL call syntax URL Call Syntax  M  WMLS-080 URL call parameter passing URL Calls and Parameter Passing  M  WMLS-081 Support for relative URLs Relative URLs  M  WMLS-082 Function argument passing Passing of Function Arguments  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 135(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Item Function Reference Status Requirement WMLS-083 Allocation of variable indexes Allocation of Variable Indexes  M  WMLS-084 Automatic function return value Automatic Function Return Value  M  WMLS-085 Variable initialization Initialisation of Variables  M  WMLS-086 Access control Access Control M    15.2.4 Binary Format  Item Function Reference Status Requirement WMLS-087 Binary format data types Used Data Types  M  WMLS-088 Multi-byte integer format Multi-byte Integer Format  M  WMLS-089 Character encoding Character Encoding  M  WMLS-090 Header Info Bytecode Header  M  WMLS-091 Constant Pool Constant Pool  M  WMLS-092 Pragma Pool  Pragma Pool  M  WMLS-093 Function Pool Function Pool M    15.2.5 Instruction Set  Item Function Reference Status Requirement WMLS-094 Control flow instructions Control Flow Instructions  M  WMLS-095 Function call instructions Function Call Instructions  M  WMLS-096 Variable access and manipulation Variable Access and Manipulation  M  WMLS-097 Access to constants Access To Constants  M  WMLS-098 Arithmetic instructions Arithmetic Instructions  M  WMLS-099 Bitwise instructions Bitwise Instructions  M  WMLS-100 Comparison instructions Comparison Instructions  M  WMLS-101 Logical instructions Logical Instructions  M  WMLS-102 Stack instructions Stack Instructions  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 136(136)WAP-193-WMLS-20001025-a, Version 25-Oct-2001                                            Item Function Reference Status Requirement WMLS-103 Access to operand type Access to Operand Type  M  WMLS-104 Return instructions Function Return Instructions  M  WMLS-105 Debug instruction Miscellaneous Instructions M    15.2.6 Error Handling  Item Function Reference Status Requirement WMLS-106 Bytecode verification Integrity Check  M  WMLS-107 Runtime validity checking Runtime Validity Checks  M  WMLS-108 Support for general error handling Error Handling  M  WMLS-109 Handling of fatal errors Fatal Errors  M  WMLS-110 Handling of non-fatal errors Non-Fatal Errors M    15.2.7 Support for Floating Point Devices  Item Function Reference Status Requirement WMLS-111 Support for floating-point operations Support for Integer Only Devices O WMLS-17 AND WMLS-73"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-193_101-WMLScript-20010928-a.pdf","file":"WAP-193_101-WMLScript-20010928-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a set of standards to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers. For additional information on the WAP architecture, refer to Wireless Application Protocol Architecture Specification [WAP].  This paper is a specification of the WMLScript language. It is part of the WAP application layer and it can be used to add client side procedural logic. The language is based on ECMAScript [ECMA262] but it has been modified to better support low bandwidth communication and thin clients. WMLScript can be used together with Wireless Markup Language [WML] to provide intelligence to the clients but it has also been designed so that it can be used as a standalone tool.  One of the main differences between ECMAScript and WMLScript is the fact that WMLScript has a defined bytecode and an interpreter reference architecture. This way the narrowband communication channels available today can be optimally utilised and the memory requirements for the client kept to the minimum. Many of the advanced features of the ECMAScript language have been dropped to make the language smaller, easier to compile into bytecode and easier to learn. For example, WMLScript is a procedural language and it supports locally installed standard libraries.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 10(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             2. DOCUMENT STATUS This document is available online in the following formats:  • PDF format at http://www.wapforum.org/.   2.1 Copyright Notice © Wireless Application Protocol Forum Ltd. 2000. Terms and conditions of use are available from the Wireless Application Protocol Forum Ltd. web site (http://www.wapforum.org/docs/copyright.htm).   2.2 Errata Known problems associated with this document are published at http://www.wapforum.org/.   2.3 Comments Comments regarding this document can be submitted to WAP Forum in the manner published at http://www.wapforum.org/.  2.4 Document Changes 2.4.1 WAP-193   24-Mar-2000 Change Request Title Comments WAG-IBM-20000209-MustDefinition RFC2119 Conformance Section 5.1 – definition of SHOULD and MUST 2.4.2 WAP-193    25-Sep-2000 Change Request Title Comments New Static Conformance Format Re-release for WAP 2 WAP-193.100 Added Column for Inter-Specification Dependencies Section 15 New Title Page Format 2.4.3 WAP-193 28-Sep-2001 Change Request Title Comments Updated Static Conformance Format WAP-193.101 Added –C- and –S- delimiters, and separated floating point SCR into client and server parts     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 11(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                              2.5 Document History Document Name Date of Release SPEC-WMLScript-v1.1 17-Jun-1999 WAP-193.WMLScript-Proposed 24-March-2000 WAP-193.WMLScript    (Approved) June-2000 WAP-193.100-WMLS-20000925  (SCD) 25-September-2000 WAP-193-WMLS-20001025-a 25-October-2000 WAP-193_101-WMLS-20001025-d 28-September-2001    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 12(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             3. REFERENCES  3.1 Normative references  [ECMA262] Standard ECMA-262: \"ECMAScript Language Specification\", ECMA, June 1997 [IEEE754] ANSI/IEEE Std 754-1985: \"IEEE Standard for Binary Floating-Point Arithmetic\". Institute of Electrical and Electronics Engineers, New York (1985). [ISO10646] \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane\", ISO/IEC 10646-1:1993. [RFC2279] \"UTF-8, a transformation format of Unicode and ISO 10646\", F. Yergeau, January 1998. URL: ftp://ftp.isi.edu/in-notes/rfc2279.txt [RFC2068] \"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, et al., January 1997. URL: ftp://ftp.isi.edu/in-notes/rfc2068.txt [RFC2119] \"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March 1997. URL: ftp://ftp.isi.edu/in-notes/rfc2119.txt [RFC2396] \"Uniform Resource Identifiers (URI): Generic Syntax\", T. Berners-Lee, et al., August 1998. URL: http://info.internet.isi.edu/in-notes/rfc/files/rfc2396.txt [UNICODE] \"The Unicode Standard: Version 2.0\", The Unicode Consortium, Addison-Wesley Developers Press, 1996. URL: http://www.unicode.org/ [WAP] \"Wireless Application Protocol Architecture Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WML] \"Wireless Markup Language Specification\", WAP Forum, 04-November-1999. URL: http://www.wapforum.org/ [WMLSLibs] \"WAP-194-WMLScript Standard Libraries Specification\", WAP Forum, 15-May-2000. URL: http://www.wapforum.org/ [WSP] \"Wireless Session Protocol\", WAP Forum, 05-November-1999. URL: http://www.wapforum.org/ [XML] \"Extensible Markup Language (XML), W3C Proposed Recommendation 10-February-1998, REC-xml-19980210\", T. Bray, et al, February 10, 1998.  URL: http://www.w3.org/TR/REC-xml  3.2 Informative References  [HTML4] \"HTML 4.0 Specification, W3C Recommendation 18-December-1997, REC-HTML40-971218\", D. Raggett, et al., September 17, 1997. URL: http://www.w3.org/TR/REC-html40 [JavaScript] \"JavaScript: The Definitive Guide\", David Flanagan, O'Reilly & Associates, Inc. 1997 [WAE] \"Wireless Application Environment Specification\", WAP Forum, 04-November-1999. URL: http://www.wapforum.org/       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 13(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             4. DEFINITIONS AND ABBREVIATIONS  4.1 Definitions The following are terms and conventions used throughout this specification.  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",  \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\" and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119]. In the absence of any such terms, the specification should be interpreted as \"MUST\".  Bytecode - content encoding where the content is typically a set of low-level opcodes (ie, instructions) and operands for a targeted hardware (or virtual) machine.  Client - a device (or application) that initiates a request for connection with a server.  Content - subject matter (data) stored or generated at an origin server.  Content is typically displayed or interpreted by a user agent in response to a user request.  Content Encoding - when used as a verb, content encoding indicates the act of converting a data object from one format to another.  Typically the resulting format requires less physical space than the original, is easier to process or store and/or is encrypted.  When used as a noun, content encoding specifies a particular format or encoding standard or process.  Content Format – actual representation of content.  Device - a network entity that is capable of sending and receiving packets of information and has a unique device address.  A device can act as both a client or a server within a given context or across multiple contexts.  For example, a device can service a number of clients (as a server) while being a client to another server.  JavaScript - a de facto standard language that can be used to add dynamic behaviour to HTML documents.  JavaScript is one of the originating technologies of ECMAScript.  Origin Server - the server on which a given resource resides or is to be created.  Often referred to as a web server or an HTTP server.  Resource - a network data object or service that can be identified by a URL.  Resources may be available in multiple representations (e.g. multiple languages, data formats, size and resolutions) or vary in other ways.  Server - a device (or application) that passively waits for connection requests from one or more clients.  A server may accept or reject a connection request from a client.  User - a user is a person who interacts with a user agent to view, hear or otherwise use a rendered content.  User Agent - a user agent (or content interpreter) is any software or device that interprets WML, WMLScript or resources.  This may include textual browsers, voice browsers, search engines, etc.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 14(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             Web Server - a network host that acts as an HTTP server.  WML - the Wireless Markup Language is a hypertext markup language used to represent information for delivery to a narrowband device, e.g. a phone.  WMLScript - a scripting language used to program the mobile device.  WMLScript is an extended subset of the JavaScript scripting language.   4.2 Abbreviations For the purposes of this specification, the following abbreviations apply:  API Application Programming Interface BNF Backus-Naur Form ECMA European Computer Manufacturer Association HTML HyperText Markup Language [HTML4] HTTP HyperText Transfer Protocol [RFC2068] IANA Internet Assigned Number Authority LSB Least Significant Bits MSB Most Significant Bits RFC Request For Comments UI User Interface URL Uniform Resource Locator [RFC2396] UTF UCS Transformation Format UCS Universal Multiple-Octet Coded Character Set W3C World Wide Web Consortium WWW World Wide Web WSP Wireless Session Protocol WTP Wireless Transport Protocol WAP Wireless Application Protocol WAE Wireless Application Environment WTA Wireless Telephony Applications WTAI Wireless Telephony Applications Interface WBMP Wireless BitMaP     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 15(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             5. OVERVIEW  5.1 Why Scripting? WMLScript is designed to provide general scripting capabilities to the WAP architecture. Specifically, WMLScript can be used to complement the Wireless Markup Language [WML]. WML is a markup language based on Extensible Markup Language [XML]. It is designed to be used to specify application content for narrowband devices like cellular phones and pagers. This content can be represented with text, images, selection lists etc. Simple formatting can be used to make the user interfaces more readable as long as the client device used to display the content can support it. However, all this content is static and there is no way to extend the language without modifying WML itself. The following list contains some capabilities that are not supported by WML:  • Check the validity of user input (validity checks for the user input) • Access to facilities of the device. For example, on a phone, allow the programmer to make phone calls, send messages, add phone numbers to the address book, access the SIM card etc. • Generate messages and dialogs locally thus reducing the need for expensive round-trip to show alerts, error messages, confirmations etc. • Allow extensions to the device software and configuring a device after it has been deployed.  WMLScript was designed to overcome these limitations and to provide programmable functionality that can be used over narrowband communication links in clients with limited capabilities.   5.2 Benefits of using WMLScript Many of the services that can be used with thin mobile clients can be implemented with WML. Scripting enhances the standard browsing and presentation facilities of WML with behavioural capabilities. They can be used to supports more advanced UI functions, add intelligence to the client, provide access to the device and its peripheral functionality and reduces the amount of bandwidth needed to send data between the server and the client.  WMLScript is loosely based on ECMAScript [ECMA262] and does not require the developers to learn new concepts to be able to generate advanced mobile services.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 16(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             6. WMLSCRIPT CORE One objective for the WMLScript language is to be close to the core of the ECMAScript Language specification [ECMA262]. The part in the ECMAScript Language specification that defines basic types, variables, expressions and statements is called core and can almost be used \"as is\" for the WMLScript specification. This section gives an overview of the core parts of WMLScript.  See section WMLScript Grammar (7) for syntax conventions and precise language grammar.   6.1 Lexical Structure This section describes the set of elementary rules that specify how you write programs in WMLScript.  6.1.1 Case Sensitivity WMLScript is a case-sensitive language. All language keywords, variables and function names must use the proper capitalisation of letters.  6.1.2 Whitespace and Line Breaks WMLScript ignores spaces, tabs, newlines etc. that appear between tokens in programs, except those that are part of string constants.  Syntax: WhiteSpace :: <TAB> <VT> <FF> <SP> <LF> <CR> LineTerminator :: <LF> <CR> <CR><LF>  6.1.3 Usage of Semicolons The following statements in WMLScript have to be followed by a semicolon:1  • Empty statement (see section 6.5.1) • Expression statement (see section 6.5.2) • Variable statement (see section 6.5.4) • Break statement (see section 6.5.8) • Continue statement (see section 6.5.9)                                                  1 Compatibility note: ECMAScript supports optional semicolons.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 17(132)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            • Return statement (see section 6.5.10)  6.1.4 Comments The language defines two comment constructs: line comments (ie, start with // and end in the end of the line) and block comments (ie, consisting of multiple lines starting with /* and ending with */). It is illegal to have nested block comments.2  Syntax: Comment :: MultiLineComment SingleLineComment MultiLineComment :: /* MultiLineCommentCharsopt */ SingleLineComment :: // SingleLineCommentCharsopt  6.1.5 Literals 6.1.5.1 Integer Literals Integer literals can be represented in three different ways: decimal, octal and hexadecimal integers.  Syntax: DecimalIntegerLiteral :: 0 NonZeroDigit DecimalDigitsopt NonZeroDigit :: one of 1 2 3 4 5 6 7 8 9 DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9 HexIntegerLiteral :: 0x HexDigit 0X HexDigit HexIntegerLiteral HexDigit HexDigit :: one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F                                                  2 Compatibility note: ECMAScript also supports HTML comments.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 18(133)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            OctalIntegerLiteral :: 0 OctalDigit OctalIntegerLiteral OctalDigit OctalDigit :: one of 0 1 2 3 4 5 6 7  The minimum and maximum sizes for integer literals and values are specified in the section 6.2.7.1. An integer literal that is not within the specified value range must result in a compile time error.  6.1.5.2 Floating-Point Literals Floating-point literals can contain a decimal point as well as an exponent.  Syntax: DecimalFloatLiteral :: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPart DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit ExponentPart :: ExponentIndicator SignedInteger ExponentIndicator :: one of e E SignedInteger :: DecimalDigits + DecimalDigits - DecimalDigits  The minimum and maximum sizes for floating-point literals and values are specified in the section 6.2.7.2. A floating-point literal that is not within the specified value range must result in a compile time error. A floating-point literal underflow results in a floating-point literal zero (0.0).  6.1.5.3 String Literals Strings are any sequence of zero or more characters enclosed within double (\") or single quotes (').  Syntax: StringLiteral :: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt  '    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 19(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Examples of valid strings are:  \"Example\"    'Specials: \\x00 \\' \\b'    \"Quote: \\\"\"  Since some characters are not representable within strings, WMLScript supports special escape sequences by which these characters can be represented:  Sequence Character represented3 Unicode Symbol \\’ Apostrophe or single quote \\u0027 ' \\\" Double quote \\u0022 \" \\\\ Backslash \\u005C \\ \\/ Slash \\u002F / \\b Backspace \\u0008  \\f Form feed \\u000C  \\n Newline \\u000A  \\r Carriage return \\u000D  \\t Horizontal tab \\u0009  \\xhh The character with the encoding specified by two hexadecimal digits hh (Latin-1 ISO8859-1)   \\ooo The character with the encoding specified by the three octal digits ooo (Latin-1 ISO8859-1)   \\uhhhh The Unicode character with the encoding specified by the four hexadecimal digits hhhh.    An escape sequence occurring within a string literal always contributes a character to the string value of the literal and is never interpreted as a line terminator or as a quote mark that might terminate the string literal.  6.1.5.4 Boolean Literals A \"truth value\" in WMLScript is represented by a boolean literal. The two boolean literals are: true and false.  Syntax: BooleanLiteral :: true false  6.1.5.5 Invalid Literal WMLScript supports a special invalid literal to denote an invalid value.                                                   3 Compatibility note: ECMAScript supports also non-escape characters preceded by a backslash.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 20(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Syntax: InvalidLiteral :: invalid  6.1.6 Identifiers Identifiers are used to name and refer to three different elements of WMLScript: variables (see section 6.2), functions (see section 6.4) and pragmas (see section 6.7). Identifiers4 cannot start with a digit but can start with an underscore (_).  Syntax: Identifier :: IdentifierName but not ReservedWord IdentifierName :: IdentifierLetter IdentifierName IdentifierLetter IdentifierName DecimalDigit IdentifierLetter :: one of a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _                          DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9  Examples of legal identifiers are:  timeOfDay  speed  quality  HOME_ADDRESS  var0  _myName  ____  The compiler looks for the longest string of characters make up a valid identifier. Identifiers cannot contain any special characters except underscore (_). WMLScript keywords and reserved words cannot be used as identifiers. Examples of illegal identifiers are:  while  for  if  my~name  $sys  123  3pieces  take.this  Uppercase and lowercase letters are distinct which means that the identifiers speed and Speed are different.  6.1.7 Reserved Words WMLScript specifies a set of reserved words that have a special meaning in programs and they cannot be used as identifiers. Examples of such words are (full list can be found from the WMLScript grammar specification, see section 7):                                                  4 Compatibility note: ECMAScript supports the usage of $ character in any position of the name, too.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 21(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             break  continue  false  true  while  6.1.8 Name Spaces WMLScript supports name spaces for identifiers that are used for different purposes. The following name spaces are supported:  • Function names (see section 6.4.1) • Function parameters (see section 6.4.2) and variables (see section 6.2) • Pragmas (see section 6.7)  Thus, the same identifiers can be used to specify a function name, variable/parameter name or a name for a pragma within the same compilation unit:  use url myTest \"http://www.host.com/script\";  function myTest(myTest) {   var value = myTest#myTest(myTest);   return value; };   6.2 Variables and Data Types This section describes the two important concepts of WMLScript language: variables and internal data types. A variable is a name associated with a data value. Variables can be used to store and manipulate program data. WMLScript supports local variables5 only declared inside functions or passed as function parameters (see section 6.4).  6.2.1 Variable Declaration Variable declaration is compulsory6 in WMLScript. Variable declaration is done simply by using the var keyword and a variable name (see section 6.5.4 for information about variable statements). Variable names follow the syntax defined for all identifiers (see section 6.1.6):  var x; var price; var x,y; var size = 3;  Variables must be declared before they can be used. Initialisation of variables is optional. Uninitialised variables are automatically initialised to contain an empty string (\"\").  6.2.2 Variable Scope and Lifetime The scope of WMLScript variables is the remainder of the function (see section 6.4) in which they have been declared. All variable names within a function must be unique. Block statements (see section 6.5.3) are not used for scoping.                                                  5 Compatibility note: ECMAScript supports global variables, too. 6 Compatibility note: ECMAScript supports automatic declaration, too.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 22(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             function priceCheck(givenPrice) {   if (givenPrice > 100) {     var newPrice = givenPrice;   } else {     newPrice = 100;   };   return newPrice; };  The lifetime of a variable is the time between the variable declaration and the end of the function.  function foo() {   x = 1;          // Error: usage before declaration   var x,y;   if (x) {     var y;        // Error: redeclaration   }; };  6.2.3 Variable Access Variables are accessible only within the function in which they have been declared. Accessing the content of a variable is done by using the variable name:  var myAge   = 37; var yourAge = 63; var ourAge  = myAge + yourAge;  6.2.4 Variable Type WMLScript is a weakly typed language. The variables are not typed but internally the following basic data types are supported: boolean, integer, floating-point and string. In addition to these, a fifth data type invalid is specified to be used in cases an invalid data type is needed to separate it from the other internal data types. Since these data types are supported only internally, the programmer does not have to specify variable types and any variable can contain any type of data at any given time. WMLScript will attempt automatically convert between the different types as needed.  var flag        = true;       // Boolean var number      = 12;         // Integer var temperature = 37.7;       // Float number          = \"XII\";      // String var except      = invalid;    // Invalid  6.2.5 L-Values Some operators (see section 6.3.1 for more information about assignment operators) require that the left operand is a reference to a variable (L-value) and not the variable value. Thus, in addition to the five data types supported by WMLScript, a sixth type variable is used to specify that a variable name must be provided.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 23(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             result += 111;  // += operator requires a variable  6.2.6 Type Equivalency WMLScript supports operations on different data types. All operators (see section 6.3) specify the accepted data types for their operands. Automatic data type conversions (see section 6.8) are used to convert operand values to required data types.  6.2.7 Numeric Values WMLScript supports two different numeric variable values: integer and floating-point values7. Variables can be initialised with integer and floating-point literals and several operators can be used to modify their values during the run-time. Conversion rules between integer and floating-point values are specified in chapter 6.8  var pi     = 3.14; var length = 0; var radius = 2.5; length     = 2*pi*radius;  6.2.7.1 Integer Size The size of the integer is 32 bits (two's complement). This means that the supported value range8 for integer values is: -2147483648 and 2147483647. Lang [WMLSLibs] library functions can be used to get these values during the run-time:  Lang.maxInt() Maximum representable integer value Lang.minInt() Minimum representable integer value   6.2.7.2 Floating-point Size The minimum/maximum values9 and precision for floating-point values are specified by [IEEE754]. WMLScript supports  32-bit single precision floating-point format:  • Maximum value: 3.40282347E+38 • Minimum positive nonzero value (at least the normalised precision must be supported):  1.17549435E-38 or smaller  The Float [WMLSLibs] library can be used to get these values during the run-time:  Float.maxFloat() Maximum representable floating-point value supported.                                                  7 Convention: In cases where the value can be either an integer or a floating-point, a more generic term number is used instead. 8 Compatibility note: ECMAScript does not specify maximum and minimum values for integers. All numbers are represented as floating-point values. 9 Compatibility note: ECMAScript uses double-precision 64-bit format [IEEE754] floating-point values for all numbers.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 24(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Float.minFloat() Smallest positive nonzero floating-point value supported.  The special floating-point number types are handled by using the following rules:  • If an operation results in a floating-point number that is not part of the set of finite real numbers (not a number, positive infinity etc.) supported by the single precision floating-point format then the result is an invalid value. • If an operation results in a floating-point underflow the result is zero (0.0). • Negative and positive zero are equal and undistinguishable.   6.2.8 String Values WMLScript supports strings that can contain letters, digits, special characters etc. Variables can be initialised with string literals and string values can be manipulated both with WMLScript operators and functions specified in the standard String library [WMLSLibs].  var msg = \"Hello\"; var len = String.length(msg); msg     = msg + ' Worlds!';  6.2.9 Boolean Values Boolean values can be used to initialise or assign a value to a variable or in statements which require a boolean value as one of the parameters. Boolean value can be a literal or the result of a logical expression evaluation (see section 6.3.3 for more information).  var truth = true; var lie   = !truth;   6.3 Operators and Expressions The following sections describe the operators supported by WMLScript and how they can be used to form complex expressions.  6.3.1 Assignment Operators WMLScript supports several ways to assign a value to a variable. The simplest one is the regular assignment (=) but assignments with operation are also supported:   Operator Operation = assign += add (numbers)/concatenate (strings) and assign -= subtract and assign *= multiply and assign /= divide and assign div= divide (integer division) and assign    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 25(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Operator Operation %= remainder (the sign of the result equals the sign of the dividend) and assign <<= bitwise left shift and assign >>= bitwise right shift with sign and assign >>>= bitwise right shift zero fill and assign &= bitwise AND and assign ^= bitwise XOR and assign |= bitwise OR and assign  Assignment does not necessarily imply sharing of structure nor does assignment of one variable change the binding of any other variable.  var a = \"abc\"; var b =  a; b     = \"def\";  // Value of a is \"abc\"  6.3.2 Arithmetic Operators WMLScript supports all the basic binary arithmetic operations:  Operator Operation + add (numbers)/concatenation (strings) - subtract * multiply / divide div integer division  In addition to these, a set of more complex binary operations are supported, too:  Operator Operation % remainder, the sign of the result equals the sign of the dividend << bitwise left shift >> bitwise right shift with sign >>> bitwise shift right with zero fill & bitwise AND | bitwise OR ^ bitwise XOR  The basic unary operations supported are:  Operator Operation + plus - minus -- pre-or-post decrement    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 26(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Operator Operation ++ pre-or-post increment ~ bitwise NOT  Examples: var y = 1/3; var x = y*3+(++b);  6.3.3 Logical Operators WMLScript supports the basic logical operations:  Operator Operation && logical AND || logical OR ! logical NOT (unary)  Logical AND operator evaluates the first operand and tests the result. If the result is false, the result of the operation is false and the second operand is not evaluated. If the first operand evaluates to true, the result of the operation is the result of the evaluation of the second operand. If the first operand evaluates to invalid, the second operand is not evaluated and the result of the operation is invalid.  Similarly, the logical OR evaluates the first operand and tests the result. If the result is true, the result of the operation is true and the second operand is not evaluated. If the first operand evaluates to false, the result of the operation is the result of the evaluation of the second operand. If the first operand evaluates to invalid, the second operand is not evaluated and the result of the operation is invalid.  weAgree = (iAmRight && youAreRight) ||           (!iAmRight && !youAreRight);  WMLScript requires a value of boolean type for logical operations. Automatic conversions from other types to boolean type and vice versa are supported (see section 6.8).  Notice: If the value of the first operand for logical AND or OR is invalid, the second operand is not evaluated and the result of the operand is invalid:  var a = (1/0) || foo(); // result: invalid, no call to foo() var b = true  || (1/0); // true var c = false || (1/0); // invalid     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 27(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            6.3.4 String Operators WMLScript supports string concatenation as a built-in operation. The + and += operators used with strings perform a concatenation on the strings. Other string operations10 are supported by a standard String library (see [WMLSLibs]).  var str = \"Beginning\" + \"End\"; var chr = String.charAt(str,10); // chr = \"E\"  6.3.5 Comparison Operators WMLScript supports all the basic comparison operations:  Operator Operation < less than <= less than or equal == equal >= greater or equal > greater than != inequality  Comparison operators use the following rules:  • Boolean: true is larger than false • Integer: Comparison is based on the given integer values • Floating-point: Comparison is based on the given floating-point values • String: Comparison is based on the order of character codes of the given string values. Character codes are defined by the character set supported by the WMLScript Interpreter • Invalid: If at least one of the operands is invalid then the result of the comparison is invalid  Examples: var res = (myAmount > yourAmount); var val = ((1/0) == invalid);      // val = invalid  6.3.6 Array Operators WMLScript does not support arrays11 as such. However, the standard String library (see [WMLSLibs]) supports functions by which array like behaviour can be implemented by using strings. A string can contain elements that are separated by a separator specified by the application programmer. For this purpose, the String library contains functions by which creation and management of string arrays can be done.                                                  10 Compatibility note: ECMAScript supports String objects and a length attribute for each string. WMLScript does not support objects. However, similar functionality is provided by WMLScript libraries. 11 Compatibility note: ECMAScript supports arrays.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 28(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             function dummy() {   var str  = \"Mary had a little lamb\";   var word = String.elementAt(str,4,\" \"); };  6.3.7 Comma Operator WMLScript supports the comma (,) operator by which multiple evaluations can be combined into one expression. The result of the comma operator is the value of the second operand:  for (a=1, b=100; a < 10; a++,b++) {   ... do something ... };  Commas used in the function call to separate parameters and in the variable declarations to separate multiple variable declarations are not comma operators. In these cases, the comma operator must be placed inside the parenthesis:  var a=2; var b=3, c=(a,3); myFunction(\"Name\", 3*(b*a,c)); // Two parameters: \"Name\",9  6.3.8 Conditional Operator WMLScript supports the conditional (?:) operator which takes three operands. The operator selectively evaluates one of the given two operands based on the boolean value of the first operand. If the value of the first operand (condition) is true then the result of the operation is the result of the evaluation of the second operand. If the value of the first operand is false or invalid then the result of the operation is the result of the evaluation of the third operand.  myResult = flag ? \"Off\" : \"On (value=\" + level + \")\";  Notice: This operator behaves like an if statement (see section 6.5.5). The third operand is evaluated if the evaluation of the condition results in false or invalid.  6.3.9 typeof Operator Although WMLScript is a weakly typed language, internally the following basic data types are supported: boolean, integer, floating-point, string and invalid. Typeof (typeof) operator returns an integer value12 that describes the type of the given expression. The possible results are:  Type Code Integer: 0 Floating-point: 1 String: 2                                                  12 Compatibility note: ECMAScript specifies that the typeof operator returns a string representing the variable type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 29(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Type Code Boolean: 3 Invalid: 4  Typeof operator does not try to convert the result from one type to another but returns the type as it is after the evaluation of the expression.  var str    = \"123\"; var myType = typeof str; // myType = 2  6.3.10 isvalid Operator This operator can be used to check the type of the given expression. It returns a boolean value false if the type of the expression is invalid, otherwise true is returned. isvalid operator does not try to convert the result from one type to another but returns the type as it is after the evaluation of the expression.  var str = \"123\"; var ok  = isvalid str;   // true var tst = isvalid (1/0); // false  6.3.11 Expressions WMLScript supports most of the expressions supported by other programming languages. The simplest expressions are constants and variable names, which simply evaluate to either the value of the constant or the variable.  567 66.77 \"This is too simple\" 'This works too' true myAccount  Expressions that are more complex can be defined by using simple expressions together with operators and function calls.  myAccount + 3 (a + b)/3 initialValue + nextValue(myValues);  6.3.12 Expression Bindings The following table contains all operators supported by WMLScript. The table also contains information about operator precedence (the order of evaluation) and the operator associativity (left-to-right (L) or right-to-left (R)):     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 30(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Preced-ence13 Associativity Operator Operand types Result type Operation performed 1 R ++ number number* pre- or post-increment (unary) 1 R -- number number* pre- or post-decrement (unary) 1 R + number number* unary plus 1 R - number number* unary minus (negation) 1 R ~ integer integer* bitwise NOT (unary) 1 R ! boolean boolean* logical NOT (unary) 1 R typeof any integer return internal data type (unary) 1 R isvalid any boolean check for validity (unary) 2 L * numbers number* multiplication 2 L / numbers floating-point* division 2 L div integers integer* integer division 2 L % integers integer* remainder 3 L - numbers number* subtraction 3 L + numbers or strings number or string* addition (numbers) or string concatenation 4 L << integers integer* bitwise left shift 4 L >> integers integer* bitwise right shift with sign 4 L >>> integers integer* bitwise right shift with zero fill 5 L <, <= numbers or strings boolean* less than, less than or equal 5 L >, >= numbers or strings boolean* greater than, greater or equal 6 L == numbers or strings boolean* equal (identical values) 6 L != numbers or strings boolean* not equal (different values) 7 L & integers integer* bitwise AND 8 L ^ integers integer* bitwise XOR 9 L | integers integer* bitwise OR 10 L && booleans boolean* logical AND 11 L || booleans boolean* logical OR 12 R ? : boolean, any, any any* conditional expression 13 R = variable, any any assignment 13 R *=, -= variable, number number* assignment with numeric operation 13 R /= variable, number floating-point* assignment with numeric operation 13 R %=, div= variable, integer integer* assignment with integer operation                                                  13 Binding: 0 binds tightest    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 31(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Preced-ence13 Associativity Operator Operand types Result type Operation performed 13 R += variable, number or string number or string* assignment with addition or concatenation 13 R <<=, >>=, >>>=, &=, ^=, |= variable, integer integer* assignment with bitwise operation 14 L , any any multiple evaluation  * The operator can return an invalid value in case the data type conversions fail (see section 6.8 for more information about conversion rules) or one of the operands is invalid.  6.4 Functions A WMLScript function is a named part of the WMLScript compilation unit that can be called to perform a specific set of statements and to return a value. The following sections describe how WMLScript functions can be declared and used. 6.4.1 Declaration Function declaration can be used to declare a WMLScript function name (Identifier) with the optional parameters (FormalParameterList) and a block statement that is executed when the function is called. All functions have the following characteristics:  • Function declarations cannot be nested. • Function names must be unique within one compilation unit. • All parameters to functions are passed by value. • Function calls must pass exactly the same number of arguments to the called function as specified in the function declaration. • Function parameters behave like local variables that have been initialised before the function body (block of statements) is executed. • A function always returns a value. By default it is an empty string (\"\"). However, a return statement can be used to specify other return values.  Functions in WMLScript are not data types14 but a syntactical feature of the language.  Syntax: FunctionDeclaration : externopt  function Identifier ( FormalParameterListopt ) Block ;opt FormalParameterList : Identifier FormalParameterList , Identifier                                                   14 Compatibility note: Functions in ECMAScript are actual data types.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 32(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Arguments: The optional extern keyword can be used to specify a function to be externally accessible. Such functions can be called from outside the compilation unit in which they are defined. There must be at least one externally accessible function in a compilation unit. Identifier is the name specified for the function. FormalParameterList (optional) is a comma-separated list of argument names. Block is the body of the function that is executed when the function is called and the parameters have been initialised by the passed arguments.  Examples: function currencyConverter(currency, exchangeRate) {   return currency*exchangeRate; };  extern function testIt() {   var UDS = 10;   var FIM = currencyConverter(USD, 5.3); };  6.4.2 Function Calls The way a function is called depends on where the called (target) function is declared. The following sections describe the three function calls supported by WMLScript: local script function call, external function call and library function call.  6.4.2.1 Local Script Functions Local script functions (defined inside the same compilation unit) can be called simply by providing the function name and a comma separated list of arguments (number of arguments must match the number of parameters15 accepted by the function).  Syntax: LocalScriptFunctionCall : FunctionName Arguments FunctionName : Identifier Arguments : ( ) ( ArgumentList  ) ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression Functions inside the same compilation unit can be called before the function has been declared:                                                  15 Compatibility note: ECMAScript supports a variable number of arguments in a function call.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 33(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             function test2(param) {   return test1(param+1); };  function test1(val) {   return val*val; };  6.4.2.2 External Functions External function calls must be used when the called function is declared in an external compilation unit. The function call is similar to a local function call but it must be prefixed with the name of the external compilation unit.  Syntax: ExternalScriptFunctionCall : ExternalScriptName # FunctionName Arguments ExternalScriptName : Identifier Pragma use url (see section 6.7) must be used to specify the external compilation unit. It defines the mapping between the external unit and a name that can be used within function declarations. This name and the hash symbol (#) are used to prefix the standard function call syntax:  use url OtherScript \"http://www.host.com/script\";  function test3(param) {   return OtherScript#test2(param+1); };  6.4.2.3 Library Functions Library function calls must be used when the called function is a WMLScript standard library function [WMLSLibs].  Syntax: LibraryFunctionCall : LibraryName . FunctionName Arguments LibraryName : Identifier A library function can be called by prefixing the function name with the name of the library (see section 6.6 for more information) and the dot symbol (.):    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 34(134)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             function test4(param) {   return Float.sqrt(Lang.abs(param)+1); };  6.4.3 Default Return Value The default return value for a function is an empty string (\"\"). Return values of functions can be ignored (ie, function call as a statement):  function test5() {   test4(4); };   6.5 Statements WMLScript statements consist of expressions and keywords used with the appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line.  The following sections define the statements available in WMLScript16: empty statement, expression statement, block statement, break, continue, for, if...else, return, var, while.  6.5.1 Empty Statement Empty statement is a statement that can be used where a statement is needed but no operation is required.  Syntax: EmptyStatement : ;   Examples: while (!poll(device)) ; // Wait until poll() is true  6.5.2 Expression Statement Expression statements are used to assign values to variables, calculate mathematical expressions, make function calls etc.  Syntax: ExpressionStatement : Expression ; Expression : AssignmentExpression Expression , AssignmentExpression                                                  16 Compatibility note: ECMAScript supports also for..in and with statements.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 35(135)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             Examples: str  = \"Hey \" + yourName; val3 = prevVal + 4; counter++; myValue1 = counter, myValue2 = val3; alert(\"Watch out!\"); retVal = 16*Lang.max(val3,counter);  6.5.3 Block Statement A set of statements enclosed in the curly brackets is a block statement. It can be used anywhere a single statement is needed.  Syntax: Block : { StatementListopt } StatementList : Statement   StatementList Statement   Example: {   var i = 0;   var x = Lang.abs(b);   popUp(\"Remember!\"); }  6.5.4 Variable Statement This statement declares variables with initialisation (optional, variables are initialised to empty string (\"\") by default). The scope of the declared variable is the rest of the current function (see section 6.2.2 for more information about variable scoping).   Syntax: VariableStatement : var VariableDeclarationList ; VariableDeclarationList : VariableDeclaration VariableDeclarationList , VariableDeclaration VariableDeclaration : Identifier VariableInitializeropt VariableInitializer : = ConditionalExpression    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 36(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             Arguments: Identifier is the variable name. It can be any legal identifier. ConditionalExpression is the initial value of the variable and can be any legal expression. This expression (or the default initialisation to an empty string) is evaluated every time the variable statement is executed.  Variable names must be unique within a single function.  Examples: function count(str) {   var result = 0;      // Initialized once   while (str != \"\") {     var ind = 0;       // Initialized every time     // modify string   };   return result };  function example(param) {   var a = 0;   if (param > a) {     var b = a+1;       // Variables a and b can be used   } else {     var c = a+2;       // Variables a, b and c can be used   };   return a;            // Variable a, b and c are accessible };  6.5.5 If Statement This statement is used to specify conditional execution of statements. It consists of a condition and one or two statements and executes the first statement if the specified condition is true. If the condition is false, the second (optional) statement is executed.  Syntax: IfStatement : if ( Expression ) Statement else Statement  if ( Expression ) Statement   Arguments: Expression (condition) can be any WMLScript expression that evaluates (directly or after conversion) to a boolean or an invalid value. If condition evaluates to true, the first statement is executed. If condition evaluates to false or invalid, the second (optional) else statement is executed. Statement can be any WMLScript statement, including another (nested) if statement. else is always tied to the closest if.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 37(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Example: if (sunShines) {   myDay = \"Good\";   goodDays++; } else   myDay = \"Oh well...\";  6.5.6 While Statement This statement is used to create a loop that evaluates an expression and, if it is true, execute a statement. The loop repeats as long as the specified condition is true.  Syntax: WhileStatement : while ( Expression ) Statement    Arguments: Expression (condition) can be any WMLScript expression that evaluates (directly or after the conversion) to a boolean or an invalid value. The condition is evaluated before each execution of the loop statement. If this condition evaluates to true, the Statement is performed. When condition evaluates to false or invalid, execution continues with the statement following Statement. Statement is executed as long as the condition evaluates to true.  Example: var counter = 0; var total   = 0; while (counter < 3) {   counter++;   total += c; };  6.5.7 For Statement This statement is used to create loops. The statement consists of three optional expressions enclosed in parentheses and separated by semicolons followed by a statement executed in the loop.  Syntax: ForStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement  for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement   Arguments: The first Expression or VariableDeclarationList (initialiser) is typically used to initialise a counter variable. This expression may optionally declare new variables with the var keyword. The scope of the defined variables is the rest of the function (see section 6.2.2 for more information about variable scoping).  The second Expression (condition) can be any WMLScript expression that evaluates (directly or after the conversion) to a boolean or an invalid value. The condition is evaluated on each pass through the    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 38(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            loop. If this condition evaluates to true, the Statement is performed. This conditional test is optional. If omitted, the condition always evaluates to true.  The third Expression (increment-expression) is generally used to update or increment the counter variable. Statement is executed as long as the condition evaluates to true.  Example:  for (var index = 0; index < 100; index++) {   count += index;   myFunc(count); };  6.5.8 Break Statement This statement is used to terminate the current while or for loop and continue the program execution from the statement following the terminated loop. It is an error to use break statement outside a while or a for statement.  Syntax: BreakStatement : break ;  Example: function testBreak(x) {   var index = 0;   while (index < 6) {     if (index == 3) break;     index++;   };   return index*x; };  6.5.9 Continue Statement This statement is used to terminate execution of a block of statements in a while or for loop and continue execution of the loop with the next iteration. Continue statement does not terminate the execution of the loop:  • In a while loop, it jumps back to the condition.  • In a for loop, it jumps to the update expression.   It is an error to use continue statement outside a while or a for statement.  Syntax: ContinueStatement : continue ;     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 39(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Example:  var index = 0; var count = 0; while (index < 5) {    index++;    if (index == 3)       continue;    count += index; };  6.5.10 Return Statement This statement can be used inside the function body to specify the function return value. If no return statement is specified or none of the function return statements is executed, the function returns an empty string by default.  Syntax: ReturnStatement : return Expressionopt ;  Example: function square( x ) {   if (!(Lang.isFloat(x))) return invalid;   return x * x; };   6.6 Libraries WMLScript supports the usage of libraries17. Libraries are named collections of functions that belong logically together. These functions can be called by using a dot (‘.’) separtor with the library name and the function name with parameters:  An example of a library function call:  function dummy(str) {   var i = String.elementAt(str,3,\" \"); };  6.6.1 Standard Libraries Standard libraries are specified in more detail in the WAP-194-WMLScript Standard Libraries Specification [WMLSLibs].                                                    17 Compatibility note: ECMAScript does not support libraries. It supports a set of predefined objects with attributes. WMLScript uses libraries to support similar functionality.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 40(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            6.7 Pragmas WMLScript supports the usage of pragmas that specify compilation unit level information. Pragmas are specified at the beginning of the compilation unit before any function declaration. All pragmas start with the keyword use and are followed by pragma specific attributes.  Syntax: CompilationUnit : Pragmasopt FunctionDeclarations Pragmas : Pragma Pragmas Pragma Pragma : use PragmaDeclaration ; PragmaDeclaration : ExternalCompilationUnitPragma AccessControlPragma MetaPragma The following sections contain more information about the supported pragmas.  6.7.1 External Compilation Units WMLScript compilation units can be accessed by using a URL. Thus, each WMLScript function can be accessed by specifying the URL of the WMLScript resource and its name. A use url pragma must be used when calling a function in an external compilation unit.  Syntax: ExternalCompilationUnitPragma : url Identifier StringLiteral  The use url pragma specifies the location (URL) of the external WMLScript resource and gives it a local name. This name can then be used inside the function declarations to make external function calls (see section 6.4.2.2).  use url OtherScript \"http://www.host.com/app/script\";  function test(par1, par2) {   return OtherScript#check(par1-par2); };  The behaviour of the previous example is the following:  • The pragma specifies a URL to a WMLScript compilation unit. • The function call loads the compilation unit by using the given URL (http://www.host.com/app/script) • The content of the compilation unit is verified and the specified function (check) is executed    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 41(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             The use url pragma has its own name space for local names. However, the local names must be unique within one compilation unit. The following URLs are supported:  • Uniform Resource Locators [RFC2396] without a hash mark (#) or a fragment identifier. The schemes supported are specified in [WAE]. • Relative URLs [RFC2396] without a hash mark (#) or a fragment identifier: The base URL is the URL that identifies the current compilation unit.  The given URL must be escaped according to the URL escaping rules. No compile time automatic escaping, URL syntax or URL validity checking is performed.  6.7.2 Access Control A WMLScript compilation unit can protect its content by using an access control pragma. Access control must be performed before calling external functions. It is an error for a compilation unit to contain more than one access control pragma.  Syntax: AccessControlPragma : access AccessControlSpecifier AccessControlSpecifier : domain StringLiteral path StringLiteral domain StringLiteral path StringLiteral Every time an external function is invoked an access control check is performed to determine whether the destination compilation unit allows access from the caller. Access control pragma is used to specify domain and path attributes against which these access control checks are performed. If a compilation unit has a domain and/or path attribute, the referring compilation unit's URL must match the values of the attributes. Matching is done as follows: the access domain is suffix-matched against the domain name portion of the referring URL and the access path is prefix-matched against the path portion of the referring URL. Domain and path attributes follow the URL capitalisation rules.  Domain suffix matching is done using the entire element of each sub-domain and must match each element exactly (e.g. www.wapforum.org shall match wapforum.org, but shall not match forum.org).  Path prefix matching is done using entire path elements and must match each element exactly (e.g. /X/Y matches /X, but does not match /XZ).  The domain attribute defaults to the current compilation unit's domain. The path attribute defaults to the value \"/\".   To simplify the development of applications that may not know the absolute path to the current compilation unit, the path attribute accepts relative URLs [RFC2396]. The user agent converts the relative path to an absolute path and then performs prefix matching against the path attribute.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 42(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Given the following access control attributes for a compilation unit:  use access domain \"wapforum.org\" path \"/finance\";  The following referring URLs would be allowed to call the external functions specified in this compilation unit:  http://wapforum.org/finance/money.cgi https://www.wapforum.org/finance/markets.cgi http://www.wapforum.org/finance/demos/packages.cgi?x=123&y=456  The following referring URLs would not be allowed to call the external functions:  http://www.test.net/finance http://www.wapforum.org/internal/foo.wml  By default, access control is disabled (ie, all external functions have public access).  6.7.3 Meta-Information Pragmas can also be used to specify compilation unit specific meta-information. Meta-information is specified with property names and values. This specification does not define any properties, nor does it define how user agents must interpret meta-data. User agents are not required to act on the meta-data.  Syntax: MetaPragma : meta MetaSpecifier MetaSpecifier : MetaName MetaHttpEquiv MetaUserAgent MetaName : name MetaBody MetaHttpEquiv : http equiv MetaBody MetaUserAgent : user agent MetaBody MetaBody : MetaPropertyName MetaContent MetaSchemeopt Meta-pragmas have three attributes: property name, content (the value of the property) and optional scheme (specifies a form or structure that may be used to interpret the property value – the values vary depending on the type of meta-data). The attribute values are string literals.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 43(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            6.7.3.1 Name Name meta-pragma is used to specify meta-information intended to be used by the origin servers. The user agent should ignore any meta-data named with this attribute. Network servers should not emit WMLScript content containing meta-name pragmas.  use meta name \"Created\" \"18-March-1998\";  6.7.3.2 HTTP Equiv HTTP equiv meta-pragma is used to specify meta-information that indicates that the property should be interpreted as an HTTP header (see [RFC2068]). Meta-data named with this attribute should be converted to a WSP or HTTP response header if the compilation unit is compiled before it arrives at the user agent.  use meta http equiv \"Keywords\" \"Script,Language\";  6.7.3.3 User Agent User agent meta-pragma is used to specify meta-information intended to be used by the user agents. This meta-data must be delivered to the user agent and must not be removed by any network intermediary.  use meta user agent \"Type\" \"Test\";      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 44(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             6.8 Automatic Data Type Conversion Rules In some cases, WMLScript operators require specific data types as their operands. WMLScript supports automatic data type conversions to meet the requirements of these operators. The following sections describe the different conversions in detail.   6.8.1 General Conversion Rules WMLScript is a weakly typed language and the variable declarations do not specify a type. However, internally the language handles the following data types:  • Boolean: represents a boolean value true or false. • Integer: represents an integer value • Floating-point: represents a floating-point value • String: represents a sequence of characters • Invalid: represents a type with a single value invalid  A variable at any given time can contain a value of one of these types. WMLScript provides an operator typeof, which can be used to determine what is the current type of a variable or any expression (no conversions are performed).  Each WMLScript operator accepts a predefined set of operand types. If the provided operands are not of the right data type an automatic conversion must take place. The following sections specify the legal automatic conversions between two data types.  6.8.2 Conversions to String Legal conversions from other data types to string are:  • Integer value must be converted to a string of decimal digits that follows the numeric string grammar rules for decimal integer literals. See section 7.4 for more information about the numeric string grammar. • Floating-point value must be converted to an implementation-dependent string representation that follows the numeric string grammar rules for decimal floating-point literals (see section 7.1.4 for more information about the numeric string grammar). The resulting string representation must be equal to the original value (ie .5 can be represented as \"0.5\", \".5e0\", etc.). • The boolean value true is converted to string \"true\" and the value false is converted to string \"false\". • Invalid can not be converted to a string value.  6.8.3 Conversions to Integer Legal conversions from other data types to integer are:  • A string can be converted into an integer value only if it contains a decimal representation of an integer number (see section 7.4 for the numeric string grammar rules for a decimal integer literal). • Floating-point value cannot be converted to an integer value.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 45(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            • The boolean value true is converted to integer value 1, false to 0. • Invalid can not be converted to an integer value.  6.8.4 Conversions to Floating-Point Legal conversions from other data types to floating-point are:  • A string can be converted into a floating-point value only if it contains a valid representation of a floating-point number (see section 7.4 for the numeric string grammar rules for a decimal floating-point literal). • An integer value is converted to a corresponding floating-point value. • The boolean value true is converted to a floating-point value 1.0, false to 0.0. • Invalid can not be converted to a floating-point value.  The conversions between a string and a floating-point type must be transitive within the ability of the data types to accurately represent the value. A conversion could result in loss of precision.  6.8.5 Conversions to Boolean Legal conversions from other data types to boolean are:  • The empty string (\"\") is converted to false. All other strings are converted to true. • An integer value 0 is converted to false. All other integer numbers are converted to true. • A floating-point value 0.0 is converted to false. All other floating-point numbers are converted to true. • Invalid can not be converted to a boolean value. 6.8.6 Conversions to Invalid There are no legal conversion rules for converting any of the other data types to an invalid type. Invalid is either a result of an operation error or a literal value. In most cases, an operator that has an invalid value as an operand evaluates to invalid (see the operators in sections 6.3.8, 6.3.9 and 6.3.10 for the exceptions to this rule).  6.8.7 Summary The following table contains a summary of the legal conversions between data types:  Given \\ Used as: Boolean Integer Floating-point String Boolean true - 1 1.0 \"true\" Boolean false - 0 0.0 \"false\" Integer 0 false - 0.0 \"0\" Any other integer true - floating-point value of number string representation of a decimal integer    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 46(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Given \\ Used as: Boolean Integer Floating-point String Floating-point 0.0 false Illegal - implementation-dependent string representation of a floating-point value, e.g. \"0.0\" Any other floating-point true Illegal - implementation-dependent string representation of a floating-point value Empty string false Illegal Illegal - Non-empty string true integer value of its string representation (if valid – see section 7.4 for numeric string grammar for decimal integer literals) or illegal floating-point value of its string representation (if valid – see section 7.4 for numeric string grammar for decimal floating-point literals) or illegal - invalid Illegal Illegal Illegal Illegal   6.9 Operator Data Type Conversion Rules The previous conversion rules specify when a legal conversion is possible between two data types. WMLScript operators use these rules, the operand data type and values to select the operation to be performed (in case the type is used to specify the operation) and to perform the data type conversions needed for the selected operation. The rules are specified in the following way:  • The additional conversion rules are specified in steps. Each step is performed in the given order until the operation and the data types for its operands are specified and the return value defined. • If the type of the operand value matches the required type then the value is used as such. • If the operand value does not match the required type then a conversion from the current data type to the required one is attempted: • Legal conversion: Conversion can be done only if the general conversion rules (see section 6.9) specify a legal conversion from the current operator data type to the required one. • Illegal conversion: Conversion can not be done if the general conversion rules (see section 6.9) do not specify a legal conversion from the current type to the required type. • If a legal conversion rule is specified for the operand (unary) or for all operands then the conversion is performed, the operation performed on the converted values and the result returned as the value of the operation. If a legal conversion results in an invalid value then the operation returns an invalid value. • If no legal conversion is specified for one or more of the operands then no conversion is performed and the next step in the additional conversion rules is performed.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 47(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            The following table contains the operator data type conversion rules based on the given operand data types:  Operand types Additional conversion rules Examples Boolean(s) ß If the operand is of type boolean or can be converted into a boolean value18 then perform a boolean operation and return its value, otherwise ß return invalid true && 3.4 => boolean 1 && 0 => boolean \"A\" || \"\" => boolean !42 => boolean !invalid => invalid 3 && invalid => invalid Integer(s) ß If the operand is of type integer or can be converted into an integer value18 then perform an integer operation and return its value, otherwise ß return invalid \"7\" << 2 => integer true << 2 => integer 7.2 >> 3 => invalid 2.1 div 4 => invalid Floating-point(s) ß If the operand is of type floating-point or can be converted into a floating-point value18 then perform a floating-point operation and return its value, otherwise ß return invalid - String(s) ß If the operand is of type string or can be converted into a string value18 then perform a string operation and return its value, otherwise ß return invalid - Integer or floating-point (unary) ß If the operand is of type integer or can be converted into an integer value then perform an integer operation and return its value, otherwise ß if the operand is of type floating-point or can be converted into a floating-point value18 then perform a floating-point operation and return its value, otherwise ß return invalid +10 =>   integer -10.3 =>     float -\"33\" =>   integer +\"47.3\" =>     float +true => integer 1 -false => integer 0 -\"ABC\" =>   invalid -\"9e9999\" =>   invalid                                                   18 Conversion can be done if the general conversion rules (see section Error! Reference source not found.) specify a legal conversion from the current type to the required type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 48(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Operand types Additional conversion rules Examples Integers or floating-points ß If  at least one of the operands is of type floating-point then convert the remaining operand to a floating-point value, perform a floating-point operation and return its value, otherwise ß if the operands are of type integer or can be converted into integer values18 then perform an integer operation and return its value, otherwise ß if the operands can be converted into floating-point values18 then perform a floating-point operation and return its value, otherwise ß return invalid 100/10.3 =>   float 33*44 => integer \"10\"*3 => integer 3.4*\"4.3\" =>   float \"10\"-\"2\" => integer \"2.3\"*\"3\" =>   float 3.2*\"A\" => invalid .9*\"9e999\" => invalid invalid*1 => invalid Integers, floating-points or strings ß If at least one of the operands is of type string then convert the remaining operand to a string value, perform a string operation and return its value, otherwise ß if  at least one of the operands is of type floating-point then convert the remaining operand to a floating-point value, perform a floating-point operation and return its value, otherwise ß if the operands are of type integer or can be converted into integer values18 then perform an integer operation and return its value, otherwise ß return invalid 12+3 => integer 32.4+65 =>   float \"12\"+5.4 =>  string 43.2<77 =>   float \"Hey\"<56 =>  string 2.7+\"4.2\" =>  string 9.9+true =>   float 3<false => integer \"A\"+invalid => invalid Any ß Any type is accepted a = 37.3 =>  float b = typeof \"s\" => string   6.10 Summary of Operators and Conversions The following sections contain a summary on how the conversion rules are applied to WMLScript operators and what are their possible return value types.  6.10.1 Single-Typed Operators Operators that accept operands of one specific type use the general conversion rules directly. The following list contains all single type WMLScript operators:     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 49(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Operator Operand types Result type19 Operation performed ! boolean boolean logical NOT (unary) && booleans boolean logical AND || booleans boolean logical OR ~ integer integer bitwise NOT (unary) << integers integer bitwise left shift >> integers integer bitwise right shift with sign >>> integers integer bitwise right shift with zero fill & integers integer bitwise AND ^ integers integer bitwise XOR | integers integer bitwise OR % integers integer remainder div integers integer integer division <<=, >>=, >>>=, &=, ^=, |= first operand: variable second operand: integer integer assignment with bitwise operation %=, div= first operand: variable second operand: integer integer assignment with numeric operation  6.10.2 Multi-Typed Operators The following sections contain the operators that accept multi-typed operands:   Operator Operand types Result type20 Operation performed ++ integer or floating-point integer/floating-point pre- or post-increment (unary) -- integer or floating-point integer/floating-point pre- or post-decrement (unary) + integer or floating-point integer/floating-point unary plus - integer or floating-point integer/floating-point unary minus (negation) * integers or floating-points integer/floating-point multiplication / integers or floating-points floating-point division - integers or floating-points integer/floating-point subtraction + integers, floating-points or strings integer/floating-point/string addition or string concatenation                                                  19 All operators may have an invalid result type. 20 All operators (unless otherwise stated) may have an invalid result type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 50(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Operator Operand types Result type20 Operation performed <, <= integers, floating-points or strings boolean less than, less than or equal >, >= integers, floating-points or strings boolean greater than, greater or equal == integers, floating-points or strings boolean equal (identical values) != integers, floating-points or strings boolean not equal (different values) *=, -= first operand: variable second operand: integer or floating-point integer/floating-point assignment with numeric operation /= first operand: variable second operand: integer or floating-point floating-point assignment with division += first operand: variable second operand: integer, floating-point or string integer/floating-point/string assignment with addition or concatenation typeof any integer21 return internal data type (unary) isvalid any boolean21 check for validity (unary) ? : first operand: boolean second operand: any third operand: any any conditional expression = first operand: variable second operand: any any assignment , first operand: any second operand: any any multiple evaluation                                                   21 Operator does not generate an invalid result type.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 51(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             7. WMLSCRIPT GRAMMAR The grammars used in this specification are based on [ECMA262]. Since WMLScript is not compliant with ECMAScript, the standard has been used only as the basis for defining WMLScript language.   7.1 Context-Free Grammars This section describes the context-free grammars used in this specification to define the lexical and syntactic structure of a WMLScript program.  7.1.1 General A context-free grammar consists of a number of productions. Each production has an abstract symbol called a nonterminal as its left-hand side and a sequence of one or more nonterminal and terminal symbols as its right-hand side. For each grammar, the terminal symbols are drawn from a specified alphabet.  A given context-free grammar specifies a language. It begins with a production consisting of a single distinguished nonterminal called the goal symbol followed by a (perhaps infinite) set of possible sequences of terminal symbols. They are the result of repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.  7.1.2 Lexical Grammar A lexical grammar for WMLScript is given in section 7.2. This grammar has as its terminal symbols the characters of the Universal Character set of ISO/IEC-10646 ([ISO10646]). It defines a set of productions, starting from the goal symbol Input that describes how sequences of characters are translated into a sequence of input elements.  Input elements other than white space and comments form the terminal symbols for the syntactic grammar for WMLScript and are called WMLScript tokens. These tokens are the reserved words, identifiers, literals and punctuators of the WMLScript language. Simple white space and single-line comments are simply discarded and do not appear in the stream of input elements for the syntactic grammar. Likewise, a multi-line comment is simply discarded if it contains no line terminator; but if a multi-line comment contains one or more line terminators, then it is replaced by a single line terminator, which becomes part of the stream of input elements for the syntactic grammar.  Productions of the lexical grammar are distinguished by having two colons \"::\" as separating punctuation.  7.1.3 Syntactic Grammar The syntactic grammar for WMLScript is given in section 7.3. This grammar has WMLScript tokens defined by the lexical grammar as its terminal symbols. It defines a set of productions, starting from the goal symbol CompilationUnit, that describe how sequences of tokens can form syntactically correct WMLScript programs.  When a stream of Unicode characters is to be parsed as a WMLScript, it is first converted to a stream of input elements by repeated application of the lexical grammar; this stream of input elements is then parsed by a single application of the syntax grammar. The program is syntactically    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 52(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal CompilationUnit, with no tokens left over.  Productions of the syntactic grammar are distinguished by having just one colon \":\" as punctuation.  7.1.4 Numeric String Grammar A third grammar is used for translating strings into numeric values. This grammar is similar to the part of the lexical grammar having to do with numeric literals and has as its terminal symbols the characters of the Unicode character set. This grammar appears in section 7.4.  Productions of the numeric string grammar are distinguished by having three colons “:::” as punctuation.  7.1.5 Grammar Notation Terminal symbols of the lexical and string grammars and some of the terminal symbols of the syntactic grammar, are shown in fixed width font, both in the productions of the grammars and throughout this specification whenever the text directly refers to such a terminal symbol. These are to appear in a program exactly as written.  Nonterminal symbols are shown in italic type. The definition of a nonterminal is introduced by the name of the nonterminal being defined followed by one or more colons. (The number of colons indicates to which grammar the production belongs.) One or more alternative right-hand sides for the nonterminal then follow on succeeding lines. For example, the syntactic definition: WhileStatement : while ( Expression ) Statement states that the nonterminal WhileStatement represents the token while, followed by a left parenthesis token, followed by an Expression, followed by a right parenthesis token, followed by a Statement. The occurrences of Expression and Statement are themselves nonterminals. As another example, the syntactic definition: ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression states that an ArgumentList may represent either a single AssignmentExpression or an ArgumentList, followed by a comma, followed by an AssignmentExpression. This definition of ArgumentList is recursive, that is to say, it is defined in terms of itself. The result is that an ArgumentList may contain any positive number of arguments, separated by commas, where each argument expression is an AssignmentExpression. Such recursive definitions of nonterminals are common.  The subscripted suffix \"opt\", which may appear after a terminal or nonterminal, indicates an optional symbol. The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it. This means that: VariableDeclaration : Identifier VariableInitializeropt  is a convenient abbreviation for:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 53(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            VariableDeclaration : Identifier Identifier VariableInitializer and that: IterationStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement is a convenient abbreviation for: IterationStatement : for ( ; Expressionopt ; Expressionopt ) Statement for ( Expression ; Expressionopt ; Expressionopt ) Statement which in turn is an abbreviation for: IterationStatement : for ( ; ; Expressionopt ) Statement for ( ; Expression ; Expressionopt ) Statement for ( Expression ; ; Expressionopt ) Statement for ( Expression ; Expression ; Expressionopt ) Statement which in turn is an abbreviation for: IterationStatement : for ( ; ; ) Statement for ( ; ; Expression ) Statement for ( ; Expression ; ) Statement for ( ; Expression ; Expression ) Statement for ( Expression ; ; ) Statement for ( Expression ; ; Expression ) Statement for ( Expression ; Expression ; ) Statement for ( Expression ; Expression ; Expression ) Statement therefore, the nonterminal IterationStatement actually has eight alternative right-hand sides.  Any number of occurrences of LineTerminator may appear between any two consecutive tokens in the stream of input elements without affecting the syntactic acceptability of the program.  When the words \"one of\" follow the colon(s) in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition. For example, the lexical grammar for WMLScript contains the production: ZeroToThree :: one of 0 1 2 3 which is merely a convenient abbreviation for: ZeroToThree :: 0 1 2    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 54(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            3 When an alternative in a production of the lexical grammar or the numeric string grammar appears to be a multicharacter token, it represents the sequence of characters that would make up such a token.  The right-hand side of a production may specify that certain expansions are not permitted by using the phrase \"but not\" and then indicating the expansions to be excluded. For example, the production: Identifier :: IdentifierName but not ReservedWord means that the nonterminal Identifier may be replaced by any sequence of characters that could replace IdentifierName provided that the same sequence of characters could not replace ReservedWord.  Finally, a few nonterminal symbols are described by a descriptive phrase in roman type in cases where it would be impractical to list all the alternatives: SourceCharacter: any Unicode character  7.1.6 Source Text WMLScript source text is represented as a sequence of characters representable using the Universal Character set of ISO/IEC-10646 ([ISO10646]). Currently, this character set is identical to Unicode 2.0 ([UNICODE]). Within this document, the terms ISO10646 and Unicode are used interchangeably and will indicate the same document character set. SourceCharacter :: any Unicode character There is no requirement that WMLScript documents be encoded using the full Unicode encoding (e.g. UCS-4). Any character encoding (\"charset\") that contains an inclusive subset of the characters in Unicode may be used (e.g. US-ASCII, ISO-8859-1, etc.).  Every WMLScript program can be represented using only ASCII characters (which are equivalent to the first 128 Unicode characters). Non-ASCII Unicode characters may appear only within comments and string literals. In string literals, any Unicode character may also be expressed as a Unicode escape sequence consisting of six ASCII characters, namely \\u plus four hexadecimal digits. Within a comment, such an escape sequence is effectively ignored as part of the comment. Within a string literal, the Unicode escape sequence contributes one character to the string value of the literal.   7.1.7 Character Set Resolution When a WMLScript document is accompanied by external information (e.g. HTTP or MIME) there may be multiple sources of information available to determine the character encoding. In this case, their relative priority and the preferred method of handling conflict should be specified as part of the higher-level protocol. See, for example, the documentation of the \"text/vnd.wap.wmlscript\" and \"application/vnd.wap.wmlscriptc\" MIME media types.  The pragma meta http equiv (see section 6.7.3.2), if present in the document, is never used to determine the character encoding.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 55(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            If a WMLScript document is transformed into a different format - for example, into the WMLScript bytecode (see section 9.2) - then the rules relevant for that format are used to determine the character encoding.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 56(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             7.2 WMLScript Lexical Grammar The following contains the specification of the lexical grammar for WMLScript:  SourceCharacter :: any Unicode character WhiteSpace :: <TAB> <VT> <FF> <SP> <LF> <CR> LineTerminator :: <LF> <CR> <CR><LF> Comment :: MultiLineComment SingleLineComment MultiLineComment :: /* MultiLineCommentCharsopt */ MultiLineCommentChars :: MultiLineNotAsteriskChar MultiLineCommentCharsopt * PostAsteriskCommentCharsopt PostAsteriskCommentChars :: MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt * PostAsteriskCommentCharsopt MultiLineNotAsteriskChar :: SourceCharacter but not asterisk * MultiLineNotForwardSlashOrAsteriskChar :: SourceCharacter but not forward-slash / or asterisk * SingleLineComment :: // SingleLineCommentCharsopt SingleLineCommentChars :: SingleLineCommentChar SingleLineCommentCharsopt    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 57(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            SingleLineCommentChar :: SourceCharacter but not LineTerminator Token :: ReservedWord Identifier Punctuator Literal ReservedWord :: Keyword KeywordNotUsedByWMLScript FutureReservedWord BooleanLiteral InvalidLiteral Keyword :: one of access equiv meta while agent extern name url break for path  continue function return  div header typeof  div= http use  domain if user  else isvalid var  KeywordNotUsedByWMLScript :: one of delete null in this lib void new with FutureReservedWord :: one of case default finally struct catch do import super class enum private switch const export public throw debugger extends sizeof try Identifier :: IdentifierName but not ReservedWord IdentifierName :: IdentifierLetter IdentifierName IdentifierLetter IdentifierName DecimalDigit    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 58(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            IdentifierLetter :: one of22 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _                          DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9 Punctuator :: one of23 = > < == <= >= != , ! ~ ? : . && || ++ -- + - * / & | ^ % << >> >>> += -= *= /= &= |= ^= %= <<= >>= >>>= ( ) { } ; #    Literal ::24 InvalidLiteral BooleanLiteral NumericLiteral StringLiteral InvalidLiteral ::25 invalid BooleanLiteral ::26 true false NumericLiteral :: DecimalIntegerLiteral HexIntegerLiteral OctalIntegerLiteral DecimalFloatLiteral DecimalIntegerLiteral :: 0 NonZeroDigit DecimalDigitsopt                                                  22 Compatibility note: ECMAScript supports the usage of dollar sign ($) in identifier names, too. 23 Compatibility note: ECMAScript supports arrays and square brackets ([ ]), too. 24 Compatibility note: ECMAScript supports Null literal, too. 25 Compatibility note: ECMAScript does not support invalid. 26 Compatibility note: ECMAScript supports both lower and upper case boolean literals.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 59(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            NonZeroDigit :: one of 1 2 3 4 5 6 7 8 9 HexIntegerLiteral :: 0x HexDigit 0X HexDigit HexIntegerLiteral HexDigit HexDigit :: one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F OctalIntegerLiteral :: 0 OctalDigit OctalIntegerLiteral OctalDigit OctalDigit :: one of 0 1 2 3 4 5 6 7 DecimalFloatLiteral :: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPart DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit ExponentPart :: ExponentIndicator SignedInteger ExponentIndicator :: one of e E SignedInteger :: DecimalDigits + DecimalDigits - DecimalDigits StringLiteral :: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt  ' DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharactersopt SingleStringCharacters :: SingleStringCharacter SingleStringCharactersopt    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 60(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            DoubleStringCharacter :: SourceCharacter but not double-quote \"or backslash \\ or LineTerminator EscapeSequence SingleStringCharacter :: SourceCharacter but not single-quote 'or backslash \\ or LineTerminator EscapeSequence EscapeSequence :: CharacterEscapeSequence OctalEscapeSequence HexEscapeSequence UnicodeEscapeSequence CharacterEscapeSequence ::  \\ SingleEscapeCharacter SingleEscapeCharacter ::  one of ' \" \\ / b f n r t HexEscapeSequence :: \\x HexDigit HexDigit OctalEscapeSequence :: \\ OctalDigit \\ OctalDigit OctalDigit \\ ZeroToThree OctalDigit OctalDigit ZeroToThree :: one of 0 1 2 3 UnicodeEscapeSequence :: \\u HexDigit HexDigit HexDigit HexDigit    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 61(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             7.3 WMLScript Syntactic Grammar The following contains the specification of the syntactic grammar for WMLScript: PrimaryExpression :27 Identifier Literal ( Expression ) CallExpression : 28 PrimaryExpression LocalScriptFunctionCall ExternalScriptFunctionCall LibraryFunctionCall LocalScriptFunctionCall : FunctionName Arguments ExternalScriptFunctionCall : ExternalScriptName # FunctionName Arguments LibraryFunctionCall : LibraryName . FunctionName Arguments FunctionName : Identifier ExternalScriptName : Identifier LibraryName : Identifier Arguments : ( ) ( ArgumentList  ) ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression                                                  27 Compatibility note: ECMAScript supports objects and this, too. 28 Compatibility note: ECMAScript support for arrays ([]) and object allocation (new) removed. MemberExpression is used for specifying library functions, e.g. String.length(\"abc\"), not for accessing members of an object.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 62(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            PostfixExpression : CallExpression  Identifier ++ Identifier -- UnaryExpression :29 PostfixExpression typeof UnaryExpression isvalid UnaryExpression ++ Identifier -- Identifier + UnaryExpression - UnaryExpression ~ UnaryExpression ! UnaryExpression MultiplicativeExpression :30 UnaryExpression MultiplicativeExpression * UnaryExpression MultiplicativeExpression / UnaryExpression MultiplicativeExpression div UnaryExpression MultiplicativeExpression % UnaryExpression AdditiveExpression : MultiplicativeExpression AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression ShiftExpression : AdditiveExpression ShiftExpression << AdditiveExpression ShiftExpression >> AdditiveExpression ShiftExpression >>> AdditiveExpression RelationalExpression : ShiftExpression RelationalExpression < ShiftExpression RelationalExpression > ShiftExpression RelationalExpression <= ShiftExpression RelationalExpression >= ShiftExpression                                                  29 Compatibility note: ECMAScript operators delete and void are not supported. parseInt and parseFloat are supported as library functions. ECMAScipt does not support operator isvalid. 30 Compatibility note: Integer division (div) is not supported by ECMAScript.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 63(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            EqualityExpression : RelationalExpression EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression BitwiseANDExpression : EqualityExpression BitwiseANDExpression & EqualityExpression BitwiseXORExpression : BitwiseANDExpression BitwiseXORExpression ^ BitwiseANDExpression BitwiseORExpression : BitwiseXORExpression BitwiseORExpression | BitwiseXORExpression LogicalANDExpression : BitwiseORExpression LogicalANDExpression && BitwiseORExpression LogicalORExpression : LogicalANDExpression LogicalORExpression || LogicalANDExpression ConditionalExpression : LogicalORExpression LogicalORExpression ? AssignmentExpression : AssignmentExpression AssignmentExpression : ConditionalExpression Identifier AssignmentOperator AssignmentExpression AssignmentOperator :: one of = *= /= %= += -= <<= >>= >>>= &= ^= |= div= Expression : AssignmentExpression Expression , AssignmentExpression    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 64(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Statement :31 Block VariableStatement EmptyStatement ExpressionStatement IfStatement  IterationStatement ContinueStatement BreakStatement ReturnStatement Block : { StatementListopt } StatementList : Statement   StatementList Statement  VariableStatement : var VariableDeclarationList ; VariableDeclarationList : VariableDeclaration VariableDeclarationList , VariableDeclaration VariableDeclaration : Identifier VariableInitializeropt VariableInitializer : = ConditionalExpression EmptyStatement : ; ExpressionStatement : Expression ; IfStatement :32 if ( Expression ) Statement else Statement  if ( Expression ) Statement  IterationStatement :33 WhileStatement  ForStatement                                                    31 Compatibility note: ECMAScript with statement is not supported. 32 else is always tied to the closest if. 33 Compatibility note: ECMAScript for in statement is not supported.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 65(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            WhileStatement : while ( Expression ) Statement   ForStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement  for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement  ContinueStatement :34 continue ; BreakStatement :35 break ; ReturnStatement : return Expressionopt ; FunctionDeclaration :36 externopt  function Identifier ( FormalParameterListopt ) Block ;opt FormalParameterList : Identifier FormalParameterList , Identifier CompilationUnit : Pragmasopt FunctionDeclarations Pragmas :37 Pragma Pragmas Pragma Pragma : use PragmaDeclaration ; PragmaDeclaration : ExternalCompilationUnitPragma AccessControlPragma MetaPragma ExternalCompilationUnitPragma : url Identifier StringLiteral                                                   34 Continue statement can only be used inside a while or a for statement. 35 Break statement can only be used inside a while or a for statement. 36 Compatibility note: ECMAScript does not support keyword extern. 37 Compatibility note: ECMAScript does not support pragmas.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 66(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            AccessControlPragma :38 access AccessControlSpecifier AccessControlSpecifier : domain StringLiteral path StringLiteral domain StringLiteral path StringLiteral MetaPragma : meta MetaSpecifier MetaSpecifier : MetaName MetaHttpEquiv MetaUserAgent MetaName : name MetaBody MetaHttpEquiv : http equiv MetaBody MetaUserAgent : user agent MetaBody MetaBody : MetaPropertyName MetaContent MetaSchemeopt MetaPropertyName : StringLiteral MetaContent : StringLiteral MetaScheme : StringLiteral FunctionDeclarations : FunctionDeclaration FunctionDeclarations FunctionDeclaration   7.4 Numeric String Grammar The following contains the specification of the numeric string grammar for WMLScript. This grammar is used for translating strings into numeric values. This grammar is similar to the part of the lexical                                                  38 Compilation unit can contain only one access control pragma.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 67(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            grammar having to do with numeric literals and has as its terminal symbols the characters of the US-ASCII character set.  The following grammar can be used to convert strings into the following numeric literal values:   • Decimal Integer Literal: Use the following productions starting from the goal symbol StringDecimalIntegerLiteral. • Decimal Floating-Point Literal: Use the following productions starting from the goal symbol StringDecimalFloatingPointLiteral.  StringDecimalIntegerLiteral ::: StrWhiteSpaceopt StrSignedDecimalIntegerLiteral StrWhiteSpaceopt StringDecimalFloatingPointLiteral ::: StrWhiteSpaceopt StrSignedDecimalIntegerLiteral StrWhiteSpaceopt StrWhiteSpaceopt StrSignedDecimalFloatingPointLiteral StrWhiteSpaceopt StrWhiteSpace ::: StrWhiteSpaceChar StrWhiteSpaceopt StrWhiteSpaceChar ::: <TAB> <VT> <FF> <SP> <LF> <CR> StrSignedDecimalIntegerLiteral ::: StrDecimalDigits  + StrDecimalDigits - StrDecimalDigits StrSignedDecimalFloatingPointLiteral ::: StrDecimalFloatingPointLiteral  + StrDecimalFloatingPointLiteral  - StrDecimalFloatingPointLiteral StrDecimalFloatingPointLiteral ::: StrDecimalDigits . StrDecimalDigitsopt StrExponentPartopt . StrDecimalDigits StrExponentPartopt StrDecimalDigits StrExponentPart StrDecimalDigits ::: StrDecimalDigit StrDecimalDigits StrDecimalDigit    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 68(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            StrDecimalDigit ::: one of 0 1 2 3 4 5 6 7 8 9 StrExponentPart ::: StrExponentIndicator StrSignedInteger StrExponentIndicator ::: one of e E StrSignedInteger ::: StrDecimalDigits + StrDecimalDigits - StrDecimalDigits     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 69(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             8. WMLSCRIPT BYTECODE INTERPRETER The textual format of WMLScript language must be compiled into a binary format before it can be interpreted by the WMLScript bytecode interpreter. WMLScript compiler encodes one WMLScript compilation unit into WMLScript bytecode using the encoding format presented in the chapter 9. A WMLScript compilation unit (see section 7.1.3) is a unit containing pragmas and any number of WMLScript functions. WMLScript compiler takes one compilation unit as input and generates the WMLScript bytecode as its output.   8.1 Interpreter Architecture WMLScript interpreter takes WMLScript bytecode as its input and executes encoded functions as they are called. The following figure contains the main parts related to WMLScript bytecode interpretation:  IPVariablesCall StackFunctionscall http://www.host.com/script#myFunc(“Test”,12)OperandStackStateWMLScriptBytecodeWMLScriptLibrariesInterpreterFunctions...myFunc()...www.host.com/script: Figure 1: General architecture of the WMLScript interpreter  The WMLScript interpreter can be used to call and execute functions in a compilation unit encoded as WMLScript bytecode. Each function specifies the number of parameters it accepts and the instructions used to express its behaviour. Thus, a call to a WMLScript function must specify the function, the function call arguments and the compilation unit in which the function is declared. Once the execution completes normally, the WMLScript interpreter returns the control and the return value back to the caller.  Execution of a WMLScript function means interpreting the instructions residing in the WMLScript bytecode. While a function is being interpreted, the WMLScript interpreter maintains the following state information:  • IP (Instruction Pointer): This points to an instruction in the bytecode that is being interpreted. • Variables: Maintenance of function parameters and variables.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 70(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            • Operand stack: It is used for expression evaluation and passing arguments to called functions and back to the caller. • Function call stack: WMLScript function can call other functions in the current or separate compilation unit or make calls to library functions. The function call stack maintains the information about functions and their return addresses.    8.2 Character Set The WMLScript Interpreter must use only one character set (native character set) for all of its string operations. Transcoding between different character sets and their encodings is allowed as long as the WMLScript string operations are performed using only the native character set. The native character set can be requested by using the Lang library function Lang.characterSet() (see [WMLSLibs])   8.3 WMLScript and URLs The World Wide Web is a network of information and devices. Three areas of specification ensure widespread interoperability:  • A unified naming model. Naming is implemented with Uniform Resource Locators (URLs), which provide standard way to name any network resource. See [RFC2396]. • Standard protocols to transport information (e.g. HTTP). • Standard content types (e.g. HTML, WMLScript).  WMLScript assumes the same reference architecture as HTML and the World Wide Web. WMLScript compilation unit is named using URLs and can be fetched over standard protocols that have HTTP semantics, such as [WSP]. URLs are defined in [RFC2396]. The character set used to specify URLs is also defined in [RFC2396].  In WMLScript, URLs are used in the following situations:  • When a user agent wants to make a WMLScript call (see section 8.3.4) • When specifying external compilation units (see section 6.7.1) • When specifying access control information (see section 6.7.2)  8.3.1 URL Schemes A WMLScript interpreter must implement the URL schemes specified in [WAE].  8.3.2 Fragment Anchors WMLScript has adopted the HTML de facto standard of naming locations within a resource. A WMLScript fragment anchor is specified by the document URL, followed by a hash mark (#), followed by a fragment identifier. WMLScript uses fragment anchors to identify individual WMLScript functions within a WMLScript compilation unit. The syntax of the fragment anchor is specified in the following section.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 71(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            8.3.3 URL Call Syntax This section contains the grammar for specifying the syntactic structure of the URL call. This grammar is similar to the part of the WMLScript lexical and syntactic grammars having to do with function calls and literals and has as its terminal symbols the characters of the US-ASCII character set.  http://www.host.com/scr#foo(1,-3,'hello')       // OK http://www.host.com/scr#bar(1,-3+1,'good')      // Error http://www.host.com/scr#test(foo(1,-3,'hello')) // Error  Only the syntax for the fragment anchor (#) is specified (see [RFC2396] for more information about URL syntax).  URLCallFragmentAnchor ::: FunctionName( ) FunctionName( ArgumentList ) FunctionName ::: FunctionNameLetter FunctionName FunctionNameLetter FunctionName DecimalDigit FunctionNameLetter ::: one of a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _                          DecimalDigit ::: one of 0 1 2 3 4 5 6 7 8 9 ArgumentList : Argument ArgumentList , Argument Argument ::: WhiteSpacesopt Literal WhiteSpacesopt WhiteSpaces : WhiteSpace White Spaces WhiteSpace WhiteSpace ::: <TAB> <VT> <FF> <SP> <LF> <CR>    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 72(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Literal ::: InvalidLiteral BooleanLiteral NumericLiteral StringLiteral InvalidLiteral ::: invalid BooleanLiteral ::: true false NumericLiteral ::: SignedDecimalIntegerLiteral SignedDecimalFloatLiteral SignedDecimalIntegerLiteral ::: DecimalIntegerLiteral + DecimalIntegerLiteral - DecimalIntegerLiteral DecimalIntegerLiteral ::: DecimalDigit DecimalDigitsopt SignedDecimalFloatLiteral ::: DecimalFloatLiteral + DecimalFloatLiteral - DecimalFloatLiteral DecimalFloatLiteral ::: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPart DecimalDigits ::: DecimalDigit DecimalDigits DecimalDigit ExponentPart ::: ExponentIndicator SignedInteger ExponentIndicator ::: one of e E SignedInteger ::: DecimalDigits + DecimalDigits - DecimalDigits    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 73(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            StringLiteral ::: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt  ' DoubleStringCharacters ::: DoubleStringCharacter DoubleStringCharactersopt SingleStringCharacters ::: SingleStringCharacter SingleStringCharactersopt DoubleStringCharacter ::: SourceCharacter but not double-quote \" SingleStringCharacter ::: SourceCharacter but not single-quote '  8.3.4 URL Calls and Parameter Passing A user agent can make a call to an external WMLScript function by providing the following information using URLs and fragment anchors:  • URL of the compilation unit (e.g. http://www.x.com/myScripts.scr) • Function name and parameters as the fragment anchor (e.g. testFunc('Test%20argument',-8))  The final URL with the fragment is:  http://www.x.com/myScripts.scr#testFunc('Test%20argument',-8)  If the given URL denotes a valid WMLScript compilation unit then:  • Access control checks are performed (see section 6.7.2). The call fails if the caller does not have rights to call the compilation unit. • The function name specified in the fragment anchor is matched against the external functions in the compilation unit. The call fails if no match is found. • The parameter list in the fragment anchor (see section 8.3.2) is parsed and the given arguments with their appropriate types (string literals as string data types, integer literals as integer data types etc.) are passed to the function. The call fails if the parameter list has an invalid syntax.  8.3.5 Character Escaping URL calls can use URL escaping (see [RFC2396]) and any other escaping mechanism provided by the content format containing the URL call to specify the URL. However, the URL Call Syntax is applied to the URL fragment only after it has been properly unescaped.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 74(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            8.3.6 Relative URLs WMLScript has adopted the use of relative URLs, as specified in [RFC2396]. [RFC2396] specifies the method used to resolve relative URLs in the context of a WMLScript compilation unit. The base URL of a WMLScript compilation unit is the URL that identifies the compilation unit.   8.4 Bytecode Semantics The following sections describe the general encoding rules that must be used to generate WMLScript bytecode. These rules specify what the WMLScript compiler can assume from the behaviour of the WMLScript interpreter.  8.4.1 Passing of Function Arguments Arguments must be present in the operand stack in the same order as they are presented in a WMLScript function declaration at the time of a WMLScript or library function call. Thus, the first argument is pushed into the operand stack first, the second argument is pushed next, etc. The instruction executing the call must pop the arguments from the operand stack and use them to initialise the appropriate function variables.  8.4.2 Allocation of Variable Indexes A WMLScript function refers to variables by using unique variable indexes. These indexes must match with the information specified for each called WMLScript function: the number of arguments the function accepts and the number of local variables used by the function. Thus, the variable index allocation must be done using the following rules:  1) Function Arguments: Indexes for function arguments must be allocated first. The allocation must be done in the same order as the arguments are pushed into the operand stack (0 is allocated for the first argument, 1 for the second argument, etc.). The number of indexes allocated for function arguments must match the number of arguments accepted by the function. Thus, if the function accepts N arguments then the last variable index must be N-1. If the function does not accept any arguments (N = 0) then no variable indexes are allocated.  2) Local variables: Indexes for local variables must be allocated subsequently from the first variable index (N) that is not used for function arguments. The number of indexes allocated for local variables must match the number of local variables used by the function.  8.4.3 Automatic Function Return Value WMLScript function must return an empty string in case the end of the function is encountered without a return statement. The compiler can rely on the WMLScript interpreter to automatically return an empty string every time the interpreter reaches the end of the function without encountering a return instruction.  8.4.4 Initialisation of Variables The WMLScript compiler should rely on the WMLScript interpreter to initialise all function local variables initially to an empty string. Thus, the compiler does not have to generate initialization code for variables declared without initialisation.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 75(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            8.5 Access Control WMLScript provides two mechanisms for controlling the access to the functions in the WMLScript compilation unit: external keyword and a specific access control pragma. Thus, the WMLScript interpreter must support the following behaviour:  • External functions: Only functions specified as external can be called from other compilation units (see section 6.4.2.2). • Access control: Access to the external functions defined inside a compilation unit is allowed from other compilation units that match the given access domain and access path definitions (see section 6.7.2).      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 76(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             9. WMLSCRIPT BINARY FORMAT The following sections contain the specifications for the WMLScript bytecode, a compact binary representation for compiled WMLScript functions. The format was designed to allow for compact transmission over narrowband channels, with no loss of functionality or semantic information.  9.1 Conventions The following sections describe the general encoding conventions and data types used to generate WMLScript bytecode.  9.1.1 Used Data Types The following data types are used in the specification of the WMLScript Bytecode:  Data Type Definition bit 1 bit of data byte 8 bits of opaque data int8 8 bit signed integer (two's complement encoding) u_int8 8 bit unsigned integer int16 16 bit signed integer (two's complement encoding) u_int16 16 bit unsigned integer mb_u_int16 16 bit unsigned integer, in multi-byte integer format. See section 9.1.2 for more information. int32 32 bit signed integer (two's complement encoding) u_int32 32 bit unsigned integer mb_u_int32 32 bit unsigned integer, in multi-byte integer format. See section 9.1.2 for more information. float32 32 bit signed floating-point value in ANSI/IEEE Std 754-1985  [IEEE754] format.  Network byte order for multi-byte integer values is \"big-endian\". In other words, the most significant byte is transmitted on the network first followed subsequently by the less significant bytes. Network bit ordering for bit fields within a byte is \"big-endian\". In other words, bit fields described first are placed in the most significant bits of the byte.  9.1.2 Multi-byte Integer Format This encoding uses a multi-byte representation for integer values. A multi-byte integer consists of a series of octets, where the most significant bit is the continuation flag and the remaining seven bits are a scalar value. The continuation flag is used to indicate that an octet is not the end of the multi-byte sequence. A single integer value is encoded into a sequence of N octets. The first N-1 octets have the continuation flag set to a value of one (1). The final octet in the series has a continuation flag value of zero.  The remaining seven bits in each octet are encoded in a big-endian order, e.g., most significant bit first. The octets are arranged in a big-endian order, e.g. the most significant seven bits are transmitted first. In the situation where the initial octet has less than seven bits of value, all unused bits must be set to zero (0).    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 77(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             For example, the integer value 0xA0 would be encoded with the two-byte sequence 0x81 0x20. The integer value 0x60 would be encoded with the one-byte sequence 0x60.  9.1.3 Character Encoding WMLScript bytecode supports the following character encoding:  • UTF-8 (see [RFC2279])  Other character sets and their encodings are supported by a special string type (string with external character encoding definition, see section 9.4.1.3.3) that does not explicitly specify the used character set or its encoding but assumes that this information is provided as part of the compilation unit itself (constant pool). The following rules must be applied when defining the used character encoding for these special strings:  • If the value of the character set number in the constant pool is non-zero then this number defines the used character encoding (the number denotes the MIBEnum value assigned by the IANA for all character sets). • If the value of the character set number in the constant pool is zero (0) then the character set is unknown.  The compiler must select one of these encodings to encode character strings in the WMLScript bytecode.  WMLScript language constructs, such as function names in WMLScript, are written by using only a subset of Unicode character set i.e, a subset of US-ASCII characters. Thus, function names in the WMLScript bytecode must use a fixed UTF-8 encoding.  9.1.4 Notational Conventions WMLScript bytecode is a set of bytes that represent WMLScript functions in a binary format. It contains all the information needed by the WMLScript interpreter to execute the encoded functions as specified. The bytecode can be divided into sections and subsections each of which containing a binary representation of a logical WMLScript unit.  The WMLScript bytecode structure and content is presented using the following table based notation:  Name Data type and size Comment This is a name of a section inside the bytecode. This specifies a data type and its size reserved for a section in case it cannot be divided into smaller subsections. Subsection specification is given in a separate table. Reference to the table is provided. This gives a general overview of the meaning of this section.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 78(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Name Data type and size Comment The name of the next section. Any number of sections can be presented in one table.   ...     The following conventions apply:  • Sections of bytecode are represented as rows in a table. • Each section may be divided into subsections and represented in separate tables. In such case a reference to the subsection table is provided. • Repetitive sections are denoted by section name followed by three dots (...).   9.2 WMLScript Bytecode The WMLScript encoding contains two major elements: constant literals and the constructs needed to describe the behaviour of each WMLScript function. Thus, the WMLScript bytecode consists of the following sections:  Name Data type and size Comment HeaderInfo See section 9.3 Contains general information related to the bytecode. ConstantPool See section 9.4 Contains the information of all constants specified as part of the WMLScript compilation unit that are encoded into bytecode. PragmaPool See section 9.5  Contains the information related to pragmas specified as part of the WMLScript compilation unit that are encoded into bytecode. FunctionPool See section 9.6 Contains all the information related to the encoding of functions and their behaviour.  The following sections define the encoding of these sections and their subsections in detail.   9.3 Bytecode Header The header of the WMLScript bytecode contains the following information:     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 79(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Name Data type and size Comment VersionNumber byte Version number of the WMLScript bytecode. The version byte contains the major version minus one in the upper 4 bits and the minor version in the lower 4 bits.  The current version is 1.1. Thus, the version number must be encoded as 0x01. CodeSize mb_u_int32 The size of the rest of the bytecode (not including the version number and this variable) in bytes   9.4 Constant Pool Constant pool contains all the constants used by the WMLScript functions. Each of the constants has an index number starting from zero that is defined by its position in the list of constants. The instructions use this index to refer to specific constants.  Name Data type and size Comment NumberOfConstants mb_u_int16 Specifies how many constants are encoded in this pool. CharacterSet mb_u_int16 Specifies the character set used by the string constants in the constant pool. The character set is specified as an integer that denotes a MIBEnum value assigned by the IANA for all character sets (see [WSP] for more information). Constants... See section 9.4.1 Contains the definitions for each constant in the constant pool. The number of constants is specified by NumberOfConstants.   9.4.1 Constants Constants are stored into the bytecode one after each other. Encoding of each constant starts with the definition of its type (integer, floating-point, string etc.). It is being followed by constant type specific data that represents the actual value of the constant:  Name Data type and size Comment ConstantType u_int8 The type of the constant. ConstantValue See sections 9.4.1.1, 9.4.1.2 and 9.4.1.3 Type specific value definition.  The following encoding for constant types is used:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 80(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             Code Type Encoding 0 8 bit signed integer 9.4.1.1.1 1 16 bit signed integer 9.4.1.1.2 2 32 bit signed integer 9.4.1.1.3 3 32 bit signed floating-point 9.4.1.2 4 UTF-8 String 9.4.1.3.1 5 Empty String 9.4.1.3.2 6 String with external character encoding definition 9.4.1.3.3 7-255 Reserved for future use   9.4.1.1 Integers WMLScript bytecode supports 8 bit, 16 bit and 32 bit signed integer constants. The compiler can optimise the WMLScript bytecode size by selecting the smallest integer constant type that can still hold the integer constant value.  9.4.1.1.1 8 Bit Signed Integer 8 bit signed integer constants are represented in the following format:  Name Data type and size Comment ConstantInteger8 int8 The value of the 8 bit signed integer constant.  9.4.1.1.2 16 Bit Signed Integer 16 bit signed integer constants are represented in the following format:  Name Data type and size Comment ConstantInteger16 int16 The value of the 16 bit signed integer constant.  9.4.1.1.3 32 Bit Signed Integer 32 bit signed integer constants are represented in the following format:  Name Data type and size Comment ConstantInteger32 int32 The value of the 32 bit signed integer constant.   9.4.1.2 Floats Floating-point constants are represented in 32-bit ANSI/IEEE Std 754-1985 [IEEE754] format:     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 81(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Name Data type and size Comment ConstantFloat32 float32 The value of the 32 bit floating point constant.  9.4.1.3 Strings WMLScript bytecode supports several ways to encode string constants39 into the constant pool. The compiler can select the most suitable character encoding supported by the client and optimise the WMLScript bytecode size by selecting the smallest string constant type that can still hold the string constant value.  9.4.1.3.1 UTF-8 Strings Strings that use UTF-8 encoding are encoded into the bytecode by first specifying their length and then the content:  Name Data type and size Comment StringSizeUTF8 mb_u_int32 The size of the following string in bytes (not containing this variable). ConstantStringUTF8 StringSizeUTF8 bytes The value of the Unicode string (non-null terminated) constant encoded using UTF-8. See 9.1.3 for more information about transfer encoding of strings.  9.4.1.3.2 Empty Strings Empty strings do not need any additional encoding for their value.   9.4.1.3.3 Strings with External Character Encoding Definition Strings that use external character encoding definition are encoded into the bytecode by first specifying their length and then the content:  Name Data type and size Comment StringSizeExt mb_u_int32 The size of the following string in bytes (not containing this field). ConstantStringExt StringSizeExt bytes The value of the string (non-null terminated) constant using external character encoding definition. See 9.1.3 for more information about transfer encoding of strings.                                                     39 Note that string constants can contain embedded null characters.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 82(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            9.5  Pragma Pool The pragma pool contains the information for pragmas defined in the compiled compilation unit.  Name Data type and size Comment NumberOfPragmas mb_u_int16 The number of pragmas. Pragmas... See 9.5.1 Contains the definitions for each pragma in the pragma pool. The number of pragmas is specified by NumberOfPragmas.  9.5.1 Pragmas Pragmas are stored into the bytecode one after each other. Encoding of each pragma starts with the definition of its type. It is being followed by pragma type specific data that represents the actual value of the pragma:  Name Data type and size Comment PragmaType u_int8 The type of the pragma following pragma value. PragmaValue See sections 9.5.1.1 and 9.5.1.2 Pragma type specific value definition.  The following encoding for pragma types is used:  Code Type Encoding 0 Access Domain 9.5.1.1.1 1 Access Path 9.5.1.1.2 2 User Agent Property 9.5.1.2.1 3 User Agent Property and Scheme 9.5.1.2.2 4-255 Reserved for future use   9.5.1.1 Access Control Pragmas Access control information is encoded into the bytecode using two different pragma types: access domain and access path. The pragma pool can contain only one entry for each access control pragma type.  9.5.1.1.1 Access Domain This pragma specifies the access domain to be used for the access control.  Name Data type and size Comment AccessDomainIndex mb_u_int16 Constant pool index to a string constant containing the value of the access domain. The referred constant type must be between 4 and 6.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 83(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             9.5.1.1.2 Access Path This pragma specifies the access path to be used for access control.  Name Data type and size Comment AccessPathIndex mb_u_int16 Constant pool index to a string constant containing the value of the access path. The referred constant type must be between 4 and 6.  9.5.1.2 Meta-Information Pragmas These pragmas contain meta-information that is mean for the WMLScript interpreter. Meta-information contains following entities: name, content and scheme (optional)  9.5.1.2.1 User Agent Property User agent properties are encoded by first specifying their name and then their value as indexes to the constant pool:  Name Data type and size Comment PropertyNameIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property name. ContentIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property value.  9.5.1.2.2 User Agent Property and Scheme This pragma is encoded by specifying the property name, the value and the additional scheme:  Name Data type and size Comment PropertyNameIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property name. ContentIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property value. SchemeIndex mb_u_int16 Constant pool index to a string constant (constant types 4 to 6) containing the property schema.       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 84(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            9.6 Function Pool The function pool contains the function definitions. Each of the functions has an index number starting from zero that is defined by its position in the list of functions. The instructions use this index to refer to specific functions.  Name Data type and size Comment NumberOfFunctions u_int8 The number of functions specified in this function pool. FunctionNameTable See section 9.6.1 Function name table contains the names of all external functions present in the bytecode. Functions... See section 9.6.2 Contains the bytecode for each function.  9.6.1 Function Name Table The names of the functions that are specified as external (extern) are stored into a function name table. The names must be presented in the same order as the functions are represented in the function pool. Functions that are not specified as external are not represented in the function name table. The format of the table is the following:  Name Data type and size Comment NumberOfFunctionNames u_int8 The number of function names stored into the following table. FunctionNames... See section 9.6.1.1  Each external function name represented in the same order as the functions are stored into the function pool.  9.6.1.1 Function Names Function name is provided only for functions that are specified as external in WMLScript. Each name is represented in the following manner:  Name Data type and size Comment FunctionIndex u_int8 The index of the function for which the following name is provided. FunctionNameSize u_int8 The size of the following function name in bytes (not including this variable). FunctionName FunctionNameSize bytes The characters of the function name encoded by using UTF-8. See section 9.1.3 for more information about function name encoding.   9.6.2 Functions Each function is defined by its prologue and code array:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 85(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             Name Data type and size Comment NumberOfArguments u_int8 The number of arguments accepted by the function. NumberOfLocalVariables u_int8 The number of local variables used by the function (not including arguments). FunctionSize mb_u_int32 Size of the following CodeArray (not including this variable) in bytes. CodeArray See section 9.6.2.1 Contains the code of the function.   9.6.2.1 Code Array Code array contains all instructions that are needed to implement the behaviour of a WMLScript function. See 10 for more information about WMLScript instruction set.  Name Data type and size Comment Instructions... See section 10 The encoded instructions.   9.7 Limitations The following table contains the limitations inherent in the selected bytecode format and instructions:  Maximum size of the bytecode 4294967295 bytes Maximum number of constants in the constant pool 65535 Maximum number of different constant types 256 Maximum size of a constant string 4294967295 bytes Maximum size of a constant URL 4294967295 bytes Maximum length of function name 255 Maximum number of different pragma types 256 Maximum number of pragmas in the pragma pool 65536 Maximum number of functions in the function pool 255 Maximum number of function parameters 255 Maximum number of local variables / function 255 Maximum number of local variables and function parameters 256 Maximum number of libraries 65536 Maximum number of functions / library 256     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 86(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             10. WMLSCRIPT INSTRUCTION SET The WMLScript instruction set specifies a set of assembly level instructions that must be used to encode all WMLScript language constructs and operations. These instructions are defined in such a way that they are easy to implement efficiently on a variety of platforms.  10.1 Conversion Rules The following table contains a summary of the conversion rules specified for the WMLScript interpreter:  Rule – Operand type(s) Conversions 1 – Boolean(s) See the conversion rules for Boolean(s) in section Operator Data Type Conversion Rules (6.9) 2 – Integer(s) See the conversion rules for Integer(s) in section Operator Data Type Conversion Rules (6.9) 3 – Floating-point(s) See the conversion rules for Floating-point(s) in section Operator Data Type Conversion Rules (6.9) 4 – String(s) See the conversion rules for String(s) in section Operator Data Type Conversion Rules (6.9) 5 – Integer or floating-point (unary) See the conversion rules for Integer or floating-point (unary) in section Operator Data Type Conversion Rules (6.9) 6 – Integers or floating-points See the conversion rules for Integers or floating-points in section Operator Data Type Conversion Rules (6.9) 7 – Integers, floating-points or strings See the conversion rules for Integers, floating-points or strings in section Operator Data Type Conversion Rules (6.9) 8 - Any See the conversion rules for Any in section Operator Data Type Conversion Rules (6.9)   10.2 Fatal Errors The following table contains a summary of the fatal errors specified for the WMLScript interpreter:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 87(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             Error code: Fatal Error: 1 (Verification Failed) See section Verification Failed (12.3.1.1) for details 2 (Fatal Library Function Error) See section Fatal Library Function Error (12.3.1.2) for details 3 (Invalid Function Arguments) See section Invalid Function Arguments (12.3.1.3) for details 4 (External Function Not Found) See section External Function Not Found (12.3.1.4) for details 5 (Unable to Load Compilation Unit) See section Unable to Load Compilation Unit (12.3.1.5) for details 6 (Access Violation) See section Access Violation (12.3.1.6) for details 7 (Stack Underflow) See section Stack Underflow (12.3.1.7) for details 8 (Programmed Abort) See section Programmed Abort (12.3.2.1) for details 9 (Stack Overflow) See section Stack Overflow (12.3.3.1) for details* 10 (Out of Memory) See section Out of Memory (12.3.3.2) for details* 11 (User Initiated) See section User Initiated (12.3.4.1) for details* 12 (System Initiated) See section System Initiated (12.3.4.2) for details*  * These fatal errors are not related to computation but can be generated as a result of memory exhaustion or external signals.   10.3 Optimisations WMLScript instruction set has been defined so that it provide at least the minimal set of instructions by which WMLScript language operations can be presented. Since the WMLScript bytecode is being transferred from the gateway to the client through a narrowband connection, the selected instructions have been optimised so that the compilers can generate code of minimal size. In some cases, this    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 88(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            has meant that several instructions with different parameters have been introduced to perform the same operation. The compiler should use the one that generates optimal code.  Inline parameters have been used to optimally pack information into as few bytes as possible. The following inline parameter optimisations have been introduced:  Signature Available instructions Used for 1XXPPPPP 4 JUMP_FW_S, JUMP_BW_S, TJUMP_FW_S, LOAD_VAR_S 010XPPPP 2 STORE_VAR_S, LOAD_CONST_S 011XXPPP 4 CALL_S, CALL_LIB_S, INCR_VAR_S 00XXXXXX 63 The rest of the instructions   10.4 Notational Conventions The following sections contain the definitions of instructions in the WMLScript instruction set. For each instruction, the following information is provided:   • Instruction: A symbolic name given to the instruction and its parameters. • Opcode: The 8-bit encoding of the instruction. • Parameters: Parameter description specifying their ranges and semantics. Some instructions are optimised and can contain an implicit parameter as part of the encoding, ie, a set of bits from the 8 bit encoding is reserved for a parameter value. • Operation: Description of the operation of the instruction, its parameters and the effects they have on the execution and the operand stack. • Operands: Specifies the number of operands required by the instruction and all acceptable operand types. • Conversion: Specifies the used conversion rule (see section 10.1). • Result: Specifies the result and its type. • Operand stack: Specifies the effect on the operand stack. It is described by using notation where the part before the arrow (=>) represents the stack before the instruction has been executed and the part after the arrow the stack after the execution. • Errors: Specifies the possible fatal errors that can occur during the execution of the instruction (see section 10.2).  All instructions except the control flow instructions continue the execution at the following instruction. Control flow instructions specify the next instruction explicitly.  Fatal errors that can be encountered at any time (see section External Exceptions in 12.3.4 and Memory Exhaustion Errors in 12.3.3) are assumed to be possible with every instruction.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 89(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            The result of the instruction can be an invalid value. This is not explicitly stated with each instruction but is assumed to be the result of the used conversion rule, a load of an invalid or unsupported floating-point constant or a result of an operation with an invalid operand.   10.5 Instructions The following sections contain the descriptions of each instruction divided into subcategories.  10.5.1 Control Flow Instructions 10.5.1.1 Instruction: JUMP_FW_S Opcode: 100iiiii (iiiii is the implicit unsigned offset) Parameter: Offset is an unsigned 5-bit integer in the range of 0..31. Operation: Jumps forward to an offset. Execution proceeds at the given offset from the address of the first byte following this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 1 + offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.1.2 Instruction: JUMP_FW offset Opcode: 00000001 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Jumps forward to an offset. Execution proceeds at the given offset from the address of the first byte following this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 2 + offset. Operands: - Conversion: - Operand stack: No change Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 90(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.1.3 Instruction: JUMP_FW_W <offset1,offset2> Opcode: 00000010 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Jumps forward to an offset. Execution proceeds at the given offset from the address of the first byte following this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 3 + offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.1.4 Instruction: JUMP_BW_S Opcode: 101iiiii (iiiii is the implicit unsigned offset) Parameter: Offset is an unsigned 5-bit integer in the range of 0..31. Operation: Jumps backward to an offset. Execution proceeds at the given offset from the address of this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 91(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.1.5 Instruction: JUMP_BW offset Opcode: 00000011 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Jumps backward to an offset. Execution proceeds at the given offset from the address of this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.1.6 Instruction: JUMP_BW_W <offset1,offset2> Opcode: 00000100 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Jumps backward to an offset. Execution proceeds at the given offset from the address of this instruction. More specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 92(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.1.7 Instruction: TJUMP_FW_S Opcode: 110iiiii (iiiii is the implicit unsigned offset) Parameter: Offset is an unsigned 5-bit integer in the range of 0..31. Operation: Pops a value from the operand stack and jumps forward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of the first byte following this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 1 + offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.1.8 Instruction: TJUMP_FW offset Opcode: 00000101 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value from the operand stack and jumps forward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of the first byte following this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 2 + offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 93(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.1.9 Instruction: TJUMP_FW_W <offset1,offset2> Opcode: 00000110 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Pops a value from the operand stack and jumps forward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of the first byte following this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n + 3 + offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.1.10 Instruction: TJUMP_BW offset Opcode: 00000111 Parameter: Offset is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value from the operand stack and jumps backward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 94(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.1.11 Instruction: TJUMP_BW_W <offset1,offset2> Opcode: 00001000 Parameter: Offset is an unsigned 16-bit integer <offset1, offset2> in the range of 0..65535. Operation: Pops a value from the operand stack and jumps backward to an offset if the value is either false or invalid. Execution proceeds at the given offset from the address of this instruction (more specifically, if the address of this instruction is n and the value of the offset is offset then the next instruction to be executed is at address: n - offset). Otherwise, the execution continues at the next instruction. Operand: Any Conversion: 1 – Boolean(s) Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)   10.5.2 Function Call Instructions 10.5.2.1 Instruction: CALL_S Opcode: 01100iii (iii is the implicit findex) Parameter: Findex is an unsigned 3-bit integer in the range of 0..7. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a local function defined in the same function pool. Execution proceeds from the first instruction of the function findex. Operands: Variable number, any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 95(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.2.2 Instruction: CALL findex Opcode: 00001001 Parameter: Findex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a local function defined in the same function pool. Execution proceeds from the first instruction of the function findex. Operands: Variable number, any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.2.3 Instruction: CALL_LIB_S lindex Opcode: 01101iii (iii is the implicit findex) Parameters: Findex is an unsigned 3-bit integer in the range of 0..7. Lindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a library function findex defined in the specified library lindex. Operands: Variable number (specified by the called library function), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 2 (Fatal Library Function Error), 7 (Stack Underflow), 8 (Programmed Abort)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 96(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.2.4 Instruction: CALL_LIB  findex  lindex Opcode: 00001010 Parameters: Findex is an unsigned 8-bit integer in the range of 0..255. Lindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a library function findex defined in the specified library lindex. Operands: Variable number (specified by the called library function), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 2 (Fatal Library Function Error), 7 (Stack Underflow), 8 (Programmed Abort)  10.5.2.5 Instruction: CALL_LIB_W findex  <lindex1, lindex2> Opcode: 00001011 Parameters: Findex is an unsigned 8-bit integer in the range of 0..255. Lindex is an unsigned 16-bit integer <lindex1,lindex2> in the range of 0..65535. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a library function findex defined in the specified library lindex. Operands: Variable number (specified by the called library function), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 2 (Fatal Library Function Error), 7 (Stack Underflow), 8 (Programmed Abort)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 97(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.2.6 Instruction: CALL_URL  urlindex  findex  args Opcode: 00001100 Parameters: Urlindex is an unsigned 8-bit integer in the range of 0..255 that must point to the constant pool containing a valid URL. The referred constant type must be between 4 and 6.  Findex is an unsigned 8-bit integer in the range of 0..255 that must point to the constant pool containing a valid function name. The referred constant type must be 4.  Args is an unsigned 8-bit integer in the range of 0..255 that must contain the number of function arguments pushed on the operand stack. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a function specified by findex defined in the specified URL address urlindex. Operands: Variable number (specified by args), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 3 (Invalid Function Arguments), 4 (External Function Not Found), 5 (Unable to Load Compilation Unit), 6 (Access Violation), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 98(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.2.7 Instruction: CALL_URL_W  <urlindex1,urlindex2>  <findex1,findex2>  args Opcode: 00001101 Parameters: Urlindex is an unsigned 16-bit integer <urlindex1,urlindex2> in the range of 0..65535 that must point to the constant pool containing a valid URL. The referred constant type must be between 4 and 6.  Findex is an unsigned 16-bit integer <findex1,findex2> in the range of 0..65535 that must point to the constant pool containing a valid function name. The referred constant type must be 4.  Args is an unsigned integer in the range of 0..255 that must contain the number of function arguments pushed on the operand stack. Operation: Pops function arguments from the operand stack, initialises the function variables (arguments and local variables) and calls a function specified by findex defined in the specified URL address urlindex. Operands: Variable number (specified by args), any type Conversion: - Result:  Any (function return value) Operand stack: ..., [arg1, [arg2 ...]]  =>  ..., ret-value Errors:  1 (Verification Failed), 3 (Invalid Function Arguments), 4 (External Function Not Found), 5 (Unable to Load Compilation Unit), 6 (Access Violation), 7 (Stack Underflow)   10.5.3 Variable Access and Manipulation 10.5.3.1 Instruction: LOAD_VAR_S Opcode: 111iiiii (iiiii is the implicit vindex) Parameter: Vindex is an unsigned 5-bit integer in the range of 0..31. Operation: Pushes the value of the variable vindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the variable) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 99(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.3.2 Instructions: LOAD_VAR vindex Opcode: 00001110 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pushes the value of the variable vindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the variable) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)  10.5.3.3 Instruction: STORE_VAR_S Opcode: 0100iiii  (iiii is the implicit vindex) Parameter: Vindex is an unsigned 4-bit integer in the range of 0..15. Operation:  Pops the value from the operand stack and stores it into the variable vindex. Operand: Any Conversion: 8 - Any Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.3.4 Instruction: STORE_VAR vindex Opcode: 00001111 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops the value from the operand stack and stores it into the variable vindex. Operand: Any Conversion: 8 - Any Result:  - Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 100(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.3.5 Instruction: INCR_VAR_S Opcode: 01110iii (iii is the implicit vindex) Parameter: Vindex is an unsigned 3-bit integer in the range of 0..7. Operation: Increments the value of a variable vindex by one. Operands: - Conversion: 5 – Integer or floating-point (unary) Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.3.6 Instruction: INCR_VAR vindex Opcode: 00010000 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Increments the value of a variable vindex by one. Operands: - Conversion: 5 – Integer or floating-point (unary) Result:  - Operand stack: No change Errors:  1 (Verification Failed)  10.5.3.7 Instruction: DECR_VAR vindex Opcode: 00010001 Operation: Decrements the value of a variable vindex by one. Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operands: - Conversion: 5 – Integer or floating-point (unary) Result:  - Operand stack: No change Errors:  1 (Verification Failed)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 101(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.4 Access To Constants 10.5.4.1 Instruction: LOAD_CONST_S Opcode: 0101iiii (iiii is the implicit cindex) Parameter: Cindex is an unsigned 4-bit integer in the range of 0..15 that points to the constant pool containing the actual constant. The referred constant type must be between 0 and 6. Operation: Pushes the value of the constant denoted by cindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the constant) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)  10.5.4.2 Instruction: LOAD_CONST cindex Opcode: 00010010 Parameter: Cindex is an unsigned 8-bit integer in the range of 0..255 that points to the constant pool containing the actual constant. The referred constant type must be between 0 and 6. Operation: Pushes the value of the constant denoted by cindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the constant) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)  10.5.4.3 Instruction: LOAD_CONST_W <cindex1,cindex2> Opcode: 00010011 Parameter: Cindex is an unsigned 16-bit integer <cindex1,cindex2> in the range of 0..65535 that points to the constant pool containing the actual constant. The referred constant type must be between 0 and 6. Operation: Pushes the value of the constant cindex on the operand stack. Operands: - Conversion: - Result:  Any (content of the constant) Operand stack: ...  =>  ..., value Errors:  1 (Verification Failed)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 102(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.4.4 Instruction: CONST_0 Opcode: 00010100 Parameters: - Operation: Pushes an integer value 0 on the operand stack. Operands: - Conversion: - Result:  Integer Operand stack: ...  =>  ..., value_0 Errors:  -  10.5.4.5 Instruction: CONST_1 Opcode: 00010101 Parameters: - Operation: Pushes an integer value 1 on the operand stack. Operands: - Conversion: - Result:  Integer Operand stack: ...  =>  ..., value_1 Errors:  -  10.5.4.6 Instruction: CONST_M1 Opcode: 00010110 Parameters: - Operation: Pushes an integer value –1 on the operand stack. Operands: - Conversion: - Result:  Integer Operand stack: ...  =>  ..., value_-1 Errors:  -     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 103(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.4.7 Instruction: CONST_ES Opcode: 00010111 Parameters: - Operation: Pushes an empty string on the operand stack. Operands: - Conversion: - Result:  String Operand stack: ...  =>  ..., value_\"\" Errors:  -  10.5.4.8 Instruction: CONST_INVALID Opcode: 00011000 Parameters: - Operation: Pushes an invalid value on the operand stack. Operands: - Conversion: - Result:  Invalid Operand stack: ...  =>  ..., value_invalid Errors:  -  10.5.4.9 Instruction: CONST_TRUE Opcode: 00011001 Parameters: - Operation: Pushes a boolean value true on the operand stack. Operands: - Conversion: - Result:  Boolean Operand stack: ...  =>  ..., value_true Errors:  -     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 104(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.4.10 Instruction: CONST_FALSE Opcode: 00011010 Parameters: - Operation: Pushes a boolean value false on the operand stack. Operands: - Conversion: - Result:  Boolean Operand stack: ...  =>  ..., value_false Errors:  -   10.5.5 Arithmetic Instructions 10.5.5.1 Instruction: INCR Opcode: 00011011  Parameters: - Operation: Increments the value on the top of the operand stack by one. Operand: Integer or floating-point Conversion: 5 – Integer or floating-point (unary) Result:  Integer or floating-point (incremented by one) Operand stack: ..., value  =>  ..., value+1 Errors:  7 (Stack Underflow)  10.5.5.2 Instruction: DECR Opcode: 00011100 Parameters: - Operation: Decrements the value on the top of the operand stack by one. Operand: Integer or floating-point Conversion: 5 – Integer or floating-point (unary) Result:  Integer or floating-point (decremented by one) Operand stack: ..., value  =>  ..., value-1 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 105(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.5.3 Instruction: ADD_ASG vindex Opcode: 00011101 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value from the operand stack and adds the value to the variable vindex. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  For integers or floating-points: variable containing the result of the addition For strings: variable containing the result of string concatenation Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.5.4 Instruction: SUB_ASG vindex Opcode: 00011110 Parameter: Vindex is an unsigned 8-bit integer in the range of 0..255. Operation: Pops a value (subtractor) from the operand stack and subtracts the value from the variable vindex. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Variable containing the result of the subtraction Operand stack: ..., value  =>  ... Errors:  1 (Verification Failed), 7 (Stack Underflow)  10.5.5.5 Instruction: UMINUS Opcode: 00011111 Parameters: - Operation: Pops a value from the operand stack and performs a unary minus operation on it and pushes the result back on the operand stack. Operand: Integer or floating-point Conversion: 5 – Integer or floating-point (unary) Result:  Integer or floating-point (negated) Operand stack: ..., value  =>  ..., -value Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 106(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.5.6 Instruction: ADD Opcode: 00100000 Parameters: - Operation: Pops two values from the operand stack and performs an add operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  For integers or floating-points: the result of the addition For strings: the result of the concatenation Operand stack: ..., value1, value2  =>  ..., value1 + value2 Errors:  7 (Stack Underflow)  10.5.5.7 Instruction: SUB Opcode: 00100001 Parameters: - Operation: Pops two values from the operand stack and performs a subtract operation on them and pushes the result back on the operand stack. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Integer or floating-point Operand stack: ..., value1, value2  =>  ..., value1 - value2 Errors:  7 (Stack Underflow)  10.5.5.8 Instruction: MUL Opcode: 00100010 Parameters: - Operation: Pops two values from the operand stack, performs a multiplication operation on them and pushes the result back on the operand stack. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Integer or floating-point Operand stack: ..., value1, value2  =>  ..., value1 * value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 107(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.5.9 Instruction: DIV Opcode: 00100011 Parameters: - Operation: Pops two values from the operand stack, performs a division operation on them and pushes the result back on the operand stack. Operands: Integers or floating-points Conversion: 6 – Integers or floating-points Result:  Floating-point Operand stack: ..., value1, value2  =>  ..., value1 / value2 Errors:  7 (Stack Underflow)  10.5.5.10 Instruction: IDIV Opcode: 00100100 Parameters: - Operation: Pops two values from the operand stack, performs an integer division operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 IDIV value2 Errors:  7 (Stack Underflow)  10.5.5.11 Instruction: REM Opcode: 00100101 Parameters: - Operation: Pops two values from the operand stack, performs a reminder operation on them (the sign of the result equals the sign of the dividend) and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 % value2 Errors:  7 (Stack Underflow)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 108(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.6 Bitwise Instructions 10.5.6.1 Instruction: B_AND Opcode: 00100110 Parameters: - Operation: Pops two values from the operand stack and performs a bitwise and operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 & value2 Errors:  7 (Stack Underflow)  10.5.6.2 Instruction: B_OR Opcode: 00100111 Parameters: - Operation: Pops two values from the operand stack and performs a bitwise or operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 | value2 Errors:  7 (Stack Underflow)  10.5.6.3 Instruction: B_XOR Opcode: 00101000 Parameters: - Operation: Pops two values from the operand stack, performs a bitwise xor operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value1, value2  =>  ..., value1 ^ value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 109(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.6.4 Instruction: B_NOT Opcode: 00101001 Parameters: - Operation: Pops a value from the operand stack and performs a bitwise complement operation on it and pushes the result back on the operand stack. Operands: Integer Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value  =>  ..., ~value Errors:  7 (Stack Underflow)  10.5.6.5 Instruction: B_LSHIFT Opcode: 00101010 Parameters: - Operation: Pops two values from the operand stack, performs a bitwise left-shift operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value, amount  =>  ..., value << amount Errors:  7 (Stack Underflow)  10.5.6.6 Instruction: B_RSSHIFT Opcode: 00101011 Parameters: - Operation: Pops two values from the operand stack, performs a bitwise signed right-shift operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value, amount  =>  ..., value >> amount Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 110(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.6.7 Instruction: B_RSZSHIFT Opcode: 00101100 Parameters: - Operation: Pops two values from the operand stack and performs a bitwise right-shift with zero operation on them and pushes the result back on the operand stack. Operands: Integers Conversion: 2 – Integer(s) Result:  Integer Operand stack: ..., value, amount  =>  ..., value >>> amount Errors:  7 (Stack Underflow)   10.5.7 Comparison Instructions 10.5.7.1 Instruction: EQ Opcode: 00101101 Parameters: - Operation: Pops two values from the operand stack, performs a logical equality operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 EQ value2 Errors:  7 (Stack Underflow)  10.5.7.2 Instruction: LE Opcode: 00101110 Parameters: - Operation: Pops two values from the operand stack, performs a logical less-or-equal operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 LE value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 111(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.7.3 Instruction: LT Opcode: 00101111 Parameters: - Operation: Pops two values from the operand stack, performs a logical less-than operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 LT value2 Errors:  7 (Stack Underflow)  10.5.7.4 Instruction: GE Opcode: 00110000 Parameters: - Operation: Pops two values from the operand stack, performs a logical greater-or-equal operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 GE value2 Errors:  7 (Stack Underflow)  10.5.7.5 Instruction: GT Opcode: 00110001 Parameters: - Operation: Pops two values from the operand stack, performs a greater-than operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 GT value2 Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 112(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.7.6 Instruction: NE Opcode: 00110010 Parameters: - Operation: Pops two values from the operand stack, performs a logical not-equal operation on them and pushes the result back on the operand stack. Operands: Integers, floating-points or strings Conversion: 7 – Integers, floating-points or strings Result:  Boolean Operand stack: ..., value1, value2  =>  ..., value1 NE value2 Errors:  7 (Stack Underflow)   10.5.8 Logical Instructions 10.5.8.1 Instruction: NOT Opcode: 00110011 Parameters: - Operation: Pops a value from the operand stack and performs a logical complement operation on it and pushes the result back on the operand stack. Operands: Boolean Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., !value Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 113(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.8.2 Instruction: SCAND Opcode: 00110100 Parameters: - Operation: Pops a value from the operand stack and converts it to a boolean value. If the converted value is false or invalid then the converted value itself is pushed on the operand stack and the boolean value false is pushed on the operand stack. If the converted value is true then the converted value itself is pushed on the operand stack. Operands: Any Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., false, false (in case the value is false) ..., value  =>  ..., true (in case the value is true) ..., value  =>  ..., invalid, false (in case the value is invalid) Errors:  7 (Stack Underflow)  10.5.8.3 Instruction: SCOR Opcode: 00110101 Parameters: - Operation: Pops a value from the operand stack and converts it to a boolean value. If the converted value is false then the boolean value true is pushed on the operand stack. If the converted value is true or invalid then the converted value itself is pushed on the operand stack and the boolean value false is pushed on the operand stack. Operands: Any Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., true (in case the value is false) ..., value  =>  ..., true, false (in case the value is true) ..., value  =>  ..., invalid, false (in case the value is invalid) Errors:  7 (Stack Underflow)     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 114(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.8.4 Instruction: TOBOOL Opcode: 00110110 Parameters: - Operation: Pops a value from the operand stack and converts the value to a boolean value and pushes the converted value on the operand stack. If the popped value is invalid then an invalid value is pushed back on the operand stack. Operands: Any Conversion: 1 – Boolean(s) Result:  Boolean Operand stack: ..., value  =>  ..., tobool Errors:  7 (Stack Underflow)   10.5.9 Stack Instructions 10.5.9.1 Instruction: POP Opcode: 00110111 Parameters: - Operation: Pops a value from the operand stack. Operands: Any Conversion: - Result:  - Operand stack: ..., value  =>  ... Errors:  7 (Stack Underflow)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 115(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.10 Access to Operand Type 10.5.10.1 Instruction: TYPEOF Opcode: 00111000 Parameters: - Operation: Pops a value from the operand stack and checks its type. Pushes the result as an integer on the operand stack. The possible results are: 0 = Integer, 1 = Floating-point, 2 = String, 3 = Boolean, 4 = Invalid Operands: Any Conversion: - Result:  Integer Operand stack: ..., value  =>  ..., typeof? Errors:  7 (Stack Underflow)  10.5.10.2 Instruction: ISVALID Opcode: 00111001 Parameters: - Operation: Pops a value from the operand stack and checks its type. If the type is invalid a boolean value false is pushed on the operand stack, otherwise a boolean value true is pushed on the operand stack. Operands: Any Conversion: - Result:  Boolean Operand stack: ..., value  =>  ..., valid? Errors:  7 (Stack Underflow)      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 116(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.11 Function Return Instructions 10.5.11.1 Instruction: RETURN Opcode: 00111010 Parameters: - Operation: Returns the control back to the caller. The return value is on the top of the operand stack. The execution continues at the next instruction following the function call of the calling function. Operands: Any Conversion: - Result:  - Operand stack: ..., ret-value  =>  ..., ret-value Errors:  7 (Stack Underflow)  10.5.11.2 Instruction: RETURN_ES Opcode: 00111011 Parameters: - Operation: Pushes an empty string on the operand stack and returns the control back to the caller. The execution continues at the next instruction following the function call of the calling function. Operands: - Conversion: - Result:  - Operand stack: ...  =>  ..., \"\" Errors:  -      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 117(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            10.5.12 Miscellaneous Instructions 10.5.12.1 Instruction: DEBUG Opcode: 00111100 Parameters: - Operation: No operation. Reserved for debugging and profiling purposes. Operands: - Conversion: - Result:  - Operand stack: No change Errors:  -      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 118(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             11. BYTECODE VERIFICATION Bytecode verification takes place before or while the bytecode is used for execution. The purpose of the verification is to make sure that the content follows the WMLScript bytecode specification. In case of verification failure, the failed bytecode should not be used for execution or the execution must be aborted and failure signalled to the caller of the WMLScript interpreter.  The following checks are to be executed in the WMLScript Interpreter either before the execution is started or during the execution of WMLScript bytecode.  11.1 Integrity Check The following list contains checks that must be used to verify the integrity of the WMLScript bytecode before it is executed:  • Check that the version number is correct: The bytecode version number must be compared with the bytecode version number supported by the WMLScript interpreter. The major version numbers must match. The minor version number of the bytecode must be less than or equal to the minor version number supported by the WMLScript interpreter.  • Check that the size of the bytecode is correct: The size specified in the bytecode must match exactly the byte size of the content.  • Check the constant pool: • The number of constants is correct: The number of constants specified in the constant pool must match the number of constants stored into the constant pool. • The types of constants are valid: The numbers used to specify the constant types in the constant pool must match the supported constant types. Reserved constant types (7-255) result in a verification failure. • The sizes of constants are valid: Each constant must allocate only the correct number of bytes specified by the WMLScript bytecode specification (fixed size constants such as integers) or the size parameter provided as part of the constant entity (constants of varying size such as strings).  • Check the pragma pool: • The number of pragmas is correct: The number of pragmas specified in the pragma pool must match the number of pragmas stored into the pragma pool. • The types of pragmas are valid: The numbers used to specify the pragma types in the pragma pool must match the supported pragma types. Reserved pragma types (4-255) result in a verification failure. • The constant pool indexes are valid: • The access control domain and path must point to string constants. • The constant pool indexes used in meta-information pragmas must point to string constants.  • Check the function pool: • The number of functions is correct: The number of functions specified in the function pool must match the number of functions stored into the function pool. • The function name table is correct:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 119(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            • The number of function names is correct: The number of function names specified in the function name table must match the number of function names stored into the function name table. • The function name indexes are correct: The indexes must point to existing functions in the function pool. • The function names contain only valid function name characters: Function names must follow the WMLScript function name syntax. • There is at least one name in the table. • The function prologue is correct: • The number of arguments and local variables is correct: The sum of the number of arguments and local variables must be less or equal to 256. • The size of the function is correct: The size specified in the function prologue must match exactly the byte size of the function.  11.2 Runtime Validity Checks The following list contains the checks that must be done during the execution to verify that the used instructions are valid and they use valid parameter values:  • Check that the bytecode contains only valid instructions: Only instructions that are defined in chapter 10 are valid. • Check that local variable references are valid: The references must be within the boundaries specified by the number of function local variables in the function prologue. • Check that constant references are valid: • The references must be within the boundaries specified by the number of constants in the constant pool. • The references must point to the valid constant types specified by each instruction: • In case of URL references, the referred constant strings must contain a valid URL (see [RFC2396]). • In case of Function Name references, the referred constant strings must contain a valid WMLScript function name. • Check that the standard library indexes and library function indexes are valid: The indexes must be within the boundaries specified by the WMLScript Standard Libraries specification [WMLSLibs]. • Check that local function call indexes are valid: The function indexes must match with the number of functions specified in the function pool. • Check that the jumps are within function boundaries: All jumps must have a target inside the function in which they are specified. • Check that the targets of jumps are valid: The target of all jumps must be the beginning of an instruction. • Check that the ends of the functions are valid: Functions must not end in the middle of an instruction.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 120(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             12. RUN-TIME ERROR DETECTION AND HANDLING Since WMLScript functions are used to implement services for users that expect the terminals (in particular mobile phones) to work properly in all situations, error handling is of utmost importance. This means that while the language does not provide, for example, an exception mechanism, it should provide tools to either prevent errors from happening or tools to notice them and take appropriate actions. Aborting a program execution should be the last resort used only in cases where nothing else is possible.  The following section lists errors that can happen when downloading bytecode and executing it. It does not contain programming errors (such as infinite loop etc.). For these cases a user controlled abortion mechanism is needed.   12.1 Error Detection The goal of error detection is to give tools for the programmer to detect errors (if possible) that would lead to erroneous behaviour. Since WMLScript is a weakly typed language, special functionality has been provided to detect errors that are caused by invalid data types :  • Check that the given variable contains the right value: WMLScript supports type validation library [WMLSLibs] functions such as Lang.isInt(), Lang.isFloat(), Lang.parseInt() and Lang.parseFloat(). • Check that the given variable contains a value that is of right type: WMLScript supports the operators typeof and isvalid that can be used for this purpose.   12.2 Error Handling Error handling takes place after an error has already happened. This is the case when the error could not be prevented by error detection (memory limits, external signals etc.) or it would have been too difficult to do so (overflow, underflow etc.). These cases can be divided into two classes:  • Fatal errors: These are errors that cause the program to abort. Since WMLScript functions are always called from some other user agents, program abortion should always be signalled to the calling user agent. It is then its responsibility to take the appropriate actions to signal the user of errors. • Non-fatal errors: These are errors that can be signalled back to the program as special return values and the program can decide on the appropriate action.  The following error descriptions are divided into sections based on their fatality.   12.3 Fatal Errors 12.3.1 Bytecode Errors These errors are related to the bytecode and the instructions being executed by the WMLScript Bytecode Interpreter. They are indications of erroneous constant pool elements, invalid instructions, invalid arguments to instructions or instructions that cannot be completed.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 121(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            12.3.1.1 Verification Failed Description: Reports that the specified bytecode for the called compilation unit did not pass the verification (see section 11 for more information about bytecode verification). Generated: At any time when a program attempts to call an external function. Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: Is detected during the bytecode verification. Solution: Abort program and signal an error to the caller of the WMLScript interpreter. 12.3.1.2 Fatal Library Function Error Description: Reports that a call to a library function resulted in a fatal error. Generated: At any time when a call to a library function is used (CALL_LIB). Typically, this is an unexpected error in the library function implementation. Example: var a = String.format(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.3 Invalid Function Arguments Description: Reports that the number of arguments specified for a function call do not match with the number of arguments specified in the called function. Generated: At any time a call to an external function is used (CALL_URL). Example: Compiler generates an invalid parameter to an instruction or the number of parameters in the called function has changed. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.4 External Function Not Found Description: Reports that a call to an external function could not be found from the specified compilation unit. Generated: At any time, when a program attempts to call an external function (CALL_URL). Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 122(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            12.3.1.5 Unable to Load Compilation Unit Description: Reports that the specified compilation unit could not be loaded due to unrecoverable errors in accessing the compilation unit in the network server or the specified compilation unit does not exist in the network server. Generated: At any time, when a program attempts to call an external function (CALL_URL). Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.6 Access Violation Description: Reports an access violation. The called external function resides in a protected compilation unit. Generated: At any time when a program attempts to call an external function (CALL_URL). Example: var a = 3*OtherScript#doThis(param); Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.1.7 Stack Underflow Description: Indicates a stack underflow because of a program error (compiler generated bad code). Generated: At any time when a program attempts to pop an empty stack. Example: Only generated if compiler generates bad code. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.   12.3.2 Program Specified Abortion This error is generated when a WMLScript function calls the library function Lang.abort() (see [WMLSLibs]) to abort the execution.  12.3.2.1 Programmed Abort Description: Reports that the execution of the bytecode was aborted by a call to Lang.abort() function. Generated: At any time when a program makes a cal to Lang.abort() function.. Example: Lang.abort(\"Unrecoverable error\"); Severity: Fatal. Predictable: No.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 123(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Solution: Abort program and signal an error to the caller of the WMLScript interpreter.   12.3.3 Memory Exhaustion Errors These errors are related to the dynamic behaviour of the WMLScript interpreter (see section 8.1 for more information) and its memory usage.  12.3.3.1 Stack Overflow Description: Indicates a stack overflow. Generated: At any time when a program recourses too deep or attempts to push too many variables onto the operand stack. Example: function f(x) { f(x+1); }; Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.3.3.2 Out of Memory Description: Indicates that no more memory resources are available to the interpreter. Generated: At any time when the operating system fails to allocate more space for the interpreter. Example: function f(x) {   x=x+”abcdefghijklmnopqrstuvzyxy”;   f(x); }; Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.   12.3.4 External Exceptions The following exceptions are initiated outside of the WMLScript Bytecode Interpreter.  12.3.4.1 User Initiated Description: Indicates that the user wants to abort the execution of the program (reset button etc.) Generated: At any time. Example: User presses reset button while an application is running. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 124(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            12.3.4.2 System Initiated Description: Indicates that an external fatal exception occurred while a program is running and it must be aborted. Exceptions can be originated from a low battery, power off, etc. Generated: At any time. Example: The system is automatically switching off due to a low battery. Severity: Fatal. Predictable: No. Solution: Abort program and signal an error to the caller of the WMLScript interpreter.  12.4 Non-Fatal Errors 12.4.1 Computational Errors These errors are related to arithmetic operations supported by the WMLScript.  12.4.1.1 Divide by Zero Description: Indicates a division by zero. Generated: At any time when a program attempts to divide by 0 (integer or floating-point division or remainder). Example: var a = 10; var b = 0; var x = a / b; var y = a div b; var z = a % b; a /= b; Severity: Non-fatal. Predictable: Yes. Solution: The result is an invalid value.  12.4.1.2 Integer Overflow Description: Reports an arithmetic integer overflow. Generated: At any time when a program attempts to execute an integer operation. Example: var a = Lang.maxInt(); var b = Lang.maxInt(); var c = a + b; Severity: Non-fatal. Predictable: Yes (but difficult in certain cases). Solution: The result is an invalid value.  12.4.1.3 Floating-Point Overflow Description: Reports an arithmetic floating-point overflow. Generated: At any time when a program attempts to execute a floating-point operation.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 125(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Example: var a = 1.6e308; var b = 1.6e308; var c = a * b; Severity: Non-fatal. Predictable: Yes (but difficult in certain cases). Solution: The result is an invalid value.  12.4.1.4 Floating-Point Underflow Description: Reports an arithmetic underflow. Generated: At any time when the result of a floating-point operation is smaller than what can be represented. Example: var a = Float.precision(); var b = Float.precision(); var c = a * b; Severity: Non-fatal. Predictable: Yes (but difficult in certain cases). Solution: The result is a floating-point value 0.0.   12.4.2 Constant Reference Errors These errors are related to run-time references to constants in the constant pool.  12.4.2.1 Not a Number Floating-Point Constant Description: Reports a reference to a floating-point literal in the constant pool that is Not a Number [IEEE754]. Generated: At any time when a program attempts to access a floating-point literal and the compiler has generated a Not a Number as a floating-point constant. Example: A reference to a floating-point literal. Severity: Non-fatal. Predictable: Yes. Solution: The result is an invalid value.  12.4.2.2 Infinite Floating-Point Constant Description: Reports a reference to a floating-point literal in the constant pool that is either positive or negative infinity [IEEE754]. Generated: At any time when a program attempts to access a floating-point literal and the compiler has generated a floating-point constant with a value of positive or negative infinity. Example: A reference to a floating-point literal. Severity: Non-fatal. Predictable: Yes. Solution: The result is an invalid value.  12.4.2.3 Illegal Floating-Point Reference Description: Reports an erroneous reference to a floating-point value in the constant pool.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 126(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Generated: At any time when a program attempts to use floating-point values and the environments supports only integer values. Example: var a = 3.14; Severity: Non-fatal. Predictable: Can be detected during the run-time. Solution: The result is an invalid value.   12.4.3 Conversion Errors These errors are related to automatic conversions supported by the WMLScript.  12.4.3.1 Integer Too Large Description: Indicates a conversion to an integer value where the integer value is too large (positive/negative). Generated: At any time when an application attempts to make an automatic conversion to an integer value. Example: var a = -\"999999999999999999999999999999999999999999\"; Severity: Non-fatal. Predictable: No. Solution: The result is an invalid value.  12.4.3.2 Floating-Point Too Large Description: Indicates a conversion to a floating-point value where the floating-point value is too large (positive/negative). Generated: At any time when an application attempts to make an automatic conversion to a floating-point value. Example: var a = -\"9999999.9999999999e99999\"; Severity: Non-fatal. Predictable: No. Solution: The result is an invalid value.  12.4.3.3 Floating-Point Too Small Description: Indicates a conversion to a floating-point value where the floating-point value is too small (positive/negative). Generated: At any time when an application attempts to make an automatic conversion to a floating-point value. Example: var a = -\"0.01e-99\"; Severity: Non-fatal. Predictable: No. Solution: The result is a floating-point value 0.0.   12.5 Library Calls and Errors Since WMLScript supports the usage of libraries, there is a possibility that errors take place inside the library functions. Design and the behaviour of the library functions are not part of the WMLScript language specification. However, following guidelines should be followed when designing libraries:    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 127(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             • Provide the library users mechanisms by which errors can be detected before they happen. • Use the same error handling mechanisms as WMLScript operators in cases where error should be reported back to the caller. • Minimise the possibility of fatal errors in all library functions.    © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 128(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             13. SUPPORT FOR INTEGER ONLY DEVICES The WMLScript language has been designed to run also on devices that do not support floating-point operations. The following rules apply when WMLScript is used with such devices:  • Variables can only contain the following internal data types: • Boolean • Integer • String • Invalid • Any LOAD_CONST bytecode that refers to a floating point constant in the constant pool will push an invalid value on the operand stack instead of the constant value. • Division (/) operation returns always an invalid value. • Assignment with division (/=) operation always results in an invalid value. • All conversion rules related to floating-points are ignored. • URL call with a floating-point value as an argument results in a failure to execute the call due to an invalid URL syntax.  The programmer can use Lang.float() [WMLSLibs] to test (during the run-time) if floating-point operations are supported.      © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 129(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             14. CONTENT TYPES The content types specified for WMLScript compilation unit and its textual and binary encoding are:  • Textual form: text/vnd.wap.wmlscript • Binary form: application/vnd.wap.wmlscriptc     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 130(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             15. STATIC CONFORMANCE REQUIREMENTS  This static conformance clause defines a minimum set of features that can be implemented to ensure that WMLScript encoders and interpreters will be able to inter-operate. While both interpreter behavior and encoder behavior is described in the WMLScript specification, not all items apply to both entities, so there are separate tables for each. A feature can be optional or mandatory.   15.1 Encoder   15.1.1 Core Capabilities   Item Function Reference Status Requirement WMLS-S-001 Support for both Floating point capable and Integer only devices Support for Integer Only Devices M  WMLS-S-002 WMLScript Standard Libraries [WMLSLibs] M    15.1.2 WMLScript Language Core  Item Function Reference Status Requirement WMLS-S-003 Language is case-sensitive Case Sensitivity  M  WMLS-S-004 Ignore extra white space and line break between program tokens Whitespace and Line Breaks  M  WMLS-S-005 Semicolon is used to terminate certain statements Usage of Semicolons  M  WMLS-S-006 Multi-line and single-line comments Comments  M  WMLS-S-007 Disallows nested comments  Comments  M  WMLS-S-008 Integer literals Integer Literals  M  WMLS-S-009 Floating point literals Floating-Point Literals  M  WMLS-S-010 String literals, single and double quoted String Literals  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 131(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Item Function Reference Status Requirement WMLS-S-011 Special escape sequences String Literals  M  WMLS-S-012 Boolean literals Boolean Literals  M  WMLS-S-013 Invalid literal Invalid Literal  M  WMLS-S-014 Identifier syntax Identifiers  M  WMLS-S-015 Variable scope and lifetime Variable Scope and Lifetime  M  WMLS-S-016 Integer size Integer Size  M  WMLS-S-017 Floating point size Floating-point Size  M  WMLS-S-018 Assignment operators Assignment Operators  M  WMLS-S-019 Arithmetic operators Arithmetic Operators  M  WMLS-S-020 Logical operators Logical Operators  M  WMLS-S-021 String operators String Operators  M  WMLS-S-022 Comparison operators Comparison Operators  M  WMLS-S-023 Array operators Array Operators  M  WMLS-S-024 Comma operator Comma Operator  M  WMLS-S-025 Conditional operator Conditional Operator  M  WMLS-S-026 typeof operator typeof Operator  M  WMLS-S-027 isvalid operator isvalid Operator M  WMLS-S-028 Expression bindings Expression Bindings  M  WMLS-S-029 Function declaration 1Declaration  M  WMLS-S-030 Local script functions calls Local Script Functions  M  WMLS-S-031 External function calls External Functions  M  WMLS-S-032 Library function calls Library Functions  M  WMLS-S-033 Default function return value Default Return Value  M  WMLS-S-034 Empty statement Empty Statement  M  WMLS-S-035 Block statement Block Statement  M  WMLS-S-036 Variable statement Variable Statement  M  WMLS-S-037 if statement If Statement  M  WMLS-S-038 while statement While Statement  M  WMLS-S-039 for statement For Statement  M  WMLS-S-040 break statement Break Statement  M  WMLS-S-041 continue statement Continue Statement  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 132(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Item Function Reference Status Requirement WMLS-S-042 return statement Return Statement  M  WMLS-S-043 External compilation unit pragma External Compilation Units  M  WMLS-S-044 Access control pragma Access Control  M  WMLS-S-045 Meta information pragma Meta-Information M    15.1.3 Function Calls  Item Function Reference Status Requirement WMLS-S-046 Function argument passing Passing of Function Arguments  M  WMLS-S-047 Allocation of variable indexes Allocation of Variable Indexes  M  WMLS-S-048 Automatic function return value Automatic Function Return Value  M  WMLS-S-049 Variable initialization Initialisation of Variables M    15.1.4 Binary Format  Item Function Reference Status Requirement WMLS-S-050 Binary format data types Used Data Types  M  WMLS-S-051 Multi-byte integer format Multi-byte Integer Format  M  WMLS-S-052 Character encoding Character Encoding  M  WMLS-S-053 Header Info Bytecode Header  M  WMLS-S-054 Constant Pool Constant Pool  M  WMLS-S-055 Pragma Pool  Pragma Pool  M  WMLS-S-056 Function Pool Function Pool M    15.1.5 Instruction Set  Item Function Reference Encoder Status Requirement WMLS-S-057 Control flow instructions Control Flow Instructions  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 133(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Item Function Reference Encoder Status Requirement Instructions  WMLS-S-058 Function call instructions Function Call Instructions  M  WMLS-S-059 Variable access and manipulation Variable Access and Manipulation  M  WMLS-S-060 Access to constants Access To Constants  M  WMLS-S-061 Arithmetic instructions Arithmetic Instructions  M  WMLS-S-062 Bitwise instructions Bitwise Instructions  M  WMLS-S-063 Comparison instructions Comparison Instructions  M  WMLS-S-064 Logical instructions Logical Instructions  M  WMLS-S-065 Stack instructions Stack Instructions  M  WMLS-S-066 Access to operand type Access to Operand Type  M  WMLS-S-067 Return instructions Function Return Instructions  M  WMLS-S-068 Debug instruction Miscellaneous Instructions O       © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 134(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                             15.2 Interpreter   15.2.1 Core Capabilities   Item Function Reference Status Requirement WMLS-C-069 Support for interpreting WMLScript bytecode WMLScript Bytecode Interpreter M  WMLS-C-070 WMLScript Standard Libraries [WMLSLibs] M    15.2.2 Automatic Data Conversion  Item Function Reference Status Requirement WMLS-C-071 Floating point size Floating-point Size  O  WMLS-C-072 Conversions to String Conversions to String  M  WMLS-C-073 Conversions to Integer Conversions to Integer  M  WMLS-C-074 Conversions to Floating Point Conversions to Floating-Point  O  WMLS-C-075 Conversions to Boolean Conversions to Boolean  M  WMLS-C-076 Conversions to Invalid Conversions to Invalid  M  WMLS-C-077 Operator data type conversion rules Operator Data Type Conversion Rules M    15.2.3 Function Calls  Item Function Reference Status Requirement WMLS-C-078 URL schemes URL Schemes  M  WMLS-C-079 Fragment anchor Fragment Anchors  M  WMLS-C-080 URL call syntax URL Call Syntax  M  WMLS-C-081 URL call parameter passing URL Calls and Parameter Passing  M  WMLS-C-082 Support for relative URLs Relative URLs  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 135(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Item Function Reference Status Requirement WMLS-C-083 Function argument passing Passing of Function Arguments  M  WMLS-C-084 Allocation of variable indexes Allocation of Variable Indexes  M  WMLS-C-085 Automatic function return value Automatic Function Return Value  M  WMLS-C-086 Variable initialization Initialisation of Variables  M  WMLS-C-087 Access control Access Control M    15.2.4 Binary Format  Item Function Reference Status Requirement WMLS-C-088 Binary format data types Used Data Types  M  WMLS-C-089 Multi-byte integer format Multi-byte Integer Format  M  WMLS-C-090 Character encoding Character Encoding  M  WMLS-C-091 Header Info Bytecode Header  M  WMLS-C-092 Constant Pool Constant Pool  M  WMLS-C-093 Pragma Pool  Pragma Pool  M  WMLS-C-094 Function Pool Function Pool M    15.2.5 Instruction Set  Item Function Reference Status Requirement WMLS-C-095 Control flow instructions Control Flow Instructions  M  WMLS-C-096 Function call instructions Function Call Instructions  M  WMLS-C-097 Variable access and manipulation Variable Access and Manipulation  M  WMLS-C-098 Access to constants Access To Constants  M  WMLS-C-099 Arithmetic instructions Arithmetic Instructions  M  WMLS-C-100 Bitwise instructions Bitwise Instructions  M  WMLS-C-101 Comparison instructions Comparison Instructions  M     © Wireless Application Protocol Forum, Ltd, 2000,2001 All rights reserved. Page 136(136)WAP-193_101-WMLS-20010928-a, version 28-Sept-2001                                            Item Function Reference Status Requirement WMLS-C-102 Logical instructions Logical Instructions  M  WMLS-C-103 Stack instructions Stack Instructions  M  WMLS-C-104 Access to operand type Access to Operand Type  M  WMLS-C-105 Return instructions Function Return Instructions  M  WMLS-C-106 Debug instruction Miscellaneous Instructions M    15.2.6 Error Handling  Item Function Reference Status Requirement WMLS-C-107 Bytecode verification Integrity Check  M  WMLS-C-108 Runtime validity checking Runtime Validity Checks  M  WMLS-C-109 Support for general error handling Error Handling  M  WMLS-C-110 Handling of fatal errors Fatal Errors  M  WMLS-C-111 Handling of non-fatal errors Non-Fatal Errors M    15.2.7 Support for Floating Point Devices  Item Function Reference Status Requirement WMLS-C-112 Support for floating-point operations Support for Integer Only Devices O WMLS-C-17 AND WMLS-C-73"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-194-WMLScriptLibraries-20000925-a.pdf","file":"WAP-194-WMLScriptLibraries-20000925-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry-wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a set of standards to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers. For additional information on the WAP architecture, refer to Wireless Application Protocol Architecture Specification [WAP].  This document specifies the library interfaces for the standard set of libraries supported by WMLScript [WMLScript] to provide access to the core functionality of a WAP client. WMLScript is a language that can be used to provide programmed functionality to WAP based applications. It is part of the WAP platform and it can be used to add script support also to the client.  One of the main differences between ECMAScript [ECMA262] and WMLScript is the fact that WMLScript is compiled into bytecode before it is being sent to the client. This way the narrowband communication channels available today can be optimally utilized and the memory requirements for the client kept to the minimum. For the same reasons, many of the advanced features of the JavaScript language have been removed to make the language both optimal, easier to compile into bytecode and easier to learn.  Library support has been added to the WMLScript to replace some of the functionality that has been removed from ECMAScript in accordance to make the WMLScript more efficient. This feature provides access to built-in functionality and a means for future expansion without unnecessary overhead.  The following chapters describe the set of libraries defined to provide access to core functionality of a WAP client. This means that all libraries, except Float, are present in the client's scripting environment. Float library is optional and only supported with clients that can support floating-point arithmetic operations.        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 6(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 2.  DOCUMENT STATUS This document is available online in the following formats:  • PDF format at http://www.wapforum.org/.   2.1  Copyright Notice © Wireless Application Protocol Forum Ltd. 2000. Terms and conditions of use are available from the Wireless Application Protocol Forum Ltd. web site (http://www.wapforum.org/docs/copyright.htm).   2.2  Errata Known problems associated with this document are published at http://www.wapforum.org/.   2.3  Comments Comments regarding this document can be submitted to the WAP Forum in the manner published at http://www.wapforum.org/.  2.4 Document Changes   2.4.1  WAP-194.100  15-May-2000 Change Request Title Comments WMLSL-IBM-20000320-SeedSequence Lang.seed Example Section 7.14 WMLSL-IBM-20000315-FormatConversion String Format Conversions Section9.16 WMLSL-IBM-20000315-CancelNav WMLBrowser – Canceling Navigation Sections11.3and11.4 WMLSL-IBM-20000308-PowExample Correct Floating Point Example Section 8.4 WMLSL-IBM-20000308-AbortText Description of Lang.abort() Section 7.12 WMLSL-IBM-20000218-v2-seed Lang.seed() – Non-numeric Input Section 7.14       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 7(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 2.4.2 WAP-194.101 25-Sept-2000 Change Request Title Comments WMLSL-IBM-20000803-LoadString Clarification on the return from loadString(). It returns the content type \"text\". Section 10.14 WMLSL-IBM-20000810-NewContext Clarification of effect of newContext() call on go() and prev(). Section11.5 New Static Conformance Format Added Inter-specification dependency Column Section 12.4  2.5 Document History Document Name Date of Release WAP-194-WMLSL-20000925 Approved Re-release (rolled up)  WAP-194.101-WMLSL-20000925 SCD 09-Sept-2000 WAP-194-WMLScriptLibraries  (Approved) June-2000 WAP-194.100-WMLScriptLibraries 15-May-2000 SPEC-WMLScriptLibs-v1_2 24-March-2000 SPEC-WMLScriptLibs-19990815 15-August-1999       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 8(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 3. REFERENCES  3.1  Normative references  [ECMA262] Standard ECMA-262: \"ECMAScript Language Specification\", ECMA, June 1997 [IEEE754] ANSI/IEEE Std 754-1985: \"IEEE Standard for Binary Floating-Point Arithmetic\". Institute of Electrical and Electronics Engineers, New York (1985). [RFC2119] \"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March 1997. URL: ftp://ftp.isi.edu/in-notes/rfc2119.tx [RFC2396] \"Uniform Resource Identifiers (URI): Generic Syntax\", T. Berners-Lee, et al., August 1998. URL: http://info.internet.isi.edu/in-notes/rfc/files/rfc2396.txt [UNICODE] \"The Unicode Standard: Version 2.0\", The Unicode Consortium, Addison-Wesley Developers Press, 1996. URL: http://www.unicode.org/ [WAP] \"Wireless Application Protocol Architecture Specification\", WAP Forum, 30-April-1998. URL: http://www.wapforum.org/ [WML] \"Wireless Markup Language Specification\", WAP Forum, 04-November-1999. URL: http://www.wapforum.org/ [WMLScript] \"WAP-193-WMLScript Language Specification\", WAP Forum, 24-March-2000. URL: http://www.wapforum.org/ [WSP] \"Wireless Session Protocol\", WAP Forum, 05-November-1999. URL: http://www.wapforum.org/  3.2  Informative References  [JavaScript] \"JavaScript: The Definitive Guide\", David Flanagan. O'Reilly & Associates, Inc. 1997 [RFC2068] \"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, et al., January 1997.  URL: ftp://ftp.isi.edu/in-notes/rfc2068.txt [WAE] \"Wireless Application Environment Specification\", WAP Forum, 04-November-1999. URL: http://www.wapforum.org/ [XML] \"Extensible Markup Language (XML), W3C Proposed Recommendation 10-February-1998, REC-xml-19980210\", T. Bray, et al, February 10, 1998.  URL: http://www.w3.org/TR/REC-xml       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 9(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 4.  DEFINITIONS AND ABBREVIATIONS  4.1 Definitions The following are terms and conventions used throughout this specification.  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",  \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\" and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119]. ]. In the absence of any such terms, the specification should be interpreted as \"MUST\".  Bytecode - content encoding where the content is typically a set of low-level opcodes (i.e., instructions) and operands for a targeted hardware (or virtual) machine.  Client - a device (or application) that initiates a request for connection with a server.  Content - subject matter (data) stored or generated at an origin server.  Content is typically displayed or interpreted by a user agent in response to a user request.  Content Encoding - when used as a verb, content encoding indicates the act of converting a data object from one format to another.  Typically the resulting format requires less physical space than the original, is easier to process or store and/or is encrypted.  When used as a noun, content encoding specifies a particular format or encoding standard or process.  Content Format – actual representation of content.  Device - a network entity that is capable of sending and receiving packets of information and has a unique device address.  A device can act as either a client or a server within a given context or across multiple contexts.  For example, a device can service a number of clients (as a server) while being a client to another server.  JavaScript - a de facto standard language that can be used to add dynamic behaviour to HTML documents.  JavaScript is one of the originating technologies of ECMAScript.  Origin Server - the server on which a given resource resides or is to be created.  Often referred to as a web server or an HTTP server.  Resource - a network data object or service that can be identified by a URL.  Resources may be available in multiple representations (e.g. multiple languages, data formats, size and resolutions) or vary in other ways.  Server - a device (or application) that passively waits for connection requests from one or more clients.  A server may accept or reject a connection request from a client.  User - a user is a person who interacts with a user agent to view, hear or otherwise use a rendered content.        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 10(58)WAP-194-20000925-a                                                                                      25-SEP-2000                User Agent - a user agent (or content interpreter) is any software or device that interprets WML, WMLScript or resources.  This may include textual browsers, voice browsers, search engines, etc.  Web Server - a network host that acts as an HTTP server.  WML - the Wireless Markup Language is a hypertext markup language used to represent information for delivery to a narrowband device, e.g. a phone.  WMLScript - a scripting language used to program the mobile device.  WMLScript is an extended subset of the JavaScript scripting language.   4.2  Abbreviations For the purposes of this specification, the following abbreviations apply:  API Application Programming Interface ECMA European Computer Manufacturer Association HTTP HyperText Transfer Protocol [RFC2068] LSB Least Significant Bits MSB Most Significant Bits RFC Request For Comments UI User Interface URL Uniform Resource Locator [RFC2396] W3C World Wide Web Consortium WWW World Wide Web WSP Wireless Session Protocol WTP Wireless Transport Protocol WAP Wireless Application Protocol WAE Wireless Application Environment WTA Wireless Telephony Applications WTAI Wireless Telephony Applications Interface WBMP Wireless BitMaP        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 11(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 5. NOTATIONAL CONVENTIONS The libraries in this document are represented by providing the following information:  NAME: Library name. The syntax of the library name follows the syntax specified in the [WMLScript] specification. Library names are case sensitive. Examples: Lang, String LIBRARY ID: The numeric identifier reserved for the library to be used by the WMLScript Compiler. The range of values reserved for this identifier is divided into the following two categories:  0 .. 32767 Reserved for standard libraries.  32768 .. 65535 Reserved for future use. DESCRIPTION: A short description of the library and used conventions.  Each function in the library is represented by providing the following information:  FUNCTION: Specifies the function name and the number of function parameters. The syntax of the function name follows the syntax specified in the [WMLScript] specification. Function names are case sensitive. Example: abs(value) Usage: var a = 3*Lang.abs(length); FUNCTION ID: The numeric identifier reserved for the function to be used by the WMLScript Compiler. The range of values reserved for this identifier is: 0..255. DESCRIPTION: Describes the function behaviour and its parameters. PARAMETERS: Specifies the function parameter types. Example: value = Number RETURN VALUE: Specifies the type(s) of the return value. Example: String or invalid. EXCEPTIONS: Describes the possible special exceptions and error codes and the corresponding return values. Standard errors, common to all functions, are not described here (see 6.3 for more information about error handling). Example: If the value1 <= 0 and value2 < 0 and not an integer then invalid is returned. EXAMPLE: Gives a few examples of how the function could be used.    var a = -3;   var b = Lang.abs(a);  // b = 3       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 12(58)WAP-194-20000925-a                                                                                      25-SEP-2000                       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 13(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 6. WMLSCRIPT COMPLIANCE WMLScript standard library functions provide a mechanism to extend the WMLScript language. Thus, the specified library functions must follow the WMLScript conventions and rules.  6.1 Supported Data Type The following WMLScript types [WMLScript] are used in the function definitions to denote the type of both the function parameters and return values:  • Boolean, Integer, Float, String and Invalid  In addition to these, number can be used to denote a parameter type when both integer and floating-point parameter value types are accepted. Any can be used when the type can be any of the supported types.  6.2  Data Type Conversions Since WMLScript is a weakly typed language, the conversions between the data types are done automatically if necessary (see [WMLScript] for more details about data type conversion rules). The library functions follow WMLScript operator data type conversion rules except where explicitly stated otherwise.  6.3  Error Handling Error cases are handled in the same way as in the WMLScript language (see [WMLScript] for more details):  • An invalid function argument results in an invalid return value with no other side effects unless explicitly stated otherwise. • A function argument that cannot be converted to the required parameter type results in an invalid return value with no side effects. See 6.2 for more information about data type conversions. • Function dependent error cases are handled by returning a suitable error code specified in each function definition. These errors are documented as part of the function specification (exceptions).  6.4  Support for Integer-Only Devices The WMLScript language has been designed to run also on devices that do not support floating-point operations. The WMLScript standard libraries have operations that require floating-point support. Thus, the following rules apply when the libraries are implemented for an integer-only device:  • Library functions accept arguments of the following type only: boolean, integer, string and invalid. • All conversion rules related to floating-point data are ignored. • Lang.float() function returns false. • Lang.parseFloat() function returns invalid.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 14(58)WAP-194-20000925-a                                                                                      25-SEP-2000                • String.format() function returns invalid when type f is specified in the format. • All Float (see chapter 8) library functions return invalid.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 15(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 7.  LANG NAME: Lang LIBRARY ID: 0 DESCRIPTION: This library contains a set of functions that are closely related to the WMLScript language core.  7.1  abs FUNCTION: abs(value) FUNCTION ID: 0 DESCRIPTION: Returns the absolute value of the given number. If the given number is of type integer then an integer value is returned. If the given number is of type floating-point then a floating-point value is returned. PARAMETERS: value = Number RETURN VALUE: Number or invalid. EXCEPTIONS: - EXAMPLE: var a = -3; var b = Lang.abs(a);  // b = 3  7.2  min FUNCTION: min(value1, value2) FUNCTION ID: 1 DESCRIPTION: Returns the minimum value of the given two numbers. The value and type returned is the same as the value and type of the selected number. The selection is done in the following way: - WMLScript operator data type conversion rules for integers and floating-points (see [WMLScript]) must be used to specify the data type (integer or floating-point ) for comparison. - Compare the numbers to select the smaller one. - If the values are equal then the first value is selected. PARAMETERS: value1 = Number value2 = Number RETURN VALUE: Number or invalid. EXCEPTIONS: -       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 16(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXAMPLE: var a = -3; var b = Lang.abs(a); var c = Lang.min(a,b);      // c = -3 var d = Lang.min(45, 76.3); // d = 45 (integer) var e = Lang.min(45, 45.0); // e = 45 (integer)  7.3  max FUNCTION: max(value1, value2) FUNCTION ID: 2 DESCRIPTION: Returns the maximum value of the given two numbers. The value and type returned is the same as the value and type of the selected number. The selection is done in the following way: - WMLScript operator data type conversion rules for integers and floating-points (see [WMLScript]) must be used to specify the data type (integer or floating-point ) for comparison. - Compare the numbers to select the larger one. - If the values are equal then the first value is selected. PARAMETERS: value1 = Number value2 = Number RETURN VALUE: Number or invalid. EXCEPTIONS: - EXAMPLE: var a = -3; var b = Lang.abs(a); var c = Lang.max(a,b);      // c = 3 var d = Lang.max(45.5, 76); // d = 76 (integer) var e = Lang.max(45.0, 45); // e = 45.0 (float)   7.4  parseInt FUNCTION: parseInt(value) FUNCTION ID: 3 DESCRIPTION: Returns an integer value defined by the string value. The legal integer syntax is specified by the WMLScript (see [WMLScript]) numeric string grammar for decimal integer literals with the following additional parsing rule: - Parsing ends when the first character is encountered that is not a leading '+' or '-' or a decimal digit. The result is the parsed string converted to an integer value. PARAMETERS: value = String       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 17(58)WAP-194-20000925-a                                                                                      25-SEP-2000                RETURN VALUE: Integer or invalid. EXCEPTIONS: In case of a parsing error an invalid value is returned. EXAMPLE: var i = Lang.parseInt(\"1234\");      // i = 1234 var j = Lang.parseInt(\" 100 m/s\");  // j = 100  7.5  parseFloat FUNCTION: parseFloat(value) FUNCTION ID: 4 DESCRIPTION: Returns a floating-point value defined by the string value. The legal floating-point syntax is specified by the WMLScript (see [WMLScript]) numeric string grammar for decimal floating-point literals with the following additional parsing rule: - Parsing ends when the first character is encountered that cannot be parsed as being part of the floating-point representation. The result is the parsed string converted to a floating-point value. PARAMETERS: value = String RETURN VALUE: Floating-point or invalid. EXCEPTIONS: In case of a parsing error an invalid value is returned. If the system does not support floating-point operations then an invalid value is returned. EXAMPLE: var a = Lang.parseFloat(\"123.7\");         // a = 123.7 var b = Lang.parseFloat(\"  +7.34e2 Hz\");  // b = 7.34e2 var c = Lang.parseFloat(\" 70e-2 F\");      // c = 70.0e-2 var d = Lang.parseFloat(\"-.1 C\");         // d = -0.1 var e = Lang.parseFloat(\" 100 \");         // e = 100.0 var f = Lang.parseFloat(\"Number: 5.5\");   // f = invalid var g = Lang.parseFloat(\"7.3e meters\");   // g = invalid var h = Lang.parseFloat(\"7.3e- m/s\");     // h = invalid  7.6  isInt FUNCTION: isInt(value) FUNCTION ID: 5 DESCRIPTION: Returns a boolean value that is true if the given value can be converted into an integer number by using parseInt(value). Otherwise false is returned. PARAMETERS: value = Any RETURN VALUE: Boolean or invalid.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 18(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXCEPTIONS: - EXAMPLE: var a = Lang.isInt(\" -123\");   // true var b = Lang.isInt(\" 123.33\"); // true var c = Lang.isInt(\"string\");  // false var d = Lang.isInt(\"#123\");    // false var e = Lang.isInt(invalid);   // invalid  7.7  isFloat FUNCTION: isFloat(value) FUNCTION ID: 6 DESCRIPTION: Returns a boolean value that is true if the given value can be converted into a floating-point number using parseFloat(value). Otherwise false is returned. PARAMETERS: value = Any RETURN VALUE: Boolean or invalid. EXCEPTIONS: If the system does not support floating-point operations then an invalid value is returned. EXAMPLE: var a = Lang.isFloat(\" -123\");   // true var b = Lang.isFloat(\" 123.33\"); // true var c = Lang.isFloat(\"string\");  // false var d = Lang.isFloat(\"#123.33\"); // false var e = Lang.isFloat(invalid);   // invalid  7.8  maxInt FUNCTION: maxInt() FUNCTION ID: 7 DESCRIPTION: Returns the maximum integer value. PARAMETERS: - RETURN VALUE: Integer 2147483647. EXCEPTIONS: - EXAMPLE: var a = Lang.maxInt();  7.9  minInt FUNCTION: minInt() FUNCTION ID: 8       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 19(58)WAP-194-20000925-a                                                                                      25-SEP-2000                DESCRIPTION: Returns the minimum integer value. PARAMETERS: - RETURN VALUE: Integer –2147483648. EXCEPTIONS: - EXAMPLE: var a = Lang.minInt();  7.10  float FUNCTION: float() FUNCTION ID: 9 DESCRIPTION: Returns true if floating-points are supported and false if not. PARAMETERS: - RETURN VALUE: Boolean. EXCEPTIONS: - EXAMPLE: var floatsSupported = Lang.float();  7.11  exit FUNCTION: exit(value) FUNCTION ID: 10 DESCRIPTION: Ends the interpretation of the WMLScript bytecode and returns the control back to the caller of the WMLScript interpreter with the given return value. This function can be used to perform a normal exit from a function in cases where the execution of the WMLScript bytecode should be discontinued. PARAMETERS: value = Any RETURN VALUE: None (this function ends the interpretation). EXCEPTIONS: - EXAMPLE: Lang.exit(\"Value: \" + myVal); // Returns a string Lang.exit(invalid);           // Returns invalid  7.12  abort FUNCTION: abort(errorDescription) FUNCTION ID: 11       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 20(58)WAP-194-20000925-a                                                                                      25-SEP-2000                DESCRIPTION: Aborts the interpretation of the WMLScript bytecode and returns the control back to the caller of the WMLScript interpreter with the return errorDescription. This function can be used to perform an abnormal exit in cases where the execution of the WMLScript should be discontinued due to serious errors detected by the program. If the type of the errorDescription is invalid, string \"invalid\" is used as the errorDescription instead. PARAMETERS: errorDescription = String RETURN VALUE: None (this function aborts the interpretation). EXCEPTIONS: - EXAMPLE: Lang.abort(\"Error: \" + errVal);  // Error value is a string  7.13  random FUNCTION: random(value) FUNCTION ID: 12 DESCRIPTION: Returns an integer value with positive sign that is greater than or equal to 0 but less than or equal to the given value. The return value is chosen randomly or pseudo-randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. If the value is of type floating-point, Float.int() is first used to calculate the actual integer value. PARAMETERS: value = Number RETURN VALUE: Integer or invalid. EXCEPTIONS: If value is equal to zero (0), the function returns zero. If value is less than zero (0), the function returns invalid. EXAMPLE: var a = 10; var b = Lang.random(5.1)*a;    // b = 0..50 var c = Lang.random(\"string\"); // c = invalid  7.14  seed FUNCTION: seed(value) FUNCTION ID: 13       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 21(58)WAP-194-20000925-a                                                                                      25-SEP-2000                DESCRIPTION: Initialises the pseudo-random number sequence and returns an empty string. If the value is zero or a positive integer then the given value is used for initialisation, otherwise a random, system dependent initialisation value is used. A seed value of greater than or equal to zero results in a repeatable sequence of pseudo-random numbers. A seed value of less than zero results in a non-repeatable sequence of random numbers. If the value is of type floating-point, Float.int() is first used to calculate the actual integer value. . If the value is non-numeric, invalid is returned and the current seed is unchanged. PARAMETERS: value = Number RETURN VALUE: String or invalid. EXCEPTIONS: - EXAMPLE: var a = Lang.seed(123);    // a = \"\" var b = Lang.random(20);   // b = 0..20 var c = Lang.seed(\"seed\"); // c = invalid (random seed left                            //              unchanged) Lang.seed(7); var a = Lang.rand(10);  // a = 4(perhaps); Lang.seed(7); var b = Lang.rand(10);  // b = 4(perhaps, but same as a) Lang.seed(-1); var c = Lang.rand(10);  // c = 6(perhaps) Lang.seed(-1); var d = Lang.rand(10);  // d = 1(perhaps, but not necessarily                         //       the same as c)   7.15  characterSet FUNCTION: characterSet() FUNCTION ID: 14 DESCRIPTION: Returns the character set supported by the WMLScript Interpreter. The return value is an integer that denotes a MIBEnum value assigned by the IANA for all character sets (see [WSP] for more information). PARAMETERS: - RETURN VALUE: Integer. EXCEPTIONS: - EXAMPLE: var charset = Lang.characterSet(); // charset = 4 for latin1         2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 22(58)WAP-194-20000925-a                                                                                      25-SEP-2000                  8.  FLOAT NAME: Float LIBRARY ID: 1 DESCRIPTION: This library contains a set of typical arithmetic floating-point functions that are frequently used by applications. The implementation of these library functions is optional and implemented only by devices that can support floating-point operations (see 6.4). If floating-point operations are not supported, all functions in this library must return invalid.  8.1  int FUNCTION: int(value) FUNCTION ID: 0 DESCRIPTION: Returns the integer part of the given value. If the value is already an integer, the result is the value itself. PARAMETERS: value = Number RETURN VALUE: Integer or invalid. EXCEPTIONS: - EXAMPLE: var a = 3.14; var b = Float.int(a);    // b = 3 var c = Float.int(-2.8); // c = -2  8.2  floor FUNCTION: floor(value) FUNCTION ID: 1 DESCRIPTION: Returns the greatest integer value that is not greater than the given value. If the value is already an integer, the result is the value itself. PARAMETERS: value = Number RETURN VALUE: Integer or invalid. EXCEPTIONS: - EXAMPLE: var a = 3.14; var b = Float.floor(a);    // b = 3 var c = Float.floor(-2.8); // c = -3        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 23(58)WAP-194-20000925-a                                                                                      25-SEP-2000                8.3  ceil FUNCTION: ceil(value) FUNCTION ID: 2 DESCRIPTION: Returns the smallest integer value that is not less than the given value. If the value is already an integer, the result is the value itself. PARAMETERS: value = Number RETURN VALUE: Integer or invalid. EXCEPTIONS: - EXAMPLE: var a = 3.14; var b = Float.ceil(a);    // b = 4 var c = Float.ceil(-2.8); // c = -2  8.4  pow FUNCTION: pow(value1, value2) FUNCTION ID: 3 DESCRIPTION: Returns an implementation-dependent approximation to the result of raising value1 to the power of value2. If value1 is a negative number then value2 must be an integer. PARAMETERS: value1 = Number value2 = Number RETURN VALUE: Floating-point or invalid. EXCEPTIONS: If value1 == 0 and value2 < 0 then invalid is returned. If value1 < 0 and value2 is not an integer then invalid is returned. EXAMPLE: var a = 3; var b = Float.pow(a,2); // b = 9.0  8.5  round FUNCTION: round(value) FUNCTION ID: 4 DESCRIPTION: Returns the number value that is closest to the given value and is equal to a mathematical integer. If two integer number values are equally close to the value, the result is the larger number value. If the value is already an integer, the result is the value itself. PARAMETERS: value = Number       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 24(58)WAP-194-20000925-a                                                                                      25-SEP-2000                RETURN VALUE: Integer or invalid. EXCEPTIONS: - EXAMPLE: var a = Float.round(3.5);  // a = 4 var b = Float.round(-3.5); // b = -3 var c = Float.round(0.5);  // c = 1 var d = Float.round(-0.5); // b = 0  8.6  sqrt FUNCTION: sqrt(value) FUNCTION ID: 5 DESCRIPTION: Returns an implementation-dependent approximation to the square root of the given value. PARAMETERS: value = Floating-point RETURN VALUE: Floating-point or invalid. EXCEPTIONS: If value is a negative number then invalid is returned. EXAMPLE: var a = 4; var b = Float.sqrt(a); // b = 2.0 var c = Float.sqrt(5); // c = 2.2360679775  8.7  maxFloat FUNCTION: maxFloat() FUNCTION ID: 6 DESCRIPTION: Returns the maximum floating-point value supported by [IEEE754] single precision floating-point format. PARAMETERS: - RETURN VALUE: Floating-point 3.40282347E+38. EXCEPTIONS: - EXAMPLE: var a = Float.maxFloat();  8.8  minFloat FUNCTION: minFloat() FUNCTION ID: 7 DESCRIPTION: Returns the smallest nonzero floating-point value supported by [IEEE754] single precision floating-point format.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 25(58)WAP-194-20000925-a                                                                                      25-SEP-2000                PARAMETERS: - RETURN VALUE: Floating-point. Smaller than or equal to the normalised minimum single precision floating-point value: 1.17549435E-38. EXCEPTIONS: - EXAMPLE: var a = Float.minFloat();       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 26(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 9. STRING NAME: String LIBRARY ID: 2 DESCRIPTION: This library contains a set of string functions. A string is an array of characters. Each of the characters has an index. The first character in a string has an index zero (0). The length of the string is the number of characters in the array. The user of the String library can specify a special separator by which elements in a string can be separated. These elements can be accessed by specifying the separator and the element index. The first element in a string has an index zero (0). Each occurrence of the separator in the string separates two elements (no escaping of separators is allowed). A White space character is one of the following characters: - TAB: Horizontal Tabulation - VT: Vertical Tabulation - FF: Form Feed - SP: Space - LF: Line Feed - CR: Carriage Return  9.1  length FUNCTION: length(string) FUNCTION ID: 0 DESCRIPTION: Returns the length (number of characters) of the given string. PARAMETERS: string = String RETURN VALUE: Integer or invalid. EXCEPTIONS: - EXAMPLE: var a = \"ABC\"; var b = String.length(a);    // b = 3 var c = String.length(\"\");   // c = 0 var d = String.length(342);  // d = 3  9.2  isEmpty FUNCTION: isEmpty(string)       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 27(58)WAP-194-20000925-a                                                                                      25-SEP-2000                FUNCTION ID: 1 DESCRIPTION: Returns a boolean true if the string length is zero and boolean false otherwise.  PARAMETERS: string = String RETURN VALUE: Boolean or invalid. EXCEPTIONS: - EXAMPLE: var a = \"Hello\"; var b = \"\"; var c = String.isEmpty(a);    // c = false; var d = String.isEmpty(b);    // d = true var e = String.isEmpty(true); // e = false  9.3  charAt FUNCTION: charAt(string, index) FUNCTION ID: 2 DESCRIPTION: Returns a new string of length one containing the character at the specified index of the given string. If the index is of type floating-point, Float.int() is first used to calculate the actual integer index. PARAMETERS: string = String index = Number (the index of the character to be returned) RETURN VALUE: String or invalid. EXCEPTIONS: If index is out of range then an empty string (\"\") is returned. EXAMPLE: var a = \"My name is Joe\"; var b = String.charAt(a, 0);       // b = \"M\" var c = String.charAt(a, 100);     // c = \"\" var d = String.charAt(34, 0);      // d = \"3\" var d = String.charAt(a, \"first\"); // e = invalid  9.4  subString FUNCTION: subString(string, startIndex, length) FUNCTION ID: 3       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 28(58)WAP-194-20000925-a                                                                                      25-SEP-2000                DESCRIPTION: Returns a new string that is a substring of the given string. The substring begins at the specified startIndex and its length (number of characters) is the given length. If the startIndex is less than 0 then 0 is used for the startIndex. If the length is larger than the remaining number of characters in the string, the length is replaced with the number of remaining characters. If the startIndex or the length is of type floating-point, Float.int() is first used to calculate the actual integer value. PARAMETERS: string = String startIndex = Number (the beginning index, inclusive) length = Number (the length of the substring) RETURN VALUE: String or invalid. EXCEPTIONS: If startIndex is larger than the last index an empty string (\"\") is returned. If length <= 0 an empty string (\"\") is returned. EXAMPLE: var a = \"ABCD\"; var b = String.subString(a, 1, 2);    // b = \"BC\" var c = String.subString(a, 2, 5);    // c = \"CD\" var d = String.subString(1234, 0, 2); // d = \"12\"  9.5  find FUNCTION: find(string, subString) FUNCTION ID: 4 DESCRIPTION: Returns the index of the first character in the string that matches the requested subString. If no match is found integer value –1 is returned. Two strings are defined to match when they are identical. Characters with multiple possible representations match only if they have the same representation in both strings. No case folding is performed. PARAMETERS: string = String subString = String RETURN VALUE: Integer or invalid. EXCEPTIONS: If subString is an empty string (\"\"), an invalid value is returned. EXAMPLE: var a = \"abcde\"; var b = String.find(a, \"cd\");    // b = 2 var c = String.find(34.2, \"de\"); // c = -1 var d = String.find(a, \"qz\");    // d = -1 var e = String.find(34, \"3\");    // e = 0 var f = String.find(a, \"\");      // f = invalid  9.6  replace  FUNCTION: replace(string, oldSubString, newSubString)       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 29(58)WAP-194-20000925-a                                                                                      25-SEP-2000                FUNCTION ID: 5 DESCRIPTION: Returns a new string resulting from replacing all occurrences of oldSubString in this string with newSubString. Two strings are defined to match when they are identical. Characters with multiple possible representations match only if they have the same representation in both strings. No case folding is performed. PARAMETERS: string = String oldSubString = String newSubString = String RETURN VALUE: String or invalid. EXCEPTIONS:  If oldSubString is an empty string an invalid value is returned. EXAMPLE: var a = \"Hello Joe.  What is up Joe?\"; var newName = \"Don\"; var oldName = \"Joe\"; var c = String.replace(a, oldName, newName);   //  c = \"Hello Don.  What is up Don?\"; var d = String.replace(a, newName, oldName); //  d = \"Hello Joe.  What is up Joe?\"  9.7  elements FUNCTION: elements(string, separator) FUNCTION ID: 6 DESCRIPTION: Returns the number of elements in the given string separated by the given separator. Empty string (\"\") is a valid element (thus, this function can never return a value that is less or equal to zero). PARAMETERS: string = String separator = String (the first character of the string used as separator) RETURN VALUE: Integer or invalid. EXCEPTIONS: Returns invalid if the separator is an empty string.  EXAMPLE: var a = \"My name is Joe; Age 50;\"; var b = String.elements(a, \" \");       // b = 6 var c = String.elements(a, \";\");       // c = 3 var d = String.elements(\"\", \";\");      // d = 1 var e = String.elements(\"a\", \";\");     // e = 1 var f = String.elements(\";\", \";\");     // f = 2 var g = String.elements(\";;,;\", \";,\"); // g = 4 separator = ;  9.8  elementAt FUNCTION: elementAt(string, index, separator)       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 30(58)WAP-194-20000925-a                                                                                      25-SEP-2000                FUNCTION ID: 7 DESCRIPTION: Search string for index'th element, elements being separated by separator and return the corresponding element. If the index is less than 0 then the first element is returned. If the index is larger than the number of elements then the last element is returned. If the string is an empty string then an empty string is returned. If the index is of type floating-point, Float.int() is first used to calculate the actual index value. PARAMETERS: string = String index = Number (the index of the element to be returned) separator = String (the first character of the string used as separator) RETURN VALUE: String or invalid. EXCEPTIONS: Returns invalid if the separator is an empty string. EXAMPLE: var a = \"My name is Joe; Age 50;\"; var b = String.elementAt(a, 0, \" \");  // b = \"My\" var c = String.elementAt(a, 14, \";\"); // c = \"\" var d = String.elementAt(a, 1, \";\");  // d = \" Age 50\"  9.9  removeAt FUNCTION: removeAt(string, index, separator) FUNCTION ID: 8 DESCRIPTION: Returns a new string where the element and the corresponding separator (if existing) with the given index are removed from the given string. If the index is less than 0 then the first element is removed. If the index is larger than the number of elements then the last element is removed. If the string is empty, the function returns a new empty string. If the index is of type floating-point, Float.int() is first used to calculate the actual index value. PARAMETERS: string = String index = Number (the index of the element to be deleted) separator = String (the first character of the string used as separator) RETURN VALUE: String or invalid. EXCEPTIONS: Returns invalid if the separator is an empty string.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 31(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXAMPLE: var a = \"A A;  B C D\"; var s = \" \"; var b = String.removeAt(a, 1, s);  //  b = \"A  B C D\" var c = String.removeAt(a, 0, \";\");  //  c = \"  B C D\" var d = String.removeAt(a, 14, \";\");  //  d = \"A A\"  9.10  replaceAt FUNCTION: replaceAt(string, element, index, separator) FUNCTION ID: 9 DESCRIPTION: Returns a string with the current element at the specified index replaced with the given element. If the index is less than 0 then the first element is replaced. If the index is larger than the number of elements then the last element is replaced. If the string is empty, the function returns a new string with the given element. If the index is of type floating-point, Float.int() is first used to calculate the actual index value. PARAMETERS: string = String element = String index = Number (the index of the element to be replaced) separator = String (the first character of the string used as separator) RETURN VALUE: String or invalid. EXCEPTIONS: Returns invalid if the separator is an empty string. EXAMPLE: var a = \"B C; E\"; var s = \" \"; var b = String.replaceAt(a, \"A\", 0, s);  //  b = \"A C; E\" var c = String.replaceAt(a, \"F\", 5, \";\");  //  c = \"B C;F\"  9.11  insertAt FUNCTION: insertAt(string, element, index, separator) FUNCTION ID: 10 DESCRIPTION: Returns a string with the element and the corresponding separator (if needed) inserted at the specified element index of the original string. If the index is less than 0 then 0 is used as the index. If the index is larger than the number of elements then the element is appended at the end of the string. If the string is empty, the function returns a new string with the given element. If the index is of type floating-point, Float.int() is first used to calculate the actual index value.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 32(58)WAP-194-20000925-a                                                                                      25-SEP-2000                PARAMETERS: string = String (original string) element = String (element to be inserted) index = Number (the index of the element to be added) separator = String (the first character of the string used as separator) RETURN VALUE: String or invalid. EXCEPTIONS: Returns invalid if the separator is an empty string. EXAMPLE: var a = \"B C; E\"; var s = \" \"; var b = String.insertAt(a, \"A\", 0, s);  //  b = \"A B C; E\"  var c = String.insertAt(a, \"X\", 3, s);  //  c = \"B C; E X\"  var d = String.insertAt(a, \"D\", 1, \";\");  //  d = \"B C;D; E\" var e = String.insertAt(a, \"F\", 5, \";\");  //  e = \"B C; E;F\"  9.12  squeeze FUNCTION: squeeze(string) FUNCTION ID: 11 DESCRIPTION: Returns a string where all consecutive series of white spaces within the string are reduced to single inter-word space. PARAMETERS: String = String RETURN VALUE: String or invalid. EXCEPTIONS: - EXAMPLE: var a = \"Hello\"; var b = \" Bye    Jon . \\r\\n See you!  \"; var c = String.squeeze(a); // c = \"Hello\"; var d = String.squeeze(b); // d = \" Bye Jon . See you! \";  9.13  trim FUNCTION: trim(string) FUNCTION ID: 12 DESCRIPTION: Returns a string where all trailing and leading white spaces in the given string have been trimmed. PARAMETERS: String = String RETURN VALUE: String or invalid.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 33(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXCEPTIONS: - EXAMPLE: var a = \"Hello\"; var b = \" Bye    Jon .  See you!  \"; var c = String.trim(a); // c = \"Hello\" var d = String.trim(b); // d = \"Bye    Jon .  See you!\"  9.14  compare FUNCTION: compare(string1, string2) FUNCTION ID: 13 DESCRIPTION: The return value indicates the lexicographic relation of string1 to string2. The relation is based on the relation of the character codes in the native character set. The return value is –1 if string1 is less than string2, 0 if string1 is identical to string2 or 1 if string1 is greater than string2. PARAMETERS: String1 = String String2 = String RETURN VALUE: Integer or invalid. EXCEPTIONS: - EXAMPLE: var a = \"Hello\"; var b = \"Hello\"; var c = String.compare(a, b);         // c = 0 var d = String.compare(\"Bye\", \"Jon\"); // d = -1 var e = String.compare(\"Jon\", \"Bye\"); // e = 1  9.15  toString FUNCTION: toString(value) FUNCTION ID: 14 DESCRIPTION: Returns a string representation of the given value. This function performs exactly the same conversions as supported by the [WMLScript] language (automatic conversion from boolean, integer and floating-point values to strings) except that invalid value returns the string \"invalid\". PARAMETERS: value = Any RETURN VALUE: String. EXCEPTIONS: - EXAMPLE: var a = String.toString(12);   // a = \"12\" var b = String.toString(true); // b = \"true\"        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 34(58)WAP-194-20000925-a                                                                                      25-SEP-2000                9.16  format  FUNCTION: format(format, value) FUNCTION ID: 15 DESCRIPTION: Converts the given value to a string by using the given formatting provided as a format string. The format string can contain only one format specifier, which can be located anywhere inside the string. If more than one is specified, only the first one (leftmost) is used and the remaining specifiers are replaced by an empty string. The format specifier has the following form:     % [width] [.precision] type The width argument is a nonnegative decimal integer controlling the minimum number of characters printed. If the number of characters in the output value is less than the specified width, blanks are added to the left until the minimum width is reached. The width argument never causes the value to be truncated. If the number of characters in the output value is greater than the specified width or, if width is not given, all characters of the value are printed (subject to the precision argument). The precision argument specifies a nonnegative decimal integer, preceded by a period (.), which can be used to set the precision of the output value. The interpretation of this value depends on the given type: d Specifies the minimum number of digits to be printed. If the number of digits in the value is less than precision, the output value is padded on the left with zeroes. The value is not truncated when the number of digits exceeds precision. Default precision is 1. If precision is specified as 0 and the value to be converted is 0, the result is an empty string. f Specifies the number of digits after the decimal point. If a decimal point appears, at least one digit appears before it. The value is rounded to the appropriate number of digits. Default precision is 6; if precision is 0 or if the period (.) appears without a number following it, no decimal point is printed. s Specifies the maximum number of characters to be printed. By default, all characters are printed. Unlike the width argument, the precision argument can cause either truncation of the output value or rounding of a floating-point value. The type argument is the only required format argument; it appears after any optional format fields. The type character determines whether the given value is interpreted as integer, floating-point or string. If the value argument is of a different type than is specified by the type argument, it is converted according to WMLScript standard automatic conversion rules, with the addition that if value is of type floating-point and type is d, Float.int() is called to convert the value. The supported type arguments are: d Integer: The output value has the form [-]dddd, where dddd is one       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 35(58)WAP-194-20000925-a                                                                                      25-SEP-2000                or more decimal digits. f Floating-point: The output value has the form [-]dddd.dddd, where dddd is one or more decimal digits. The number of digits before the decimal point depends on the magnitude of the number and the number of digits after the decimal point depends on the requested precision. When the number of digits after the decimal point in the value is less than the precision, letter 0 should be padded to fill columns (e.g. the result of String.format(\"%2.3f\", 1.2) will be \"1.200\") s String: Characters are printed up to the end of the string or until the precision value is reached. When the width is larger than precision, the width should be ignored. A literal percent character (%) may be included in the format string by preceding it with another percent character (%%). PARAMETERS: format = String  value = Any RETURN VALUE: String or invalid. EXCEPTIONS: Illegal format specifier results in an invalid return value. If type f is specified in format argument and floating-point numbers are not supported, invalid is returned. EXAMPLE: var a = 45; var b = -45; var c = \"now\"; var d = 1.2345678; var e = String.format(\"e: %6d\", a);   // e = \"e:     45\" var f = String.format(\"%6d\", b);      // f = \"   -45\" var g = String.format(\"%6.4d\", a);    // g = \"  0045\" var h = String.format(\"%6.4d\", b);    // h = \" –0045\" var i = String.format(\"Do it %s\", c); // i = \"Do it now\" var j = String.format(\"%3f\", d);      // j = \"1.234568\" var k = String.format(\"%10.2f%%\", d); // k = \"      1.23%\" var l = String.format(\"%3f %2f.\", d); // l = \"1.234568 .\" var m = String.format(\"%.0d\", 0);     // m = \"\" var n = String.format(\"%7d\", \"Int\");  // n = invalid var o = String.format(\"%s\", true);    // o = \"true\"        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 36(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 10.  URL NAME: URL LIBRARY ID: 3 DESCRIPTION: This library contains a set of functions for handling both absolute URLs and relative URLs. The URL syntax supported is defined in [RFC2396]. Currently this library supports access to only a subset of URL elements specified in [RFC2396].  10.1  isValid FUNCTION: isValid(url) FUNCTION ID: 0 DESCRIPTION: Returns true if the given url has the right URL syntax, otherwise returns false. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. PARAMETERS: url = String RETURN VALUE: Boolean or invalid. EXCEPTIONS: - EXAMPLE: var a = URL.isValid(\"http://w.hst.com/script#func()\"); //  a = true var b = URL.isValid(\"../common#test()\"); //  b = true var c = URL.isValid(\"experimental?://www.host.com/cont>\"); //  c = false  10.2  getScheme FUNCTION: getScheme(url) FUNCTION ID: 1 DESCRIPTION: Returns the scheme used in the given url. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the scheme an invalid value is returned.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 37(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXAMPLE: var a = URL.getScheme(\"http://w.h.com/path#frag\"); //  a = \"http\" var b = URL.getScheme(\"w.h.com/path#frag\"); //  b = \"\"  10.3  getHost FUNCTION: getHost(url) FUNCTION ID: 2 DESCRIPTION: Returns the host specified in the given url. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. If the host part of the URL is not defined, the function returns an empty string. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the host part an invalid value is returned. EXAMPLE: var a = URL.getHost(\"http://w.h.com/path#frag\"); //  a = \"w.h.com\" var b = URL.getHost(\"path#frag\"); //  b = \"\" var c = URL.getHost(\"zyx://me@ismo.k.oksa#fab\"); //  c = \"ismo.k.oksa\"  10.4  getPort FUNCTION: getPort(url) FUNCTION ID: 3 DESCRIPTION: Returns the port number specified in the given url. If no port is specified then an empty string is returned. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the port number an invalid value is returned. EXAMPLE: var a = URL.getPort(\"http://w.h.com:80/path#frag\"); //  a = \"80\" var b = URL.getPort(\"http://w.h.com/path#frag\"); //  b = \"\"        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 38(58)WAP-194-20000925-a                                                                                      25-SEP-2000                10.5  getPath FUNCTION: getPath(url) FUNCTION ID: 4 DESCRIPTION: Returns the path specified in the given url. Parameters specified for each path segment, if any, are not returned. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the path an invalid value is returned. EXAMPLE: a = URL.getPath(\"http://w.h.com/home/sub/comp#frag\"); //  a = \"/home/sub/comp\" b = URL.getPath(\"../home/sub/comp#frag\"); //  b = \"../home/sub/comp\" c = URL.getPath(\"http://w.a.p/a;x/b;y=1/c;fg#a\"); //  c = \"/a/b/c\" d = URL.getPath(\"http://w.a.p/a;x/b;y=1/c#b\"); //  d = \"/a/b/c\"  10.6  getParameters FUNCTION: getParameters(url) FUNCTION ID: 5 DESCRIPTION: Returns the parameters used in the last path segment of the given url. If no parameters are specified an empty string is returned. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. NOTE: This version of this function does not take into account the possibility for each segment to have parameters (see [RFC2396] for more information). Only the parameters specified for the last segment are returned. This may change in the future. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the parameters an invalid value is returned.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 39(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXAMPLE: a = URL.getParameters(\"http://w.h.com/script;3;2?x=1&y=3\"); //  a = \"3;2\" b = URL.getParameters(\"../script;3;2?x=1&y=3\"); //  b = \"3;2\" c = URL.getParameters(\"http://w.a.p/a;x/b;y=1/c;fg\"); //  c = \"fg\" d = URL.getParameters(\"http://w.a.p/a;x/b;y=1/c\"); //  d = \"\"  10.7  getQuery FUNCTION: getQuery(url) FUNCTION ID: 6 DESCRIPTION: Returns the query part specified in the given url. If no query part is specified an empty string is returned. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the query part an invalid value is returned. EXAMPLE: a = URL.getQuery(\"http://w.h.com/home;3;2?x=1&y=3\"); //  a = \"x=1&y=3\"  10.8  getFragment FUNCTION: getFragment(url) FUNCTION ID: 7 DESCRIPTION: Returns the fragment used in the given url. If no fragment is specified an empty string is returned. Both absolute and relative URLs are supported. Relative URLs are not resolved into absolute URLs. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: If an invalid URL syntax is encountered while extracting the fragment an invalid value is returned. EXAMPLE: var a = URL.getFragment(\"http://w.h.com/cont#frag\"); //  a = \"frag\"  10.9  getBase FUNCTION: getBase()       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 40(58)WAP-194-20000925-a                                                                                      25-SEP-2000                FUNCTION ID: 8 DESCRIPTION: Returns an absolute URL (without the fragment) of the current WMLScript compilation unit. PARAMETERS: - RETURN VALUE: String. EXCEPTIONS: - EXAMPLE: var a = URL.getBase(); //  Result: \"http://www.host.com/test.scr\"  10.10  getReferer FUNCTION: getReferer() FUNCTION ID: 9 DESCRIPTION: Returns the smallest relative URL (relative to the base URL of the current compilation unit, see 10.9) to the resource that called the current compilation unit. Local function calls do not change the referer. If the current compilation unit does not have a referer then an empty string is returned. PARAMETERS: - RETURN VALUE: String. EXCEPTIONS: - EXAMPLE: var base    = URL.getBase(); //  base    = \"http://www.host.com/current.scr\" var referer = URL.getReferer(); //  referer = \"app.wml#card2\"  10.11  resolve FUNCTION: resolve(baseUrl, embeddedUrl) FUNCTION ID: 10 DESCRIPTION: Returns an absolute URL from the given baseUrl and the embeddedUrl according to the rules specified in [RFC2396]. Before executing the rules specified in [RFC2396] the baseUrl is checked. If the baseUrl’s path component is an empty string, then a single slash character (“/”) is assumed as the path. If the embeddedUrl is already an absolute URL, the function returns it without modification. PARAMETERS: baseUrl = String embeddedUrl = String RETURN VALUE: String or invalid.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 41(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXCEPTIONS: If an invalid URL syntax is encountered as part of the resolution an invalid value is returned. EXAMPLE: var a = URL.resolve(\"http://foo.com/\",\"foo.vcf\"); //  a = \"http://foo.com/foo.vcf\" var b = URL.resolve(\"http://foo.com\",\"c\"); //  b = \"http://foo.com/c\" var c = URL.resolve(\"http://foo.com\",\"/c\"); //  c = \"http://foo.com/c\" var d = URL.resolve(\"http://foo.com\",\"?q\"); //  d = \"http://foo.com/?q\" var e = URL.resolve(\"http://\", \"x\"); //  e = \"http:///x\"  10.12  escapeString FUNCTION: escapeString(string) FUNCTION ID: 11 DESCRIPTION: This function computes a new version of a string value in which special characters specified by [RFC2396] have been replaced by a hexadecimal escape sequence (a two-digit escape sequence of the form %xx must be used). The characters to be escaped are: - Control characters: <US-ASCII coded characters 00-1F and 7F> - Space:      <US-ASCII coded character 20 hexadecimal> - Reserved: \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" - Unwise:   \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"`\" - Delims:    \"<\" | \">\" | \"#\" | \"%\" | <\"> - Non-US-ASCII: <characters with hex code 8F-FF> The given string is escaped as such; no URL parsing is performed. Non-US-ASCII characters must be converted using the character codes used in the native character set. PARAMETERS: string = String RETURN VALUE: String or invalid. EXCEPTIONS: If string contains characters with a character codes above hex FF an invalid value is returned. EXAMPLE: var a = URL.escapeString(\"http://w.h.com/dck?x=\\u007f#crd\"); //  a = \"http%3a%2f%2fw.h.com%2fdck%3fx%3d%7f%23crd\" var b = URL.escapeString(\"http://w.h.com/dck?x=\\\\u007f#crd\"); // b = \"http%3a%2f%2fw.h.com%2fdck%3fx%3d%5cu007f%23crd\"        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 42(58)WAP-194-20000925-a                                                                                      25-SEP-2000                10.13  unescapeString FUNCTION: UnescapeString(string) FUNCTION ID: 12 DESCRIPTION: The unescape function computes a new version of a string value in which each escape sequences of the sort that might be introduced by the URL.escapeString() function (see 10.12) is replaced with the character that it represents. The given string is unescaped as such; no URL parsing is performed. PARAMETERS: string = String RETURN VALUE: String or invalid. EXCEPTIONS: If string contains characters that are not part of the US-ASCII character set, an invalid value is returned. EXAMPLE: var a = \"http%3a%2f%2fw.h.com%2fdck%3fx%3d12%23crd\"; var b = URL.unescapeString(a); //  b = \"http://w.h.com/dck?x=12#crd\"        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 43(58)WAP-194-20000925-a                                                                                      25-SEP-2000                10.14  loadString FUNCTION: loadString(url, contentType) FUNCTION ID: 13 DESCRIPTION: Returns the content denoted by the given absolute url and the content type. Regardless of what content types the user agent supports, it MUST expect to receive \"text\" content as a result of executing URL.loadString. The user agent MUST preface the request with an Accept header which consists  ONLY of the content type specified by contentType. The given content type is erroneous if it does not follow the following rules: - Only one content type can be specified. The whole string must match with only one content type and no extra leading or trailing spaces are allowed. - The type must be text but the subtype can be anything. Thus, the type prefix must be \"text/\". The behaviour of this function is the following: - The content with the given content type and url is loaded. The rest of the attributes needed for the content load are specified by the default settings of the user agent. - If the load is successful and the returned content type matches the given content type then the content is converted to a string and returned. - If the load is unsuccessful or the returned content is of wrong content type then a scheme specific error code is returned. PARAMETERS: url = String contentType = String RETURN VALUE: String, integer or invalid. EXCEPTIONS: Returns an integer error code that depends on the used URL scheme in case the load fails. If HTTP [RFC2068] or WSP (see [WAE]) schemes are used, HTTP error codes are returned. If an erroneous content type is given, an invalid value is returned. EXAMPLE: var myUrl = \"http://www.host.com/vcards/myaddr.vcf\"; myCard = URL.loadString(myUrl,\"text/x-vcard\");        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 44(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 11.  WMLBROWSER NAME: WMLBrowser LIBRARY ID: 4 DESCRIPTION: This library contains functions by which WMLScript can access the associated WML context. These functions must not have any side effects and they must return invalid in the following cases: If the system does not have a WML browser, or if the WMLScript interpreter was not invoked by the WML browser, these functions must always return invalid.  11.1  getVar FUNCTION: getVar(name) FUNCTION ID: 0 DESCRIPTION: Returns the value of the variable with the given name in the current browser context. Returns an empty string if the given variable does not exist. Variable name must follow the syntax specified by [WML]. PARAMETERS: name = String RETURN VALUE: String or invalid. EXCEPTIONS: If the syntax of the variable name is incorrect an invalid value is returned. EXAMPLE: var a = WMLBrowser.getVar(\"name\"); // a = \"Jon\" or whatever value the variable has.  11.2  setVar FUNCTION: setVar(name, value) FUNCTION ID: 1 DESCRIPTION: Returns true if the variable with the given name is successfully set to contain the given value in the current browser context, false otherwise. Variable name and its value must follow the syntax specified by [WML]. Variable value must be legal XML CDATA. PARAMETERS: name = String value = String RETURN VALUE: Boolean or invalid. EXCEPTIONS: If the syntax of the variable name or its value is incorrect an invalid value is returned. EXAMPLE: var a = WMLBrowser.setVar(\"name\", Mary); // a = true       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 45(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 11.3  go FUNCTION: go(url) FUNCTION ID: 2 DESCRIPTION: Specifies the content denoted by the given url to be loaded. This function has the same semantics as the GO task in WML (see [WML] for more information). The content is loaded only after the WML browser resumes the control back from the WMLScript interpreter after the WMLScript invocation is finished. When the WML browser loads the content, the referring URI is the URI of the current card. If a relative URI is given as the url, the WML browser must resolve it by using the URI of the current card. No content is loaded if the given url is an empty string (\"\"). go() and prev() (see 11.3) library functions override each other. Both of these library functions can be called multiple times before returning the control back to the WML browser. However, only the settings of the last call stay in effect. In particular, if the last call to go()sets the URL to an empty string (\"\"), all previous go() and prev() requests are effectively cancelled. Invoking the Lang.abort() function (see 7.12) along with any other fatal errors (see [WMLScript]) cancels any pending go() request.  This function returns an empty string. PARAMETERS: url = String RETURN VALUE: String or invalid. EXCEPTIONS: -       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 46(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXAMPLE: extern function goToStart() {   var card = \"http://www.host.com/loc/app.dck#start\";   WMLBrowser.go(card); };  extern function get() {   WMLBrowser.go(\"#next_card\");   return; };  // If the above function is invoked from the following // WML fragment: // .. //  <card id=\"referring_card\" > //    .. //    <go href=\"myscript#get()\"/> //    .. //  </card> // .. // // The referring URI will be the URI of the WML card that // invoked the function go and fulfils the script's request // (i.e., the card with the id \"referring_card\").  11.4  prev FUNCTION: prev() FUNCTION ID: 3 DESCRIPTION: Signals the WML browser to go back to the previous WML card. This function has the same semantics as the PREV task in WML (see [WML] for more information). The previous card is loaded only after the WML browser resumes the control back from the WMLScript interpreter after the WMLScript invocation is finished. prev() and go() (see 11.3) library functions override each other. Both of these library functions can be called multiple times before returning the control back to the WML browser. However, only the settings of the last call stay in effect. In particular, if the last call to go()sets the URL to an empty string (\"\"), all previous go() and prev() requests are effectively cancelled. Invoking the Lang.abort() function (see 7.12) along with any other fatal errors (see [WMLScript]) cancels any pending prev() request.  This function returns an empty string. PARAMETERS: - RETURN VALUE: String or invalid.       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 47(58)WAP-194-20000925-a                                                                                      25-SEP-2000                EXCEPTIONS: - EXAMPLE: WMLBrowser.prev();  11.5  newContext FUNCTION: newContext() FUNCTION ID: 4 DESCRIPTION: A call to this function clears all variables of the associated WML context and clears the navigation history stack (see [WML] for more information) except for the current card before returning execution to the calling entity. The function does not impact a navigation request from a previous or subsequent go() call. A previous or subsequent prev() call will have no effect. The function returns an empty string. PARAMETERS: - RETURN VALUE: String or invalid. EXCEPTIONS: - EXAMPLE: WMLBrowser.newContext();  11.6  getCurrentCard FUNCTION: getCurrentCard() FUNCTION ID: 5 DESCRIPTION: Returns the smallest relative URL (relative to the base of the current compilation unit, see 10.9 for information about how to access the current base) specifying the card (if any) currently being processed by the WML Browser (see [WML] for more information). The function returns an absolute URL in case the WML deck containing the current card does not have the same base as the current compilation unit. PARAMETERS: - RETURN VALUE: String or invalid. EXCEPTIONS: Returns invalid in case there is no current card. EXAMPLE: var a = WMLBrowser.getCurrentCard(); //  a = \"deck#input\"  11.7  refresh FUNCTION: refresh() FUNCTION ID: 6       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 48(58)WAP-194-20000925-a                                                                                      25-SEP-2000                DESCRIPTION: The WML Browser should update its user interface based on the current context. Implementations that support refresh must perform the steps defined in [WML] with the exception to restarting a suspended timer. This function must not restart a suspended timer. This function must block until all the steps have completed. The refresh actions must be applied to the current WML card. If the current WML card was not rendered prior to invoking this call (e.g., a script that was invoked by an onenterforward event binding), the refresh function must render the current card. This function returns invalid if the current implementation does not support immediate refresh. Otherwise, this function returns an empty string if the refresh succeeds, or a non-empty string if it fails (e.g., failed to update an image). The content of the string is implementation dependent. The function should return a brief message explaining the error. Note: if the current implementation does not support refresh, the WML user agent must still refresh the card when control returns back to the WML user agent. PARAMETERS: - RETURN VALUE: String or invalid. EXCEPTIONS: - EXAMPLE: WMLBrowser.setVar(\"name\",\"Zorro\"); var refreshOK = WMLBrowser.refresh();         2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 49(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 12.  DIALOGS NAME: Dialogs LIBRARY ID: 5 DESCRIPTION: This library contains a set of typical user interface functions.  12.1  prompt FUNCTION: prompt(message, defaultInput) FUNCTION ID: 0 DESCRIPTION: Displays the given message and prompts for user input. The defaultInput parameter contains the initial content for the user input. Returns the user input. PARAMETERS: message = String defaultInput = String RETURN VALUE: String or invalid. EXCEPTIONS: - EXAMPLE: var a = \"09-555 3456\"; var b = Dialogs.prompt(\"Phone number: \",a);  12.2  confirm FUNCTION: confirm(message, ok, cancel) FUNCTION ID: 1 DESCRIPTION: Displays the given message and two reply alternatives: ok and cancel. Waits for the user to select one of the reply alternatives and returns true for ok and false for cancel. PARAMETERS: message = String ok = String (text, empty string results in the default implementation-dependent text) cancel = String (text, empty string results in the default implementation-dependent text) RETURN VALUE: Boolean or invalid. EXCEPTIONS: - EXAMPLE: function onAbort() {   return Dialogs.confirm(\"Are you sure?\",\"Yes\",\"Well...\"); };        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 50(58)WAP-194-20000925-a                                                                                      25-SEP-2000                12.3  alert FUNCTION: alert(message) FUNCTION ID: 2 DESCRIPTION: Displays the given message to the user, waits for the user confirmation and returns an empty string. PARAMETERS: message = String RETURN VALUE: String or invalid. EXCEPTIONS: - EXAMPLE: function testValue(textElement) {   if (String.length(textElement) > 8) {     Dialogs.alert(\"Enter name < 8 chars!\");   }; };       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 51(58)WAP-194-20000925-a                                                                                      25-SEP-2000                 Appendix A. Library Summary  The libraries and their library identifiers:  Library name Library ID Page Lang 0 15 Float 1 22 String 2 26 URL 3 36 WMLBrowser 4 44 Dialogs 5 49   The libraries and their functions:  Lang library Function ID abs 0 min 1 max 2 parseInt 3 parseFloat 4 isInt 5 isFloat 6 maxInt 7 minInt 8 float 9 exit 10 abort 11 random 12 seed 13 characterSet 14  Float library Function ID int 0 floor 1 ceil 2 pow 3 round 4 sqrt 5 maxFloat 6 minFloat 7        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 52(58)WAP-194-20000925-a                                                                                      25-SEP-2000                String library Function ID length 0 isEmpty 1 charAt 2 subString 3 find 4 replace  5 elements 6 elementAt 7 removeAt 8 replaceAt 9 insertAt 10 squeeze 11 trim 12 compare 13 toString 14 format  15  URL library Function ID isValid 0 getScheme 1 getHost 2 getPort 3 getPath 4 getParameters 5 getQuery 6 getFragment 7 getBase 8 getReferer 9 resolve 10 escapeString 11 unescapeString 12 loadString 13  WMLBrowser library Function ID getVar 0 setVar 1 go 2 prev 3 newContext 4 getCurrentCard 5 refresh 6        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 53(58)WAP-194-20000925-a                                                                                      25-SEP-2000                Dialogs library Function ID prompt 0 confirm 1 alert 2   Appendix B. Static Conformance Requirements  This static conformance clause defines a minimum set of features that can be implemented to ensure that WMLScript Standard Libraries will be able to inter-operate.   12.4 WMLScript Encoder Capabilities   Identifier Function Reference Status Requirement WMLSSL-001 Supports Lang library and all of its functions  Lang M  WMLSSL-002 Supports Float library and all of its functions  Float M  WMLSSL-003 Supports String library and all of its functions String M  WMLSSL-004 Supports URL library and all of its functions  URL  M  WMLSSL-005 Supports WMLBrowser library and all of its functions  WMLBrowser M  WMLSSL-006 Supports Dialogs library and all of its functions  Dialogs M  WMLSSL-007 Supports all library identifiers for standard libraries Appendix A. Library Summary M  WMLSSL-008 Supports Lang library function identifiers Appendix A. Library Summary M  WMLSSL-009 Supports Float library function identifiers Appendix A. Library Summary M  WMLSSL-010 Supports String library function identifiers Appendix A. Library Summary M        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 54(58)WAP-194-20000925-a                                                                                      25-SEP-2000                Identifier Function Reference Status Requirement WMLSSL-011 Supports URL library function identifiers Appendix A. Library Summary M  WMLSSL-012 Supports WMLBrowser library function identifiers Appendix A. Library Summary M  WMLSSL-013 Supports Dialogs library function identifiers Appendix A. Library Summary M         2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 55(59)WAP-194-20000925-a                                                                                      25-SEP-2000                 12.5 WMLScript Bytecode Interpreter Capabilities  Identifier Function Reference Status Requirement WMLSSL-014 Supports WMLScript data types integer, boolean, string, invalid and float Supported Data Type M  WMLSSL-015 Supports automatic type conversions  Data Type Conversions M  WMLSSL-016 Supports error handling  Error Handling M  WMLSSL-017 Supports floating point operations  Support for Integer-Only Devices O WMLS-111 WMLSSL-018 Supports Lang library  Lang  M  WMLSSL-019 Supports Float library  Float M  WMLSSL-020 Supports String library String M  WMLSSL-021 Supports URL library  URL M  WMLSSL-022 Supports WMLBrowser library  WMLBrowser M  WMLSSL-023 Supports Dialogs library  Dialogs M  WMLSSL-024 Supports all library identifiers for standard libraries Appendix A. Library Summary M  WMLSSL-025 Supports Lang library function identifiers Appendix A. Library Summary M  WMLSSL-026 Supports Float library function identifiers Appendix A. Library Summary M  WMLSSL-027 Supports String library function identifiers Appendix A. Library Summary M  WMLSSL-028 Supports URL library function identifiers Appendix A. Library Summary M  WMLSSL-029 Supports WMLBrowser library function identifiers Appendix A. Library Summary M  WMLSSL-030 Supports Dialogs library function identifiers Appendix A. Library Summary M        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 56(59)WAP-194-20000925-a                                                                                      25-SEP-2000                Identifier Function Reference Status Requirement Summary  Lang Library Identifier Function Reference Status Requirement WMLSSL-031 abs function  abs  M  WMLSSL-032 min function  min  M  WMLSSL-033 max function  max  M  WMLSSL-034 parseInt function  parseInt  M  WMLSSL-035 parseFloat function  parseFloat  M  WMLSSL-036 isInt function  isInt  M  WMLSSL-037 isFloat function  isFloat  M  WMLSSL-038 maxInt function  maxInt  M  WMLSSL-039 minInt function  minInt  M  WMLSSL-040 float function  float  M  WMLSSL-041 exit function  exit  M  WMLSSL-042 abort function  abort  M  WMLSSL-043 random function  random  M  WMLSSL-044 seed function  seed  M  WMLSSL-045 characterSet function  characterSet M   Float Library Identifier Function Reference Status Requirement WMLSSL-046 All functions return invalid if floating point not supported  Float  M  WMLSSL-047 int function  int  M  WMLSSL048 floor function  floor  M  WMLSSL-049 ceil function  ceil  M  WMLSSL-050 pow function  pow  M  WMLSSL-051 round function  round  M  WMLSSL-052 sqrt function  sqrt  M  WMLSSL-053 maxFloat function  maxFloat  M  WMLSSL-054 minFloat function  minFloat M   String Library Identifier Function Reference Status Requirement WMLSSL-055 length function  length  M        2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 57(58)WAP-194-20000925-a                                                                                      25-SEP-2000                Identifier Function Reference Status Requirement WMLSSL-056 isEmpty function  isEmpty  M  WMLSSL-057 charAt function  charAt  M  WMLSSL-058 subString function  subString  M  WMLSSL-059 find function  find  M  WMLSSL-060 replace function  replace  M  WMLSSL-061 elements function  elements  M  WMLSSL-062 elementAt function  elementAt  M  WMLSSL-063 removeAt function  removeAt  M  WMLSSL-064 replaceAt function  replaceAt  M  WMLSSL-065 insertAt function  insertAt  M  WMLSSL-066 squeeze function  squeeze  M  WMLSSL-067 trim function  trim  M  WMLSSL-068 compare function  compare  M  WMLSSL-069 toString function  toString  M  WMLSSL-070 format function  format M   URL Library Identifier Function Reference Status Requirement WMLSSL-071 isValid function  isValid  M  WMLSSL-072 getScheme function  getScheme  M  WMLSSL-073 getHost function  getHost  M  WMLSSL-074 getPort function  getPort  M  WMLSSL-075 getPath function  getPath  M  WMLSSL-076 getParameters function  getParameters  M  WMLSSL-077 getQuery function  getQuery  M  WMLSSL-078 getFragment function  getFragment  M  WMLSSL-079 getBase function  getBase  M  WMLSSL-080 getReferer function  getReferer  M  WMLSSL-081 resolve function   resolve  M  WMLSSL-082 escapeString function  escapeString  M  WMLSSL-083 unescapeString function  unescapeString  M  WMLSSL-084 loadString function  loadString M   WMLBrowser Library  Identifier Function Reference Status Requirement       2000,2001, Wireless Application Protocol Forum, Ltd.  All rights reserved  Page 58(58)WAP-194-20000925-a                                                                                      25-SEP-2000                Identifier Function Reference Status Requirement WMLSSL-085 getVar function  getVar  M  WMLSSL-086 setVar function  setVar  M  WMLSSL-087 go function  go  M  WMLSSL-088 prev function  prev  M  WMLSSL-089 newContext function  newContext  M  WMLSSL-090 getCurrentCard function  getCurrentCard  M  WMLSSL-091 refresh function  refresh M   Dialogs Library  Identifier Function Reference Status Requirement WMLSSL-092 prompt function  prompt  M  WMLSSL-093 confirm function  confirm  M  WMLSSL-094 alert function  alert M"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-194_103-WMLScriptLibraries-20020318-a.pdf","file":"WAP-194_103-WMLScriptLibraries-20020318-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"This document provides changes and corrections to the following document file: - WAP-194-WMLSL-20000925-a It includes changes from the following change requests: - CR-NOKIA-WMLSL-20020131-1 2. Notation In the subsections describing the changes new text is underlined. Removed text has strikethrough marks. The presented text is copied from the specification. Text that is not presented is not affected at all. The change descriptions may also include editor’s notes similar to the one below. The notes are not part of the actual changes and must not be included in the changed text."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-210-WAPArch-20010712-a.pdf","file":"WAP-210-WAPArch-20010712-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"The Wireless Application Protocol (WAP) is a result of continuous work to define an industry wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a  set  of  specifications  to  be  used  by  service  applications.  The  wireless  market  is  growing  very  quickly,  reaching  new  customers  and  providing  new  services.  To  enable  operators  and  manufacturers  to  meet  the  challenges  in  advanced  services, differentiation, and fast/flexible service creation, WAP selects and defines a set of open, extensible protocols and content formats as a basis for interoperable implementations. The objectives of the WAP Forum are: • To bring Internet content and advanced data services to digital cellular phones and other wireless terminals. • To create a global wireless protocol specification that will work across differing wireless network technologies. • To  enable  the  creation  of  content  and  applications  that  scale  across  a  very  wide  range  of  bearer  networks  and  device types. • To embrace and extend existing standards and technology wherever appropriate. The WAP Architecture Specification is intended to present the system and protocol architectures essential to achieving the objectives of the WAP Forum. The WAP Architecture Specification acts as the starting point for understanding the WAP technologies and the resulting specifications. As such, it provides an overview of the different technologies and references the appropriate specifications for further details. This version of the WAP Architecture continues the themes and builds on the successes of the initial WAP architecture.  Network  elements  remain  similar  in  function.    For  example,  the  architecture  uses  performance  and  feature-enhancing proxies to offload processing from constrained devices, to expose features and functions of the wireless network, and to provide for network and service management.  This version of the architecture has been enhanced to allow for a broader selection  of  connection  paths  between  clients  and  origin  servers  as  necessary,  for  example  to  provide  end-to-end security. The  WAP  Architecture  Specification  itself  provides  a  framework  for  a  variety  of  protocols,  features,  and  services.  It  does not mandate any specific implementation and shall therefore be considered informative.  WAP-210-WAPArch-20010712, Version 12-July-2001  Page 5 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved2. Document Status This document is available online in the following formats: • PDF format at http://www.wapforum.org/. 2.1 Copyright Notice © Copyright Wireless Application Forum Ltd, 2000. Terms and conditions of use are available from the Wireless Application Protocol Forum Ltd. web site at http://www.wapforum.org/docs/copyright.htm. 2.2 Trademark Notice WAP and all WAP-based  marks  are  world-wide trademarks or registered trademarks of Wireless Application Protocol Forum Ltd. 2.3 Errata Known problems associated with this document are published at http://www.wapforum.org/. 2.4 Comments Comments   regarding   this   document   can   be   submitted   to   the   WAP   Forum   in   the   manner   published   at http://www.wapforum.org/. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 6 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved3. References [ClassConform] WAP Class Conformance Requirements, WAP Forum. [ECMAScript] Standard ECMA-262: \"ECMAScript Language Specification\", ECMA, June 1997 [HTML4] \"HTML 4.0 Specification, W3C Recommendation 18-December-1997, REC-HTML40-971218\", D. Raggett, et al., September 17, 1997. URL: http://www.w3.org/TR/REC-html40 [HTTPState] “HTTP State Management”, WAP-223-HTTPSM, WAP Forum. [JavaScript] \"JavaScript: The Definitive Guide\", David Flanagan. O’Reilly & Associates, Inc. 1997 [MMSEncapsulation] “WAP Multimedia Messaging Service Message Encapsulation”, WAP Forum. [ProvArch] “WAP Provisioning Architecture Overview”, WAP Forum. [PushArchOverview] “WAP Push Architectural Overview”, WAP Forum. [PushOTA] “WAP Push OTA Protocol”, WAP Forum. [RFC2045] \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", N. Freed, et al., November 1996. URL: http://www.rfc-editor.org/rfc/rfc2045.txt [RFC2048] \"Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures\", N. Freed, et al., November 1996. URL: http://www.rfc-editor.org/rfc/rfc2048.txt [RFC2119] \"Key words for use in RFCs to Indicate Requirement Levels\", S. Bradner, March 1997. URL: http://www.rfc-editor.org/rfc/rfc2119.txt [RFC2246] “The TLS Protocol Version 1.0”, T. Dierks, C. Allen, January 1999.   URL: http://www.rfc-editor.org/rfc/rfc2246.txt [RFC2396] “Uniform Resource Identifiers (URI): Generic Syntax”, T. Berners-Lee, R. Fielding, L. Masinter. August 1998. URL: http://www.rfc-editor.org/rfc/rfc2396.txt [RFC2401] “Security Architecture for the Internet Protocol”, S. Kent, R. Atkinson, November 1998.   URL: http://www.rfc-editor.org/rfc/rfc2401.txt [RFC2616] \"Hypertext Transfer Protocol - HTTP/1.1\", R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, T. Berners-Lee, June 1999.  URL: http://www.rfc-editor.org/rfc/rfc2616.txt [RFC2617] “HTTP Authentication: Basic and Digest Access Authentication”, J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence, P. Leach, A. Luotonen, L. Stewart, June 1999. URL: http://www.rfc-editor.org/rfc/rfc2617.txt [STD0006] “User Datagram Protocol”, J. Postel, August 1980.  URL: http://www.rfc-editor.org/rfc/std/std6.txt [STD0007] “Transmission Control Protocol”, J. Postel, September 1981.   URL: http://www.rfc-editor.org/rfc/std/std7.txt [STD0013] “Domain Name System”, P. Mockapetris, November 1987.   URL: http://www.rfc-editor.org/rfc/std/std13.txt [TransportE2ESec] “WAP Transport Layer End-to-End Security Specification”, WAP Forum. [UAProf] “User Agent Profile Specification”, WAP Forum.  [WAE] \"Wireless Application Environment Specification\", Version 2, WAP-236-WAESpec,  WAP Forum.  [WAPCert] “WAP Certificate and CRL Profiles”, WAP Forum. [WDP] \"Wireless Datagram Protocol Specification\", WAP Forum. [WIM] “WAP Identity Module Specification”, WAP Forum. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 7 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved[WML] \"Wireless Markup Language\", WAP Forum. [WMLScriptCrypto] “WMLScript Crypto Library”, WAP Forum. [WPKI] \"WAP Public Key Infrastructure Definition\", WAP Forum. [WSP] \"Wireless Session Protocol\", WAP Forum. [WTA] “Wireless Telephony Application Specification\", WAP Forum. [WTAI] \"Wireless Telephony Application Interface\", WAP Forum. [WP-TCP] “Wireless Profiled TCP Specification”, WAP Forum. [WTLS] \"Wireless Transport Layer Security Protocol\", WAP Forum. [WTP] \"Wireless Transaction Protocol Specification\", WAP Forum. [XHTML] “XHTML 1.1 – Module Based XHTML”, World Wide Web Consortium.   URL: http://www.w3.org/TR/xhtml11/ [XML] “Extensible Markup Language (XML) 1.0”, World Wide Web Consortium. URL: http://www.w3.org/TR/REC-xml/    WAP-210-WAPArch-20010712, Version 12-July-2001  Page 8 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved4. Definitions and Abbreviations 4.1 Definitions  The following are terms and conventions used throughout this specification. The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,  “SHOULD NOT”, “RECOMMENDED”,  “MAY”, and “OPTIONAL” in this document are to be interpreted as described by [RFC2119]. Author – an author is a person or program that writes or generates WML, WMLScript or other content. Client – a device (or application) that initiates a request for a connection with a server. Content – subject matter (data) stored or generated at an origin server. Content is typically displayed or interpreted by a user agent in response to a user request. Content Encoding – when used as a verb, content encoding indicates the act of converting content from one format to another. Typically the resulting format requires less physical space than the original, is easier to process or store and/or is encrypted. When used as a noun, content encoding specifies a particular format or encoding standard or process. Content Format – actual representation of content. Device –  a  network  entity  that  is  capable  of  sending  and  receiving  packets  of  information  and  has  a  unique  device  address. A device can act as both a client or a server within a given context or across multiple contexts. For example, a device can service a number of clients (as a server) while being a client to another server. JavaScript – a de facto standard language that can be used to add dynamic behaviour to HTML documents. JavaScript is one of the originating technologies of ECMAScript. Man-Machine Interface – a synonym for user interface. Origin Server – the server on which a given resource resides or is to be created. Often referred to as a web server or an HTTP server. Resource – a network data object or service that can be identified by a URI or URL. Resources may be available in multiple representations (e.g., multiple languages, data formats, size and resolutions) or vary in other ways. Server – a device (or application) that passively waits for connection requests from one or more clients. A server may accept or reject a connection request from a client. Terminal –  a  device  providing  the  user  with  user  agent  capabilities,  including  the  ability  to  request  and  receive  information. Also called a mobile terminal or mobile station. User – a user is a person who interacts with a user agent to view, hear, or otherwise use a resource. User Agent – a user agent is any software or device that interprets WML, WMLScript, WTAI or other resources. This may include textual browsers, voice browsers, search engines, etc. WMLScript –  a  scripting  language  used  to  program  the  mobile  device.  WMLScript  is  based  on  ECMAScript  and  loosely based on the JavaScript scripting languages. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 9 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved4.2 Abbreviations  For the purposes of this specification, the following abbreviations apply.  CGI Common Gateway Interface CPU Central Processing Unit DNS Domain Name System EFI External Functionality Interface HTML HyperText Markup Language [HTML4] HTTP HyperText Transfer Protocol [RFC2616] IP Internet Protocol MMI Man-Machine Interface MMS Multimedia Message Service OTA Over The Air PDA Personal Digital Assistant PICS Protocol Implementation Conformance Statement PKI Public Key Infrastructure RAM Random Access Memory RFC Request For Comments ROM Read Only Memory SCR Static Conformance Requirement SSL Secure Sockets Layer STD Internet Standard TCP Transmission Control Protocol [STD0007] TLS Transport Layer Security UDP User Datagram Protocol [STD0006] URI Uniform Resource Identifier [RFC2396] URL Uniform Resource Locator [RFC2396] W3C World Wide Web Consortium WAE Wireless Application Environment [WAE] WAP Wireless Application Protocol WDP Wireless Datagram Protocol [WDP] WIM Wireless Identity Module [WIM] WML Wireless Markup Language [WML] WPKI Wireless Public Key Infrastructure [WPKI] WAP-210-WAPArch-20010712, Version 12-July-2001  Page 10 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reservedWSP Wireless Session Protocol [WSP] WTA Wireless Telephony Application [WTA] WTAI Wireless Telephony Application Interface [WTAI] WTLS Wireless Transport Layer Security [WTLS] WTP Wireless Transaction Protocol [WTP] WWW World-Wide Web XHTML Extensible Hypertext Markup Language [XHTML] XML Extensible Markup Language [XML] WAP-210-WAPArch-20010712, Version 12-July-2001  Page 11 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved5. Background 5.1 Motivation WAP is positioned at the convergence of three rapidly evolving network technologies, wireless data, telephony, and the Internet. Both the wireless data market and the Internet are growing very quickly and are continuing to reach new customers. The explosive growth of the Internet has fuelled the creation of new and exciting information services. Most  of  the  original  technology  developed  for  the  Internet  has  been  designed  for  desktop  and  larger  computers  and  medium to high bandwidth, generally reliable data networks. Mass-market, hand-held wireless devices present a more constrained computing environment compared to desktop computers. Because of fundamental limitations of power and form-factor, mass-market handheld devices tend to have: • Less powerful CPUs, • Less memory (ROM and RAM), • Restricted power consumption, • Smaller displays, and • Different input devices (e.g., a phone keypad). Similarly, wireless data networks present a more constrained communication environment compared to wired networks. Because of fundamental limitations of power, available spectrum, and mobility, wireless data networks tend to have: • Less bandwidth, • More latency, • Less connection stability, and • Less predictable availability. Mobile networks are growing in complexity and the cost of all aspects of providing value-added services is increasing. In order to meet the requirements of mobile network operators, solutions must be: • Interoperable – terminals from different manufacturers communicate with services in the mobile network; • Scaleable – mobile network operators are able to scale services to customer needs; • Efficient – provides quality of service suited to the behaviour and characteristics of the mobile network; • Reliable – provides a consistent and predictable platform for deploying services; and • Secure –  enables  services  to  be  extended  over  potentially  unprotected  mobile  networks  while  still  preserving  the  integrity of user data; protects the devices and services from security problems such as loss of confidentiality. Many  of  the  current  mobile  networks  include  advanced  services  that  can  be  offered  to  end-users.  Mobile  network  operators strive to provide advanced services in a useable and attractive way in order to promote increased usage of the mobile  network  services  and  to  decrease  the  turnover  rate  of  subscribers.  Standard  features,  like  call  control,  can  be  enhanced  by  using  WAP  technology  to  provide  customised  user  interfaces.  For  example,  services  such  as  call  forwarding may provide a user interface that prompts the user to make a choice between accepting a call, forwarding to another person, forwarding it to voice mail, etc. The  nature  of  wireless  devices  is  that  they  are  inherently  mobile.    This  mobility  introduces  new  opportunities  for  services  that  are  sensitive  to  mobility  and  can  provide  location-dependent  information.    The  WAP  specifications  and  architecture capitalise on this unique aspect of wireless devices by including mobility as part of the application model. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 12 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reservedThe  WAP  specifications  address  mobile  network  characteristics  and  operator  needs  by  adapting  existing  network  technology  to  the  special  requirements  of  mass-market,  hand-held  wireless  data  devices  and  by  introducing  new technology where appropriate. The  WAP  specifications  will  accommodate  a  range  of  devices,  from  devices  that  provide  very  basic  functionality  to  devices that continue to expand their capabilities.  This motivates an architecture where functionality may be moved to different locations within the network as appropriate, i.e. either to devices or to network servers as necessary. 5.2 Architectural Goals The goals of the WAP Forum architecture are as follows.  This summary is informative and non-exhaustive; the order of the items does not represent any priority or importance. • Provide  a  web-centric application model for wireless data services that utilises the telephony, mobility, and other unique  functions  of  wireless  devices  and  networks  and  allows  maximum  flexibility  and  ability  for  vendors  to enhance the user experience. • Enable the personalisation and customisation of the device, the content delivered to it, and the presentation of the content. • Provide  support  for  secure  and  private  applications  and  communication  in  a  manner  that  is  consistent  and  interoperable with Internet security models. • Enable  wireless  devices  and  networks  that  are  currently  or  in  the  near  future  being  deployed,  including  a  wide  variety of bearers from narrow-band to wide-band. • Provide secure access to local handset functionality. • Facilitate network-operator and third party service provisioning. • Define a layered, scaleable and extensible architecture. • Leverage existing standards where possible, especially existing and evolving Internet standards. 6. Architecture Overview 6.1 The World-Wide Web Model The Internet World-Wide Web (WWW) architecture provides a very flexible and powerful programming model (Figure 1).  Applications  and  content  are  presented  in  standard  data  formats,  and  are  browsed by  applications  known  as  web browsers. The web browser is a networked application, i.e., it sends requests for named data objects to a network server and the network server responds with the data encoded using the standard formats.  Figure 1. World-Wide-Web Programming Model The  WWW  standards  specify  many  of  the  mechanisms  necessary  to  build  a  general-purpose  application  environment, including: WAP-210-WAPArch-20010712, Version 12-July-2001  Page 13 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved• Standard  naming  model  –  All  servers  and  content  on  the  WWW  are  named  with  an  Internet-standard Uniform Resource Locator (URL) [RFC2396]. • Content  typing  –  All  content  on  the  WWW  is  given  a  specific  type  thereby  allowing  web  browsers  to  correctly  process the content based on its type [RFC2045, RFC2048]. • Standard  content  formats  –  All  web  browsers  support  a  set  of  standard  content  formats.  These  include  the HyperText  Markup  Language  (HTML)  [HTML4],  scripting  languages  [ECMAScript,  JavaScript],  and  a  large  number of other formats. • Standard Protocols – Standard networking protocols allow any web browser to communicate with any web server. The  most  commonly  used  protocol  on  the  WWW  is  the  HyperText  Transport  Protocol  (HTTP)  [RFC2616],  operating on top of the TCP/IP protocol suite [STD0007]. This infrastructure allows users to easily reach a large number of third-party applications and content services. It also allows application developers to easily create applications and content services for a large community of clients. 6.2 The WAP Model The  WAP  programming  model  (Figure 2) is the WWW programming model with a few enhancements. Adopting the WWW  programming  model  provides  several  benefits  to  the  application  developer  community,  including  a  familiar  programming  model,  a  proven  architecture,  and  the  ability  to  leverage  existing  tools  (e.g.,  Web servers, XML tools, etc.). Optimisations and extensions have been made in order to match the characteristics of the wireless environment. Wherever  possible,  existing  standards  have  been  adopted  or  have  been  used  as  the  starting  point  for  the  WAP technology. The most significant enhancements WAP has added to the programming model are: • Push • Telephony Support (WTA)  Figure 2. WAP Programming Model The classical request-response mechanism is commonly referred to as pull to contrast it with the push mechanism. WAP content and applications are specified in a set of well-known content formats based on the familiar WWW content formats.  Content  is  transported  using  a  set  of  standard  communication  protocols  based  on  the  WWW  communication  protocols.  The  WAP  microbrowser  in  the  wireless  terminal  co-ordinates  the  user-interface  and  is  analogous  to  a  standard web browser. WAP defines a set of standard components that enable communication between mobile terminals and network servers, including: • Standard  naming  model  –  WWW-standard  URLs  are  used  to  identify  WAP  content  on  origin  servers.  WWW-standard URIs are used to identify local resources in a device, e.g. call control functions. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 14 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved• Content typing – All WAP content is given a specific type consistent with WWW typing. This allows WAP user agents to correctly process the content based on its type. • Standard  content  formats  –  WAP  content  formats  are  based  on  WWW  technology  and  include  display  markup,  calendar information, electronic business card objects, images and scripting language. • Standard  communication  protocols  –  WAP  communication  protocols  enable  the  communication  of  browser  requests from the mobile terminal to the network web server. The WAP content types and protocols have been optimised for mass market, hand-held wireless devices. 6.3 Feature/Performance-Enhancing Proxies  Figure 3. Feature/Performance-Enhancing Proxy WAP utilises proxy technology to optimise and enhance the connection between the wireless domain and the WWW. The WAP proxy may provide a variety of functions, including: • Protocol  Gateway  –  The  protocol  gateway  translates  requests  from  a  wireless  protocol  stack  (e.g.,  the  WAP  1.x  stack—WSP,  WTP,  WTLS,  and  WDP)  to  the  WWW  protocols  (HTTP  and  TCP/IP).  The  gateway  also  performs  DNS lookups of the servers named by the client in the request URLs. • Content  Encoders  and  Decoders  –  The  content  encoders  can  be  used  to  translate  WAP  content  into  a  compact  format that allows for better utilisation of the underlying link due to its reduced size. • User  Agent  Profile  Management  –  User  agent  profiles  describing  client  capabilities  and  personal  preferences  [UAProf] are composed and presented to the applications. • Caching  Proxy  –  A  caching  proxy  can  improve  perceived  performance  and  network  utilisation  by  maintaining  a  cache of frequently accessed resources. This infrastructure ensures that mobile terminal users can access a wide variety of Internet content and applications, and that application authors are able to build content services and applications that run on a large base of mobile terminals. The WAP proxy allows content and applications to be hosted on standard WWW servers and to be developed using proven WWW technologies such as CGI scripting. While the nominal use of WAP will include a web server, WAP proxy and WAP client, the WAP architecture can quite easily support other configurations. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 15 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved6.4 Supporting Servers  Figure 4. Supporting Services The WAP Architecture also includes supporting servers, which provide services to devices, proxies, and applications as needed.  These services are often specific in function, but are of general use to a wide variety of applications. The supporting servers defined by the WAP Forum include, but are not limited to: • PKI  Portal—The PKI Portal (shown in Figure 4) [WPKI] allows devices to initiate the creation of new public key certificates. • UAProf Server—The UAProf Server [UAProf] allows applications to retrieve the client capabilities and personal profiles of user agents and individual users. • Provisioning Server—The Provisioning Server [ProvArch] is trusted by the WAP device to provide its provisioning information. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 16 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved6.5 WAP Network Elements A typical WAP network is shown in Figure 5.   Figure 5. Example WAP Network WAP  clients  communicate  with  application  servers  through  a  number  of  different  proxies  or  directly.    WAP  clients  support the proxy selection mechanism that allows them to utilise the most appropriate proxy for a given service or to connect directly to that service as necessary. Proxies can be used to augment a request. They translate between WAP and WWW protocols (HTTP, TCP),  thereby allowing the WAP client to submit requests to the origin server.  Proxies may be located in a number of places, including wireless carriers or independent service providers in order to provide  feature  enhancements  coupled  to  the  wireless  network  (e.g.,  telephony,  location  and  provisioning)  or  to  optimise  the  communication  between  device  and  application  server  (e.g.,  protocol  translation  and  cookie  caching).    Proxies  may  be  located  in  a  secure  network  to  provide  a  secure  channel  between  wireless  device  and  the  secure  network. In  some  instances,  the  device  might  make  direct  connections  to  application  servers,  for  example  to  provide  a  secure  connection directly between the device and application server. The  supporting  servers  provide  support  functions  required  by  or  generally  useful  to  devices,  proxies,  and  application servers.  These functions include Provisioning, PKI, user agent profiles, etc. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 17 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved6.6 Device Architecture   Figure 6. WAP Client Architecture The  architecture  for  WAP  devices  is  shown  in  Figure 6.    The  Application  Framework  provides  the  device  execution  environment  for  WAP  applications.    WAP  applications  are  comprised  of  markup,  script,  style  sheets  and  multimedia  content, all of which are rendered on the device.  The WAP Application Environment (WAE) processing model defines the structure in which these various forms of executable and non-executable content interact.  The  network  protocols  on  the  WAP  client  are  shared  between  client  and  server.    They  are  described  in  further  detail  below.  Content renderers interpret specific forms of content and present them to the end user for perusal or interaction.  Common   functions   are   defined   to   be   utilised   by   the   application   framework,   including   persistence   and   data synchronisation. The Wireless Identity Module (WIM), as specified in [WIM], contains the identity of the device and the cryptographic means to mutually authenticate WAP devices and servers. The architecture also provides a mechanism to access external functions that are embedded or attached to the devices via the External Functionality Interface (EFI).  6.7 Security Model WAP enables a flexible security infrastructure that focuses on providing connection security between a WAP client and server. WAP  can  provide  end-to-end  security  between  protocol  endpoints.  If  a  browser  and  origin  server  desire  end-to-end security,  they  can  communicate  directly  using  the  security  protocols.      Moreover,  the  WAP  specifications  include  support for application-level security, such as signed text. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 18 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved7. Components of the WAP Architecture  Figure 7. WAP Stack Architecture The  WAP  architecture  provides  a  scaleable  and  extensible  application  development  environment    for  mobile communication devices. This is achieved through a layered design of the protocol stack (Figure 7). Each layer provides a set of functions and/or services to other services and applications through a set of well-defined interfaces. Each of the layers of the architecture is accessible by the layers above, as well as by other services and applications. The WAP architecture separates service interfaces from the protocols that provide those services to allow for evolution of  the  specifications  and  selection  of  the  most  appropriate  protocol  for  a  given  context.    Many  of  the  services in the stack may be provided by more than one protocol.  For example, either HTTP [RFC2616] or WSP [WSP] may provide the Hypermedia Transfer service.  7.1 Bearer Networks Protocols  have  either  been  designed  or  selected  to  operate  over  a  variety  of  different  bearer services, including short message, circuit-switched data, and packet data. The bearers offer differing levels of quality of service with respect to throughput,  error  rate,  and  delays.  The  protocols  are  designed  to  compensate  for  or  tolerate  these  varying  levels  of  service. Since the Transport Services layer provides the interface between the bearer service and the rest of the WAP stack, the transport  specifications  (e.g.,  [WDP])  may  list  the  bearers  that  are  supported  and  the  techniques  used  to  allow the protocols to run over each bearer. The list of supported bearers will change over time with new bearers being added as the wireless market evolves. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 19 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved7.2 Transport Services The Transport Services layer offers a set of consistent services to the upper layer protocols and maps those services to the available bearer services. The Transport Services transport unstructured data across the underlying bearer networks.  These transport services create a common abstraction that is consistent across all the bearers. The Transport Services include, but are not limited to: • Datagrams –  The  datagram  service  provides  data  transport  in  which  self-contained,  independent  entities  of  data  carry  sufficient  information  to  be  routed  from  the  source  to  the  destination  computer  without  reliance  on  earlier  exchanges  between  this  source  and  destination  computer  and  the  transporting  network.    UDP  (User  Datagram  Protocol)  [STD0006]  and  WDP  (Wireless  Datagram  Protocol)  [WDP]  are  two  protocols  used  to  provide  the datagram transport service in the WAP architecture. • Connections – The  connection  service  provides  data  transport  service  in  which  communication  proceeds  in  three  well-defined  phases:  connection  establishment,  two-way  reliable  data  transfer  and  connection  release.  TCP (Transmission Control  Protocol)  [STD0007]  is  a  protocol  used  to  provide  the  connection  transport  service  of  IP1 bearers for the WAP architecture. In order to cope with the wireless network characteristics, the TCP protocol can be profiled for its use, see [WP-TCP]. 7.3 Transfer Services The Transfer Services provide for the structured transfer of information between network elements. The Transfer Services include, but are not limited to: • Hypermedia Transfer – The  hypermedia  transfer  services  provides  for  the  transfer  of  self-describing hypermedia resources.  The combination of WSP (Wireless Session Protocol) [WSP] and WTP (Wireless Transaction Protocol) [WTP]  provide  the  hypermedia  transfer  service  over  secure  and  non-secure  datagram  transports.    The  HTTP  (Hypertext Transfer Protocol)  [RFC2616]  provides  the  hypermedia  transfer  service  over  secure  and  non-secure connection-oriented transports.  • Streaming – The streaming services provide a means for transferring isochronous data such as audio and video. • Message  Transfer  –  The  message  transfer  services  provide  the  means  to  transfer  asynchronous  multimedia  messages  such  as  email  or  instant  messages.    MMS  Encapsulation  [MMSEncapsulation]  is  a  protocol  used  to  transfer messages between WAP devices and MMS servers. 7.4 Session Services The session services provide for the establishment of shared state between network elements that span multiple network requests or data transfers.  For example, the Push session establishes that the WAP Device is ready and able to receive pushes from the Push Proxy. The Session Services include, but are not limited to: • Capability Negotiation – The WAP architecture includes specifications for describing, transmitting, and managing capabilities  and  preference  information  about  the  client,  user,  and  network  elements.    See  [UAProf]  for  more  information.  This allows for customisation of information and content returned by the origin server or pushed by the application. • Push-OTA –  The  Push-OTA  (Over  The  Air)  session  service  provides  for  network-initiated  transactions  to  be  delivered  to  wireless  devices  that  are  intermittently  able  to  receive  data  (e.g.,  modal  devices  and  devices  with  dynamically  assigned  addresses).    The  Push-OTA  service  operates  over  the  connection-oriented transport service and datagram transport [PushOTA].   • Sync – The Sync service provides for the synchronisation of replicated data.                                                                  1 Utilisation of TCP connections over IP may require additional components of the TCP/IP protocol suite. One example for such a component is ICMP. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 20 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved• Cookies – The Cookies service allows applications to establish state on the client or proxy that survives multiple hypermedia transfer transactions.  See [HTTPState] for more information. 7.5 Application Framework The  Application  Framework  provides  a  general-purpose  application  environment  based  on  a  combination  of  World  Wide Web (WWW), Internet and Mobile Telephony technologies. The primary objective of the Application Framework is  to  establish  an  interoperable  environment  that  will  allow  operators  and  service  providers  to  build  applications  and  services that can reach a wide variety of different wireless platforms in an efficient and useful manner.  The Application Framework includes, but is not limited to: • WAE/WTA  User-Agent –  WAE  is  a  micro-browser  environment  containing  or  allowing  for  markup  (including  WML  and  XHTML),  scripting,  style-sheet  languages,  and  telephony  services  and  programming  interfaces,  all  optimised for use in hand-held mobile terminals.  See [WAE] for more information. • Push –  The  Push  service  provides  a  general  mechanism  for  the  network  to  initiate  the  transmission  of  data  to  applications resident on WAP devices.  See [PushArchOverview] for more information. • Multimedia  Messaging  –  The  Multimedia  Message  Service  (MMS)  provides  for  the  transfer  and  processing  of  multimedia messages such as email and instant messages to WAP devices. • Content Formats – The application framework includes support for a set of well-defined data formats, such as color images, audio, video, animation, phone book records, and calendar information. 7.6 Security Services Security  forms  a  fundamental  part  of  the  WAP  Architecture,  and  its  services  can  be  found  in  many  of  its  layers.    In  general the following security facilities offered are: • Privacy – facilities to ensure that communication is private and cannot be understood by any intermediate parties that may have intercepted it. • Authentication – facilities to establish the authenticity of parties to the communication. • Integrity – facilities to ensure that communication is unchanged and uncorrupted. • Non-Repudiation – facilities to ensure parties to a communication cannot deny the communication took place. The  Security  Services  span  all  the  various  layers  of  the  WAP  Architecture.    Some  specific  examples  of  the  security  services include: • Cryptographic  Libraries  –  This  application  framework  level  library  provides  services  for  signing  of  data  for integrity and non-repudiation purposes.  See [WMLScriptCrypto] for more information. • Authentication –  The  Security  Services  provide  various  mechanisms  for  client  and  server  authentication.    At  the  Session Services layer HTTP Client Authentication [RFC2617] may be used to authenticate clients to proxies and application  servers.  At  the  Transport  Services  layer,  WTLS  and  TLS  handshakes  may  be  used  to  authenticate  clients and servers. • Identity –  WIM  provides  the  functions  that  store  and  process  information  needed  for  user  identification  and  authentication [WIM] • PKI – The set of security services that enable the use and management of public-key cryptography and certificates [WPKI], [WAPCert]. • Secure  Transport  –  The  Transport  Services  layer  protocols  are  defined  for  secure  transport  over  datagrams  and  connections.    WTLS  is  defined  for  secure  transport  over  datagrams  and  TLS  is  defined  for  secure  transport  over  connections (i.e. TCP). See [WTLS] and [WAPTLS] for more information. • Secure Bearer – Some bearer networks provide bearer level security.  For example, IP networks (especially in the context of IPv6) provide bearer-level security with IPSec [RFC2401]. WAP-210-WAPArch-20010712, Version 12-July-2001  Page 21 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reserved7.7 Service Discovery Service  discovery  forms  a  fundamental  part  of  the  WAP  Architecture  and  its  services  can  be  found  at  many  layers.    Some specific examples of Service Discovery services include: • EFI – The External Functionality Interface (EFI) allows applications to discover what external functions/services are available on the device. • Provisioning – The Provisioning service allows a device to be provisioned with the parameters necessary to access network services.  See [ProvArch] for more information. • Navigation Discovery – The Navigation Discovery service allows a device to discover new network services (e.g. secure  pull  proxies)  during  the  course  of  navigation  such  as  when  downloading  resources  from  a  hypermedia  server.    The  WAP  Transport-Level  End-to-End  Security  specification  [TransportE2ESec]  defines  one  navigation  discovery protocol. • Service  Lookup  –  The  Service  Lookup  service  provides  for  the  discovery  of  a  service’s  parameters  through  a  directory lookup by name.  One example of this is the Domain Name System (DNS) [STD0013]. 7.8 Other Services and Applications The WAP layered architecture enables other services and applications to utilise the features of the WAP stack through a set  of  well-defined  interfaces.  External  applications  may  access  the  various  services  directly.  The  WAP  layered  architecture  builds  upon  an  extensible  set  of  protocols.  This  allows  the  WAP  stack  to  be  used  for  applications  and  services  not  currently  specified  by  WAP,  but  deemed  to  be  valuable  for  the  wireless  market.  Such  applications  and  services  may  benefit  from  adding  protocols  or  particular  protocol  capabilities.  For  example,  applications,  such  as  electronic mail, calendar, phone book, notepad, and electronic commerce, or services, such as white and yellow pages, may be developed to use the WAP protocols. 8. Sample Configurations of WAP Technology Because several of the services in the WAP stack can be provided using different protocols based on the circumstances, there  are  more  than  one  possible  stack  configurations.    The  following  figures  depict  several  possible  protocol  stacks  using  WAP  technology.  These  are  for  illustrative,  informative  purposes  only  and  do  not  constitute  a  statement  of conformance or interoperability, nor is this set of examples exhaustive.   Figure 8. Example WAP 1.x Gateway WAP-210-WAPArch-20010712, Version 12-July-2001  Page 22 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reservedFigure 8  depicts  the  protocol  stacks  for  the  original  WAP  architecture.    The  WAP  Gateway  converts the hypermedia transfer service between the datagram-based protocols (WSP, WTP, WTLS, WDP) and connection-oriented protocols commonly used on the Internet (HTTP, SSL, TCP).    Figure 9. Example WAP HTTP Proxy with Profiled TCP and HTTP  Figure 9 depicts a WAP HTTP proxy. The proxy configuration is widely used in the Internet for ordinary web access, multimedia  data,  e.g.  music,  video  clip  downloading  and  so  on.    This  configuration  locates  the  WAP  Proxy between wireline and wireless networks to enhance performance by using the wireless profile of TCP (as shown with TCP*). In addition to TCP optimisations, the wireless profile of HTTP  (as illustrated by HTTP*) allows for further performance enhancements.  Both  profiles  comprise  well-defined  IETF  options  that  provide  for  efficient  operation  over  wireless  networks as within the scope of WAP. The wireless profiled versions are interoperable with TCP and HTTP.   Figure 10. Example WAP Proxy Support for TLS Tunneling WAP-210-WAPArch-20010712, Version 12-July-2001  Page 23 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reservedFigure 10  depicts  a  WAP  HTTP  proxy  that  has  established  a  connection-oriented  tunnel  to  the  web  server  (e.g.,  in  response to a CONNECT command).  This configuration is used to allow TLS to provide end-to-end security between mobile terminal and origin server. E-commerce is a compelling use case for end-to-end security.    Figure 11. Example Direct Access Figure 11 depicts a WAP device directly accessing a Web Server via the Internet.  The wireless IP router is a standard part of an IP network that is used to transfer IP packets from one link layer (e.g., the wireless link) to another (e.g., the wired link).  This configuration can apply to the case where bearer-level security (such as IPSec) is utilised. In the Direct Access scenario, wireless optimisations as defined by the Wireless Profiles for TCP and HTTP may not be available.   Figure 12. Dual Stack Support WAP-210-WAPArch-20010712, Version 12-July-2001  Page 24 (24)  Copyright Wireless Application Protocol Forum, Ltd, 2000-2001All rights reservedWhile  the  previous  configurations  show  single  protocol  stacks  for  each  of  WAP  configuration,  Figure 12 depicts a device that supports both the 1.x and 2.x protocol stacks.  This configuration is useful in cases where a device needs to interoperate with both old a new WAP servers.  9. Conformance and Interoperability The  WAP  Forum  views  vendor  interoperability  as  an  important  element  to  the  success  of  WAP  products.  In  order  to  provide  as  high  a  probability  as  is  technically  possible  that  two  WAP  products  developed  independently  by  two  different vendors will successfully interoperate, a rigorous definition of conformance, compliance, and testing has been developed. Conformance answers the question, “Does an implementation meet the standard as written?”  The WAP Forum charters a  neutral  third  party  to  build  a  comprehensive  test  suite  from  its  specifications.    Usually,  implementations  are  tested  against known references. Interoperability  answers  the  question,  “Will  this  implementation  work  with  other  products  developed  to  the  same  standard?”    Interoperability  testing  uses  a  test  suite  designed  to  test  implementation  to  implementation  compatibility,  and implementations are tested against each other.  Interoperability testing is not focused on compliance—two products with the same non-compliant implementation will be interoperable.  Figure 13. Interoperability and Compliance The  WAP  Forum  Certification  Program  is  focused  on  conformance,  but  offers  some  interoperability  testing  as well.  The Certification Program covers the entire value chain as shown in Figure 13. To  improve  interoperability  at  the  authoring  level,  the  WAP  Forum  provides  authoring  guidelines  to  improve  the  accessibility of WAP content.   To certify WAP clients and servers, the WAP Forum conducts interoperability testing of an implementation against multiple reference implementations using a predefined suite of test cases. The  WAP  Forum  has  defined  a  number  of  Class  Conformance  Profiles,  e.g.  Class  A,  Class  B,  and  Class  C.    An  implementation  may  be  certified  in  one  or  more  class.    The  class  conformance  requirements  are  specified  in  [ClassConform]. Each WAP Specification includes static conformance requirements (SCRs) for that specification.  These define which features are mandatory and optional and are the basis for the conformance test suite."},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-237-WAEMT-20010515-a.pdf","file":"WAP-237-WAEMT-20010515-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless Application Protocol (WAP) is a result of continuous work to define an industry wide specification for developing applications that operate over wireless communication networks. The scope for the WAP Forum is to define a set of specifications to be used by service applications. The wireless market is growing very quickly and reaching new customers and services. To enable operators and manufacturers to meet the challenges in advanced services, differentiation and fast/flexible service creation, WAP defines a set of protocols in transport, session and application layers.   Wireless Application Environment (WAE) is part of the WAP Forum's effort to specify an application framework for wireless terminals such as mobile phones, pagers, and PDAs.  The framework extends and leverages other WAP technologies, including WTP and WSP, as well as other Internet technologies such as XML, URLs, scripting, and various media types.  The effort enables operators, manufacturers, and content developers to meet the challenges in building advanced and differentiating services and implementations in a fast and flexible manner. This specification defines content formats that are optimised for wireless environment. Currently, this specification includes following format: • Wireless BitMaP (WBMP) For a general feature of the overall WAE architecture, please refer to [WAESpec]"},{"url":"http://www.openmobilealliance.org/release/Browsing/V2_4-20080923-C/WAP-238-WML-20010911-a.pdf","file":"WAP-238-WML-20010911-a.pdf","status":"","version":"","date":"","contentMediaType":"application/pdf","description":"Wireless  Application  Protocol  (WAP)  is  a  result  of  continuous  work  to  define  an  industry-wide  specification  fordeveloping applications that operate over wireless communication networks. The scope for the WAP Forum is to definea set of specifications to be used by service applications. The wireless market is growing very quickly and reaching newcustomers  and  services.  To  enable  operators  and  manufacturers  to  meet  the  challenges  in  advanced  services,differentiation, and fast/flexible service creation, WAP defines a set of protocols in transport, session, and applicationlayers. For additional information on the WAP architecture, refer to [WAPARCH].This specification defines the Wireless Markup Language version 2.0 (WML2), a language that extends XHTML withthe unique semantics of WML1 [WML1].WML2 is used for backwards compatibility only. It is not intended for content authoring. WAP2 content is created withXHTML Mobile Profile [XHTMLMP].The complete behaviour for a WAE user agent is not described in this specification, only the WML2 specific behaviour.In  order  to  build  a  WAE  compliant  user  agent,  this  specification  must  be  read  in  conjunction  with  the  WirelessApplication Environment Specification [WAE]."}]}}